{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to FMKit FMKit (i.e., F inger M otion analysis software Kit ) is a code library and data repository for finger motion based in-air-handwriting analysis. Besides, we have also built a demo system for FMKit. See the video and demo . The FMKit Code Library The FMKit library contains a set of Python code and scripts to model and process in-air-handwriting signals. See the \" FMKit GitHub repository \". An overview is shown as follows. code_fmkit ---> The main library code written in Python. The \" fmsignal.py \" module contains the classes modeling the finger motion signal. The \" fmsignal_vis.py \" module contains functions to plot and animate the signal and the trajectory. The \" fmsignal_demo.py \" module contains demo code for the user manual on signal manipulation . The \"pyrotation\" module is copied from the pyrotation project, which is necessary for finger motion signal preprocessing. code_utilities ---> Utility code written in C to speed up the Dynamic Time Warping calculation. data_demo ---> Some example in-air-handwriting signals, collected using two devices. meta_demo ---> Metadata of the datasets. The FMKit code library requires the following software packages Python 3 (tested with Python 3.6.9) NumPy (tested with NumPy 1.19.5) Matplotlib (tested with 3.1.2) To use this code library, just download the Python modules under the \"code_fmkit\" folder and incorporate into your project. The FMKit Data Repository The FMKit data repository contains multiple datasets, all collected using two types of devices (shown in the following figure): a wearable device (a custom-made data glove with inertial sensors) and a contactless 3D camera (the Leap Motion controller). The glove has a few variants with slightly different form factors (e.g., glove or hand band) and microcontrollers, but the essential motion sensors and the obtained signals are identical. Currently, the following datasets are available. See the \" The FMKit Data Repository \" section in \"The FMKit Architecture\" document for further details. (1) ID-passcode : This dataset contains in-air-handwriting signals of ID strings and passcodes by users for login through a gesture interface. (2) ID-passcode-collision : This dataset contains in-air-handwriting signals of ID strings and passcodes by imposters (knowing the contents but without seeing the original users' hand movements). The contents of ID strings and passcodes are the same as the dataset \"ID-passcode\". (3) ID-passcode-spoofing : This dataset contains in-air-handwriting signals of ID strings and passcodes by imposters (knowing the contents and seeing the original users' hand movements). The contents of ID strings and passcodes are the same as the dataset \"ID-passcode\". (4) ID-passcode-persistence : This dataset contains in-air-handwriting signals of ID strings and passcodes by users for multiple sessions in different days. The contents of ID strings and passcodes are the same as the dataset \"ID-passcode\". (5) word-210 : This dataset contains in-air-handwriting signals of 210 English words and 210 Chinese words. (6) FMCode-survey : This dataset contains the survey results on the subjective evaluation of the usability of a gesture sign-in system (i.e., FMCode ). This dataset construction effort has IRB approval from the authors' institute (Arizona State University STUDY00008279 and STUDY00010539). Currently, the \"word-210\" dataset is openly available here . If you would like to use other datasets related to in-air-handwriting of ID and passcode, please send an email application to our academic advisor Dr. Dijiang Huang (see the \"Authors\" section below). Authors Duo Lu < duolu AT asu DOT edu > - main contributor, current maintainer of the project. Yuli Deng < ydeng19 AT asu DOT edu > - contributor. Linzhen Luo < lluo21 AT asu DOT edu > - contributor. Dijiang Huang < dijiang.huang AT asu DOT edu > - our academic advisor and sponsor. Papers and Patents Dijiang Huang, Duo Lu, \" Three-Dimensional In-The-Air Finger Motion based User Login Framework for Gesture Interface \", US Patent 10,877,568, 2020. [link] Duo Lu, Linzhen Luo, Dijiang Huang, Yezhou Yang, \" FMKit: An In-Air-Handwriting Analysis Library and Data Repository. \" CVPR Workshop on Computer Vision for Augmented and Virtual Reality, 2020. [pdf] [link] [video] Duo Lu, Dijiang Huang, \" FMCode: A 3D In-the-Air Finger Motion Based User Login Framework for Gesture Interface. \" arXiv preprint arXiv:1808.00130, 2018. [pdf] [link] Duo Lu, Dijiang Huang, \" FMHash: Deep Hashing of In-Air-Handwriting for User Identification. \" in Proceedings of the International Conference on Communication (ICC), 2019 [pdf] [link] [slides] [video] Duo Lu, Dijiang Huang, Yuli Deng, and Adel Alshamrani. \" Multifactor user authentication with in-air-handwriting and hand geometry. \" In 2018 International Conference on Biometrics (ICB), 2018. [pdf] [link] [slides] [poster] Duo Lu, Kai Xu, and Dijiang Huang, \" A Data Driven In-Air-Handwriting Biometric Authentication System. \", in Proceedings of the International Joint Conference on Biometrics (IJCB), 2017. [pdf] [link] [slides] License This project is licensed under the MIT License - see the LICENSE.md file for details Acknowledgments We would like to thank all participants and volunteers who helped us collecting the data. This project is supported by NSF CCRI award #1925709 .","title":"Home"},{"location":"#welcome-to-fmkit","text":"FMKit (i.e., F inger M otion analysis software Kit ) is a code library and data repository for finger motion based in-air-handwriting analysis. Besides, we have also built a demo system for FMKit. See the video and demo .","title":"Welcome to FMKit"},{"location":"#the-fmkit-code-library","text":"The FMKit library contains a set of Python code and scripts to model and process in-air-handwriting signals. See the \" FMKit GitHub repository \". An overview is shown as follows. code_fmkit ---> The main library code written in Python. The \" fmsignal.py \" module contains the classes modeling the finger motion signal. The \" fmsignal_vis.py \" module contains functions to plot and animate the signal and the trajectory. The \" fmsignal_demo.py \" module contains demo code for the user manual on signal manipulation . The \"pyrotation\" module is copied from the pyrotation project, which is necessary for finger motion signal preprocessing. code_utilities ---> Utility code written in C to speed up the Dynamic Time Warping calculation. data_demo ---> Some example in-air-handwriting signals, collected using two devices. meta_demo ---> Metadata of the datasets. The FMKit code library requires the following software packages Python 3 (tested with Python 3.6.9) NumPy (tested with NumPy 1.19.5) Matplotlib (tested with 3.1.2) To use this code library, just download the Python modules under the \"code_fmkit\" folder and incorporate into your project.","title":"The FMKit Code Library"},{"location":"#the-fmkit-data-repository","text":"The FMKit data repository contains multiple datasets, all collected using two types of devices (shown in the following figure): a wearable device (a custom-made data glove with inertial sensors) and a contactless 3D camera (the Leap Motion controller). The glove has a few variants with slightly different form factors (e.g., glove or hand band) and microcontrollers, but the essential motion sensors and the obtained signals are identical. Currently, the following datasets are available. See the \" The FMKit Data Repository \" section in \"The FMKit Architecture\" document for further details. (1) ID-passcode : This dataset contains in-air-handwriting signals of ID strings and passcodes by users for login through a gesture interface. (2) ID-passcode-collision : This dataset contains in-air-handwriting signals of ID strings and passcodes by imposters (knowing the contents but without seeing the original users' hand movements). The contents of ID strings and passcodes are the same as the dataset \"ID-passcode\". (3) ID-passcode-spoofing : This dataset contains in-air-handwriting signals of ID strings and passcodes by imposters (knowing the contents and seeing the original users' hand movements). The contents of ID strings and passcodes are the same as the dataset \"ID-passcode\". (4) ID-passcode-persistence : This dataset contains in-air-handwriting signals of ID strings and passcodes by users for multiple sessions in different days. The contents of ID strings and passcodes are the same as the dataset \"ID-passcode\". (5) word-210 : This dataset contains in-air-handwriting signals of 210 English words and 210 Chinese words. (6) FMCode-survey : This dataset contains the survey results on the subjective evaluation of the usability of a gesture sign-in system (i.e., FMCode ). This dataset construction effort has IRB approval from the authors' institute (Arizona State University STUDY00008279 and STUDY00010539). Currently, the \"word-210\" dataset is openly available here . If you would like to use other datasets related to in-air-handwriting of ID and passcode, please send an email application to our academic advisor Dr. Dijiang Huang (see the \"Authors\" section below).","title":"The FMKit Data Repository"},{"location":"#authors","text":"Duo Lu < duolu AT asu DOT edu > - main contributor, current maintainer of the project. Yuli Deng < ydeng19 AT asu DOT edu > - contributor. Linzhen Luo < lluo21 AT asu DOT edu > - contributor. Dijiang Huang < dijiang.huang AT asu DOT edu > - our academic advisor and sponsor.","title":"Authors"},{"location":"#papers-and-patents","text":"Dijiang Huang, Duo Lu, \" Three-Dimensional In-The-Air Finger Motion based User Login Framework for Gesture Interface \", US Patent 10,877,568, 2020. [link] Duo Lu, Linzhen Luo, Dijiang Huang, Yezhou Yang, \" FMKit: An In-Air-Handwriting Analysis Library and Data Repository. \" CVPR Workshop on Computer Vision for Augmented and Virtual Reality, 2020. [pdf] [link] [video] Duo Lu, Dijiang Huang, \" FMCode: A 3D In-the-Air Finger Motion Based User Login Framework for Gesture Interface. \" arXiv preprint arXiv:1808.00130, 2018. [pdf] [link] Duo Lu, Dijiang Huang, \" FMHash: Deep Hashing of In-Air-Handwriting for User Identification. \" in Proceedings of the International Conference on Communication (ICC), 2019 [pdf] [link] [slides] [video] Duo Lu, Dijiang Huang, Yuli Deng, and Adel Alshamrani. \" Multifactor user authentication with in-air-handwriting and hand geometry. \" In 2018 International Conference on Biometrics (ICB), 2018. [pdf] [link] [slides] [poster] Duo Lu, Kai Xu, and Dijiang Huang, \" A Data Driven In-Air-Handwriting Biometric Authentication System. \", in Proceedings of the International Joint Conference on Biometrics (IJCB), 2017. [pdf] [link] [slides]","title":"Papers and Patents"},{"location":"#license","text":"This project is licensed under the MIT License - see the LICENSE.md file for details","title":"License"},{"location":"#acknowledgments","text":"We would like to thank all participants and volunteers who helped us collecting the data. This project is supported by NSF CCRI award #1925709 .","title":"Acknowledgments"},{"location":"arch/","text":"The FMKit Architecture Hand-gesture and in-air-handwriting provide ways for users to input information in Augmented Reality (AR) and Virtual Reality (VR) applications where a physical keyboard or a touch screen is unavailable. However, understanding the movement of hands and fingers is challenging, which requires a large amount of data and data-driven models. In this project, we propose an open research infrastructure named FMKit for in-air-handwriting analysis, which contains a set of Python libraries and a data repository collected from more than 180 users using two different types of motion capture sensors. We also present three research tasks enabled by FMKit, including in-air-handwriting based user authentication, user identification, and word recognition, with preliminary baseline performance. Introduction In AR/VR applications, 3D in-air hand gestures are natural ways to interact with virtual objects as well as a method to input information [3, 9, 10, 14]. Besides simple gestures like tap, scroll, slide, etc, there are cases when complicated information such as text or identity is needed to be presented to the software as input. Consider the scenario shown in Figure 1, a dialog pops up to an AR/VR user asking a passcode, an ID, or a short piece of text information (e.g., a tweet) as input information. One possible method is using in-air-handwriting [4, 15], i.e., instead of typing, the user can write a piece of information in the air, and ask the computer to recognize it. However, there are a few challenges. First, recognizing patterns in hand motion generally requires a large amount of data to train machine learning models, but the data collection is generally expensive. Second, there is no standard hand motion capture device and data collection procedures, and existing works choose their own ways, which makes the datasets incompatible and hard to compare. Additionally, most of them are not openly available. Third, given different motion capture devices and multiple in-air-handwriting related tasks solved using various algorithms, these mix-and-matches make it difficult to fairly evaluate different systems and compare their performance results [2]. To the best of our knowledge, the only open datasets of in-air-handwriting are constructed for word recognition [11, 4] using the Leap Motion controller. Figure 1: In-air-handwriting as input to AR/VR applications. In this project, we construct FMKit (Finger Motion analysis Kit), an open-source library and open datasets for in-air-handwriting analysis. Currently, FMKit contains several datasets of in-air-handwriting motion for various purposes. There are 103K data signals in total. Especially, each dataset has two parts collected in identical scenarios with the same in-air-handwriting content using two different motion capture devices, so that the results of the two devices can be compared. We also release the details of the devices, signal characterization, data collection protocols, and the source code of the client software so that researchers can easily extend our datasets. Meanwhile, we propose three types of research tasks enabled by the FMKit infrastructure: user authentication [1, 12, 13, 6, 8], user identification [5, 7], and in-air-handwriting word recognition [4, 15], which corresponds to the three types of inputs in Figure 1. Additionally, we provide the baseline performance for these tasks with our dataset. We hope this open infrastructure helps researchers to validate models, benchmark the performance of algorithms, and further facilitate data-driven approaches that can be generalized across sensor types for in-air-handwriting analysis. Devices The FMKit data repository contains multiple datasets, all collected using two types of devices (shown in Figure 2): a wearable device (a custom-made data glove with inertial sensors) and a contactless 3D camera (the Leap Motion controller). The Leap Motion controller can capture the 3D position of each joint of the hand at about 110 Hz with an 135 degree Field of View (FOV) and a depth range of 60 cm. Usually only the tip of the index finger or the palm center is interested. However, we discover that the tracking results of fingers are not always reliable, especially when the hand moves quickly or when the index finger points to certain directions (occluded by the palm from the perspective of the camera. The data glove can track the 3D acceleration and angular speed of the tip of the index finger at 100 Hz, using a Micro-Electro-Mechanical System (MEMS) Inertial Measurement Unit (IMU). Specifically, we use the Bosch BNO055 IMU. The glove also has an identical IMU on the thumb but that sensor is generally not used. The data glove has a few variants with slight differences in form factors, microcontrollers, and IMU orientations. However, the essential motion sensors and the obtained signals are the same. Both devices are relatively inexpensive (roughly $100) and their capabilities are similar to existing VR/AR platforms with a gesture user interface with similar sensors for hand motion capture. Figure 2: The custom data glove device (left) and the Leap Motion controller (right). In-Air-Handwriting Signal The basic unit of data in our datasets is called a \" signal \", which is a recorded piece of hand movement of writing a string in the air. Examples of raw signals are shown in Figure 3. Figure 3: The left figure shows an example of the finger motion trajectory of writing \"apple\" together with the hand skeleton captured by the Leap Motion controller. The right figure shows an example of the signal containing the acceleration and the angular speed obtained from the data glove when writing the same word \"apple\" by the same person. These signals are the \"raw signals\" directly from the device. The Python module \" fmsignal.py \" is constructed to model the signal obtain from sensor devices. It also has those routines for preprocessing. Also, the Python module \" fmsignal_vis.py \" is built to facilitate the inspection and visualization of signals. Additionally, the Python module \" fmsignal_demo.py \" contains code for demonstrating the usage of the code library. Also see the \" User Manual - Signal \". There are essentially four types of signals: Raw signal from the Leap Motion device, represented by the \" FMSignalLeap \" class. Raw signal from the data glove device, represented by the \" FMSignalGlove \" class. Preprocessed signal from the Leap Motion device, represented by the \" FMSignal \" class. Preprocessed signal from the data glove device, also represented by the \" FMSignal \" class. Note that the \"FMSignal\" class is actually device agnostic. All preprocessed signals have the same format. These four types of signals share a lot in common, and we collectively call them \"signals\". A signal is created by a user writing some content. Sometimes the user writes the same content in multiple repetitions to generate a set of signals. Hence, a signal object in any of the four types has a \"user\" attribute to indicate the writer, a \"cid\" (i.e., content ID) attribute to indicate the content, and a \"seq\" attribute to indicate one of the repetitions in a set (if it is just a standalone signal, \"seq\" is simply zero). A signal is a time series containing samples of physical states of the fingers. The time series is denoted as a two dimensional array s = ( s 1 , s 2 , ..., s i , ..., s l ), and each sample (or row) of s is s i = ( s i1 , s i2 , ..., s ij , ..., s id ). Here \"l\" is the number of samples and \"d\" is the number of sensor axes, i.e., the first dimension is the time, and the second dimension is the sensor axes. Depending on the type of signals, the meaning of each element (or column) s ij is different. For a preprocessed signal, it has 18 sensor axes (i.e., \"d\" is 18), as follows. 0 - 2: position in x-y-z. 3 - 5: velocity in x-y-z. 6 - 8: linear acceleration in x-y-z (i.e., the gravity \"g\" is removed). 9 - 11: orientation (currently, it is the qx, qy, qz components of a unit quaternion). 12 - 14: angular speed in x-y-z. 15 - 17: angular acceleration in x-y-z. Note that the \"FMSignal\" class is actually device agnostic, and hence, preprocessed signals all have these 18 sensor axes regardless of the motion capture devices. It represents the motion state of a single point on the hand, either the tip of the index finger or the center of the hand (which can be chosen at the preprocessing procedure). This two dimensional array is represented by the \"data\" attribute of the \"FMSignal\" class. It is a NumPy ndarray object. The \"dtype\" is always \"np.float32\". For raw signals, the sensor axes are specific to the device, which is more complicated. However, the only thing needs to be done for the raw signal is the preprocessing so as to obtain a preprocessed signal. The preprocessing contains the following steps. Down-sampling the signal to 50 Hz with linear interpolation on each sensor axis. Normalizing the signal reference frame,i.e., set the average position as the origin, the average hand pointingdirection as the x-axis, and the horizontal left as the y-axis. For each signal sample, deriving the 18 axes mentioned above from the raw sensor data. Low-pass filtering with a threshold frequency of 10 Hz. Trimming the start and end of the signal when the hand does not move. (Optional) Normalizing the whole signal in each sensor axis to zero mean and unit variance. (Optional) Normalizing thesignal length to 256 samples with linear interpolation. The last two steps of preprocessing are usually only needed for specific tasks. The samples of a signal are generated at a constant rate and each sample s i is associated with a timestamp \"ts i \". All signals created by the same user writing the same content can construct a set S = { s (1) , s (2) , ..., s (k) }, where \"k\" is essentially the \"seq\" attribute of a signal. Given such a set S, a template t can be generated by aligning all signals in S to the first signal and average all the algigned signals. The template is represented by the \" FMSignalTemplate \" class. A template has the same attributes as an ordinary signal. The aligning process is typically done through Dynamic Time Warping (DTW), which is also widely used for signal comparison and authentication tasks. Datasets Currently, the following datasets are available. (1) ID-passcode : We asked each user to create two distinct meaningful strings as an ID string and a passcode. The content of the string is determined by the user. Such a string may include alphanumeric letters, characters in a language other than English, or meaningful symbols such as five-pointed stars. Once the strings are created, we ask the user to write each string in-the-air for 5 repetitions as registration and another 5 repetitions as login attempts, using each device. This simulates the normal sign-up and sign-in procedure. In total, there are 360 (strings) * 10 (repetitions) * 2 (devices) = 7,200 signals. In this dataset, the content of the string is determined by the user. We strongly recommend the users avoid using the ID or password they use in their daily lives, but we did not forbid the users to write their name as ID strings because most of the in-air-handwriting are illegible like a signature and the content is hard to read. 58 users wrote words in Chinese for both strings. The remaining 122 users wrote alphanumerical strings. We asked each user to create a unique ID string so that all 180 ID strings have unique contents. However, there are no such constraints for the passcodes. Surprisingly, all 180 passcode strings also have unique contents. In fact, there is only one ID string that has the same content as another passcode. They are created by different users, who both choose the string \"helloworld\" but for different purposes. As a general guideline, we discourage simple strings for passcode such as \"123456\", and we recommend that the length of an alphanumerical string be at least eight characters. However, it is not a strict restriction, and a few users still created simple and short strings like \"USA\" or \"abc123\". Many users chose a combination of letters and numbers like a traditional password typed on a keyboard, e.g., \"stevenC909\", or meaningful phrases, \\textit{e.g.}, \"PondLakeOcean\", while some users chose a combination without an obvious meaning, e.g., \"sqwz1457\", and one user drew three five-pointed stars as a passcode. For privacy reasons, the contents of the ID and passcode are not disclosed. (2) ID-passcode-collision : We asked 10 skilled imposters to imitate the in-air-handwriting of the ID and passcode generated by the users in the \"ID-passcode\" dataset. In this setting, the imposters know the semantic meaning of the strings written by the legitimate users, but the imposters have not seen the legitimate users writing the ID and passcode in the air, which simulates the case of ID or passcode collision, or spoofing attack with semantic leakage. For each string in the \"ID-passcode\" dataset, we ask each imposter to write it with 5 repetitions using each device. In total, there are 360 (strings) * 10 (imposters) * 5 (repetitions) * 2 (devices) = 36,000 signals. (3) ID-passcode-spoofing : Similar to the \"ID-passcode-collision\" dataset, we asked 10 skilled imposters to imitate the in-air-handwriting of the ID and passcode generated by the users in the \"ID-passcode\" dataset. In this setting, the imposters can watch the recorded video of the in-air-handwriting and they will be informed with the semantic meaning of the in-air-handwriting. There are 180 string in the \"ID-passcode\" dataset where the user allows us to record a video of the hand movement (exactly 90 ID strings and 90 passcodes corresponding to 90 users). For each of the 180 strings, we ask each imposter to write it with 5 repetitions using each device. In total, there are 360 (strings) * 10 (imposters) * 5 (repetitions) * 2 (devices) = 18,000 signals. (4) ID-passcode-persistence : We kept collecting the sign-in in-air-handwriting of a subset of the users in the \"ID-passcode\" dataset for a period of about 4 weeks, which simulates login activity in the long term. In that dataset, the user wrote each string 5 repetitions as registration, while in this dataset, besides the registration, the users wrote the strings for the account ID and the account passcode 5 repetitions in a day as a session. There are 10 sessions in total and the data of each session is collected in a different day. 40 users participated in this dataset. In total there are 80 (strings) * 10 (imposters) * 5 (repetitions) * 2 (devices) = 8,000 data samples. (5) word-210 : We asked 10 users to write 210 English words and another 10 users to write 210 Chinese words, with 5 repetitions for each word using both devices. The user is asked to write in a legible way. In total, there are 2 (languages) * 210 (strings) * 10 (writers) * 5 (repetitions) * 2 (devices) = 42,000 data samples. (6) Usability Survey : We asked the participating users to fill a survey on the usability of gesture sign-in system with various sensors and different types of gestures. 100 users responded to the survey. Besides, we are currently working on an extension of the \"word-210\" dataset, named word-10k . As the name suggests, this dataset contains 10,000 English words and 10,000 Chinese words, where each English word is written by at least 10 different users with one repetition and each Chinese word is written by at least 10 different users with one repetition. In total, there will be at least 400,000 signals. It is currently work-in-progress and this dataset construction is supposed to be finished by the end of year 2021. Currently, the \"word-210\" dataset is openly available here . If you would like to use other datasets related to in-air-handwriting of ID and passcode, please send an email application to us (see the \"Authors\" section in the home page ). Data Collection Protocols The detailed procedure for the Leap Motion controller device is shown in Figure 4. The data collection is done on several identical Linux desktop and Linux laptop machines. On each machine, three Linux console terminals are opened, one for the Leap Motion daemon process (i.e., typing \"sudo leapd\" in the commandline), one for the Leap Motion control panel as well as the visualizer (typing \"LeapControlPanel --showsettings\" and then launch the \"diagnose visualizer\"), and the last for the actual data collection program (typing \"python ./client_leap.py xxx.txt\" in the commandline or launch the client program with a GUI). At the beginning of the writing of one string, the participant typically hover the hand above the sensor, like that in the following figure. Once the data collection starts, i.e., immediately after the \"client_leap.py\" script executes or the \"start/stop\" button on the GUI client is clicked, the hand starts to move. At the end of the writing of one string, the hand restores to the initial position or stop at the last stroke. The data collection program can be stopped by the user, i.e., press the \"space\" key or clicking the \"start/stop\" button (typically for the \"word-210\" dataset), or it can automatically stop if the user's hand stops moving for roughly 1 second (typically for the datasets related to ID string and passcode). The participant can write from left to right or just write every letter at the same place. Figure 4: Data collection procedure for the Leap Motion controller device. The procedure for the data glove is similar. Only one Linux console terminal is needed for the actual data collection program. Different from the Leap Motion controller where the user must write within the field of view of the sensor, the data glove does not have such constraints. The user can just start moving after the data collection program starts to collect data. When the user finishes writing, the data collection program can be stopped in the same way as that for the Leap Motion controller. Each captured handwriting signal is an individually named file. In the \"ID-passcode\" dataset, for the ID string, it is typically \"id_id_xx.csv\", where \"xx\" the sequence number of the repetition. For example, if the ID string is \"alice\", the file is named as \"alice_alice_0.csv\" for the first repetition. For the passcode, similarly, it is \"id_passcode_xx.csv\". For example, if the ID string is \"alice\" and the passcode is \"FMKit\", the file name is \"alice_FMKit_0.csv\". If the user chooses to write in Chinese, pinyin is used in the file name to indicate the content. To protect the privacy, We removed any tags and metadata that is sensitive to user identity. Files storing the data are renamed to something like \"user0_user0_0.csv\" for an ID string and \"user0_passcode0_0.csv\" for a passcode. In this way, we can immediately know which user generates which signal for what content from the file name while debugging the code and tuning trained models. For the \"\"ID-passcode-collision\" datset and the \"ID-passcode-spoofing\" dataset, the procedure of spoofing with semantic leakage is similar to the \"sign-in\" step in the \"ID-passcode\" dataset, i.e., only five repetitions for each string. The file name is in the format of \"collision_string_xx.csv\" or \"spoof_string_xx.csv\". For example, if the imposter is designated to be \"spoof8\", and the spoofed string is \"FMKit\", the file name is \"spoof8_FMKit_0.csv\" for the first repetition. To facilitate dataset loading and saving, an alternative naming scheme with a slight different difference is also used. It also follows the format \"collision_string_xx.csv\" or \"spoof_string_xx.csv\". All imposters are just designated simply as \"collision\" or \"spoof\". However, \"spoof_string_0.csv\" to \"spoof_string_4.csv\" are the five repetitions for the first imposter, \"spoof_string_5.csv\" to \"spoof_string_9.csv\" are the five repetitions for the second imposter, and so on. For the same privacy reasons, the \"string\" part in the file name are renamed to something like \"user0\" or \"passcode0\". For the long-term persistence study dataset, the procedure and file name convention are the same as sign-up and sign-in. However, the sequence number of repetitions will linearly increase. For example, if the ID string is \"alice\" and the passcode is \"FMKit\", for the five signals in registration, the file name will be \"alice_FMKit_0.csv\" to \"alice_FMKit_4.csv\". For the first login session, the file names will be \"alice_FMKit_5.csv\" to \"alice_FMKit_9.csv\". Similarly, for the second login session, the file names will be increased to \"alice_FMKit_10.csv\" to \"alice_FMKit_14.csv\", and so on. For the same privacy reasons, the files are renamed in the same pattern as that for the \"ID-passcode\" dataset. For the \"word-210\" dataset, the procedure and file name convention are the same as the collision dataset and the spoofing dataset. Instead of using \"spoofer\", \"user\" is used in the file name. For example, if the participant is designated as \"user8\", and it writes the English words \"agree\", for the first repetition, the file name would be \"user8_agree_01.csv\". The same alternative naming scheme is also used, i.e., \"user_agree_0.csv\" to \"user_agree_4.csv\" are the five repetitions for the first user, \"user_agree_5.csv\" to \"user_agree_9.csv\" are the five repetitions for the second user, and so on. For Chinese words, pinyin is used in the file name. These files do not have privacy issues, and hence, they are not anonymized. Supported Research Tasks A signal in any of the first five datasets can be represented as a tuple (s, y), where \"s\" is the signal data, and \"y\" is the label indicating the content of the string (i.e., the \"cid\"). For example, in the \"ID-passcode\" dataset, there are 180 different \"y\" labels for ID strings and another 180 different \"y\" labels for passcodes. Based on this definition, we propose the following three types of tasks. User authentication. User identification. Word recognition. User Authentication The user authentication task is essentially a binary classification problem, which serves as the function of \"typing a password\" over the gesture interface. In this task, each of the 360 passcode strings in the \"ID-passcode\" dataset is considered as the sign-in passcode of an account. Note that the ID strings are also used as the passcode for a separate account, which means each user has two accounts, one using the ID string as a passcode, and the other using the passcode string as a passcode. This is mainly due to the limited number of users in our datasets and using the ID strings for passcode purpose can essentially double the dataset. Using the \"ID-passcode\" dataset, the five signals for registration are used to construct templates and train discriminative models to construct the authentication system, and the five signals for login requests are used to test its performance. Specifically, consider an account has been constructed by the signals { s (1) , s (2) , ..., s (k) } all with the same label \"y\". Given another signal (s', y') from those testing signals in the \"ID-passcode\" dataset, the authentication system should accept the signal s' if y is the same as y', i.e., it is generated by the same person writing the same content; otherwise, the authentication system should reject it. Note that this binary classifier is specific to an account constructed by those signals with the label \"y\". For each account, there is a unique binary classifer. We call those testing signals with label y' == y the positive testing signals, and those testing signals with label y' != y the negative testing signals respectively. The signals in the \"ID-passcode-collision\" and \"ID-passcode-spoofing\" datasets are used to evaluate the authentication system performance in scenarios with adversaries, i.e., all of them are negative testing signals that should be rejected. The signals in the \"ID-passcode-persistence\" dataset are used to evaluate the authentication system performance in the long term, i.e., all of them are positive testing signals that should be accepted. Due to the imbalance of the number of positive testing signals (only five or a few more) and the number of negative testing signals (potentially thousands or more) for one account, we use the evaluation metrics commonly used in biometrics systems such as False Accept Rate (FAR) and False Reject Rate (FRR), instead of precision and recall. The are defined as follows. FAR = #{false accepts} / #{negative testing signals} FRR = #{false rejects} / #{positive testing signals} Here \"#{}\" means the number of elements in a set. Note that FAR and FRR can be applied for one specific account or a collection of accounts. In the later case, the number of testing signals for each account must be the same. Otherwise, the formular must be changed to use the average of the FAR and FRR for each account. Usually, the authentication system has a configurable discriminative threshold that can be changed to trade off FAR and FRR. For example, if the threshold is smaller, there will be more false rejects but less false accepts. When FAR is equal to FRR, this rate is called the Equal Error Rate (EER). The EER is very convenient when comparing different authentication algorithms using the same dataset, since it is just one single number. When the threshold is set to a value such that the FAR is 0.001 or 0.0001, the corresponding FRR is called FRR@FAR=1e-3 or FRR@FAR=1e-4. They are also denoted as FAR1K and FAR10K in the biometrics community, which may be confusing for readers who are not familier with biometrics. These two metrics are more important for practical usage than the EER. Based on our datasets, we set up three different experiments for each account: (a) All testing signals are from the \"ID-passcode\" dataset. (b) All positive testing signals are from the \"ID-passcode\" dataset but all negative testing signals are from the \"ID-passcode-collision\" dataset. (c) All positive testing signals are from the \"ID-passcode\" dataset but all negative testing signals are from the \"ID-passcode-spoofing\" dataset. Note that currently we do not use the \"ID-passcode-persistence\" dataset for quantitative evaluation. The number of signals in that dataset is quite limited, which can cause bias or uncertainty. Instead, we mainly use that dataset for qualitative evaluation. The performance results are averaged over all accounts and baselines are provided in the \" FMKit paper \". They are obtained using a per-account SVM classifier on aligned and temporally normalized signals. See the \" FMCode paper \" for further details (note that the datasets used in the FMCode paper is different but the algorithm is similar). User Identification The user identification is essentially a classification problem, which serves as the function of \"typing an account ID\". In this task, each of the 360 strings in the first dataset is considered as an account ID. Using the \"ID-passcode\" dataset, the five signals for registration are used to train the identification system (i.e., a classifier), and the five signals for login requests are used to test the performance of the identification system. Specifically, consider all accounts have been created and the identification system has been set up. Given another signal (s, y) from those testing signals in the \"ID-passcode\" dataset, the identification system predict the label of s as y', and y' should be the same as y, i.e., it should recognize the signal s is generated by the same person writing the same content. Different from user authentication, this classification is not specific to a specific account. There is only one system-wide classifier. Also different from a passcode, an ID string is usually not a secret. Besides predicting one single label, this task can be formulated as retrieving the top-k candidate accounts given a signal s. Together with the user authentication system, a login system can take both the in-air-handwriting of an ID and a passcode to first narrow down to one or a few candidate accounts using the ID and then check each candidate account using the passcode to authenticate the user. In this case, the ID does not needed to be returned to the user. Based on our datasets, we set up two different types of experiments. For closed-set identification, the system will always locate at least one account, i.e., it returns the best top-k prediction no matter how bad it is. For open-set identification, the system may end up with no candidate account and reject the in-air-handwriting ID string, i.e., it returns best top-k predictions that above a certain threshold set by the identification algorithm. Note that currently we only set up these experiments using the \"ID-passcode\" dataset. We plan to set up more experiments using the other datasets in the near future. However, in a realistic setting, the collision and spoofing data cannot be obtained, and hence, they are in general not available for training models. Instead, they should only be used for performance evaluation. The performance metrics are the top-1 and top-5 identification accuracy, i.e., the same as those metrics in traditional classification problems. The performance results are averaged over all accounts and baselines are provided in the \" FMKit paper \". They are obtained using neural network models. See the \" FMCode paper \" and the \" FMHash paper \" for further details (note that the datasets used in these paper are different but the algorithm is similar). In-Air-Handwriting Word Recognition In-air-handwriting word recognition is essentially another classification problem similar to user identification. However, the label of each signal is the content from a word lexicon of the \"word-210\" dataset instead of a set of user account IDs. Meanwhile, in this task, behaviors variations from different people writing the same word need to be tolerated. For example, one person may write the same letter \"O\" clockwise but another person may write it counterclockwise. Also, variation of stroke sequences need to considered. For example, when writing the same letter \"t\", one person may write the horizontal stroke as the last stroke but another person may write it as the first stroke. These problems are challenging especially on our dataset with a limited number of writers. Using the \"word-210\" dataset, the signals from nine users are used to tain the recognizer, and the signals of the remaining one user are used to test the performance of the recognizer. This is repeated for ten times by selecting the data from each user as testing data (i.e., 10-fold cross validation). All experiments are closed-set, i.e., the recognizer will always provide the best predictions. Experiments using the data of writing English and the data of writing Chinese are conducted independently. The performance metrics are the average top-1 and the average top-5 classification accuracy among the ten experiment repetitions. The performance results are averaged over all accounts and baselines are provided in the \" FMKit paper \". They are obtained using similar neural network models as those in the user identification task. Current results are on a dataset with a small lexicon and we believe it would be more challenging with a large lexicon. Reference [1] Gonzalo Bailador, Carmen Sanchez-Avila, Javier Guerra-Casanova, and Alberto de Santos Sierra, \"Analysis of patternrecognition techniques for in-air signature biometrics\", Pattern Recognition , 2011. [2] Gradeigh D Clark and Janne Lindqvist, \"Engineering gesture-based authentication systems\", IEEE Pervasive Computing , 2015. [3] Euan Freeman, Stephen Brewster, and Vuokko Lantz, \"Do that, there: an interaction technique for addressing in-air ges-ture systems\", CHI , 2016. [4] Ji Gan and Weiqiang Wang, \"In-air handwritten english wordrecognition using attention recurrent translator\", Neural Com-puting and Applications , 2017. [5] Eiji Hayashi, Manuel Maas, and Jason I Hong, \"Wave to me: user identification using body lengths and natural gestures\", SIGCHI Conference on Human Factors in Computing Systems , 2014. [6] Duo Lu, Dijiang Huang, Yuli Deng, and Adel Alshamrani, \"Multifactor user authentication with in-air-handwriting and hand geometry\", IAPR International Conference on Biometrics (ICB) , 2018. [7] Duo Lu, Dijiang Huang, and Anshul Rai, \"FMHash: Deep hashing of in-air-handwriting for user identification\", IEEE International Conference on Communications (ICC) , 2019. [8] Duo Lu, Kai Xu, and Dijiang Huang, \"A data driven in-air-handwriting biometric authentication system\", IEEE International Joint Conference on Biometrics (IJCB) , 2017. [9] Keenan R May, Thomas M Gable, and Bruce N Walker, \"Designing an in-vehicle air gesture set using elicitation methods\", International Conference on Automotive User Interfaces and Interactive Vehicular Applications , 2017. [10] Thammathip Piumsomboon, Adrian Clark, Mark Billinghurst, and Andy Cockburn, \"User-defined gestures for augmented reality\", IFIP Conference on Human-Computer Interaction , 2013. [11] Xiwen Qu, Weiqiang Wang, and Ke Lu, \"In-air handwritten Chinese character recognition using discriminative projection based on locality-sensitive sparse representation\", International Conference on Pattern Recognition (ICPR) , 2016. [12] Napa Sae-Bae, Jonathan Wu, Nasir Memon, Janusz Konrad, and Prakash Ishwar, \"Emerging NUI-based methods for user authentication: A new taxonomy and survey\", IEEE Transactions on Biometrics, Behavior, and Identity Science , 2019. [13] Jing Tian, Chengzhang Qu, Wenyuan Xu, and Song Wang. \"Kinwrite: Handwriting-based authentication using kinect\", NDSS ,2013. [14] Koji Tsukada and Michiaki Yasumura, \"Ubi-Finger: Gesture input device for mobile use\", UbiComp , 2001. [15] Ning Xu, Weiqiang Wang, and Xiwen Qu, \"Recognition of in-air handwritten Chinese character based on leap motion controller\", International Conference on Image and Graphics , 2015.","title":"The FMKit Architecture"},{"location":"arch/#the-fmkit-architecture","text":"Hand-gesture and in-air-handwriting provide ways for users to input information in Augmented Reality (AR) and Virtual Reality (VR) applications where a physical keyboard or a touch screen is unavailable. However, understanding the movement of hands and fingers is challenging, which requires a large amount of data and data-driven models. In this project, we propose an open research infrastructure named FMKit for in-air-handwriting analysis, which contains a set of Python libraries and a data repository collected from more than 180 users using two different types of motion capture sensors. We also present three research tasks enabled by FMKit, including in-air-handwriting based user authentication, user identification, and word recognition, with preliminary baseline performance.","title":"The FMKit Architecture"},{"location":"arch/#introduction","text":"In AR/VR applications, 3D in-air hand gestures are natural ways to interact with virtual objects as well as a method to input information [3, 9, 10, 14]. Besides simple gestures like tap, scroll, slide, etc, there are cases when complicated information such as text or identity is needed to be presented to the software as input. Consider the scenario shown in Figure 1, a dialog pops up to an AR/VR user asking a passcode, an ID, or a short piece of text information (e.g., a tweet) as input information. One possible method is using in-air-handwriting [4, 15], i.e., instead of typing, the user can write a piece of information in the air, and ask the computer to recognize it. However, there are a few challenges. First, recognizing patterns in hand motion generally requires a large amount of data to train machine learning models, but the data collection is generally expensive. Second, there is no standard hand motion capture device and data collection procedures, and existing works choose their own ways, which makes the datasets incompatible and hard to compare. Additionally, most of them are not openly available. Third, given different motion capture devices and multiple in-air-handwriting related tasks solved using various algorithms, these mix-and-matches make it difficult to fairly evaluate different systems and compare their performance results [2]. To the best of our knowledge, the only open datasets of in-air-handwriting are constructed for word recognition [11, 4] using the Leap Motion controller. Figure 1: In-air-handwriting as input to AR/VR applications. In this project, we construct FMKit (Finger Motion analysis Kit), an open-source library and open datasets for in-air-handwriting analysis. Currently, FMKit contains several datasets of in-air-handwriting motion for various purposes. There are 103K data signals in total. Especially, each dataset has two parts collected in identical scenarios with the same in-air-handwriting content using two different motion capture devices, so that the results of the two devices can be compared. We also release the details of the devices, signal characterization, data collection protocols, and the source code of the client software so that researchers can easily extend our datasets. Meanwhile, we propose three types of research tasks enabled by the FMKit infrastructure: user authentication [1, 12, 13, 6, 8], user identification [5, 7], and in-air-handwriting word recognition [4, 15], which corresponds to the three types of inputs in Figure 1. Additionally, we provide the baseline performance for these tasks with our dataset. We hope this open infrastructure helps researchers to validate models, benchmark the performance of algorithms, and further facilitate data-driven approaches that can be generalized across sensor types for in-air-handwriting analysis.","title":"Introduction"},{"location":"arch/#devices","text":"The FMKit data repository contains multiple datasets, all collected using two types of devices (shown in Figure 2): a wearable device (a custom-made data glove with inertial sensors) and a contactless 3D camera (the Leap Motion controller). The Leap Motion controller can capture the 3D position of each joint of the hand at about 110 Hz with an 135 degree Field of View (FOV) and a depth range of 60 cm. Usually only the tip of the index finger or the palm center is interested. However, we discover that the tracking results of fingers are not always reliable, especially when the hand moves quickly or when the index finger points to certain directions (occluded by the palm from the perspective of the camera. The data glove can track the 3D acceleration and angular speed of the tip of the index finger at 100 Hz, using a Micro-Electro-Mechanical System (MEMS) Inertial Measurement Unit (IMU). Specifically, we use the Bosch BNO055 IMU. The glove also has an identical IMU on the thumb but that sensor is generally not used. The data glove has a few variants with slight differences in form factors, microcontrollers, and IMU orientations. However, the essential motion sensors and the obtained signals are the same. Both devices are relatively inexpensive (roughly $100) and their capabilities are similar to existing VR/AR platforms with a gesture user interface with similar sensors for hand motion capture. Figure 2: The custom data glove device (left) and the Leap Motion controller (right).","title":"Devices"},{"location":"arch/#in-air-handwriting-signal","text":"The basic unit of data in our datasets is called a \" signal \", which is a recorded piece of hand movement of writing a string in the air. Examples of raw signals are shown in Figure 3. Figure 3: The left figure shows an example of the finger motion trajectory of writing \"apple\" together with the hand skeleton captured by the Leap Motion controller. The right figure shows an example of the signal containing the acceleration and the angular speed obtained from the data glove when writing the same word \"apple\" by the same person. These signals are the \"raw signals\" directly from the device. The Python module \" fmsignal.py \" is constructed to model the signal obtain from sensor devices. It also has those routines for preprocessing. Also, the Python module \" fmsignal_vis.py \" is built to facilitate the inspection and visualization of signals. Additionally, the Python module \" fmsignal_demo.py \" contains code for demonstrating the usage of the code library. Also see the \" User Manual - Signal \". There are essentially four types of signals: Raw signal from the Leap Motion device, represented by the \" FMSignalLeap \" class. Raw signal from the data glove device, represented by the \" FMSignalGlove \" class. Preprocessed signal from the Leap Motion device, represented by the \" FMSignal \" class. Preprocessed signal from the data glove device, also represented by the \" FMSignal \" class. Note that the \"FMSignal\" class is actually device agnostic. All preprocessed signals have the same format. These four types of signals share a lot in common, and we collectively call them \"signals\". A signal is created by a user writing some content. Sometimes the user writes the same content in multiple repetitions to generate a set of signals. Hence, a signal object in any of the four types has a \"user\" attribute to indicate the writer, a \"cid\" (i.e., content ID) attribute to indicate the content, and a \"seq\" attribute to indicate one of the repetitions in a set (if it is just a standalone signal, \"seq\" is simply zero). A signal is a time series containing samples of physical states of the fingers. The time series is denoted as a two dimensional array s = ( s 1 , s 2 , ..., s i , ..., s l ), and each sample (or row) of s is s i = ( s i1 , s i2 , ..., s ij , ..., s id ). Here \"l\" is the number of samples and \"d\" is the number of sensor axes, i.e., the first dimension is the time, and the second dimension is the sensor axes. Depending on the type of signals, the meaning of each element (or column) s ij is different. For a preprocessed signal, it has 18 sensor axes (i.e., \"d\" is 18), as follows. 0 - 2: position in x-y-z. 3 - 5: velocity in x-y-z. 6 - 8: linear acceleration in x-y-z (i.e., the gravity \"g\" is removed). 9 - 11: orientation (currently, it is the qx, qy, qz components of a unit quaternion). 12 - 14: angular speed in x-y-z. 15 - 17: angular acceleration in x-y-z. Note that the \"FMSignal\" class is actually device agnostic, and hence, preprocessed signals all have these 18 sensor axes regardless of the motion capture devices. It represents the motion state of a single point on the hand, either the tip of the index finger or the center of the hand (which can be chosen at the preprocessing procedure). This two dimensional array is represented by the \"data\" attribute of the \"FMSignal\" class. It is a NumPy ndarray object. The \"dtype\" is always \"np.float32\". For raw signals, the sensor axes are specific to the device, which is more complicated. However, the only thing needs to be done for the raw signal is the preprocessing so as to obtain a preprocessed signal. The preprocessing contains the following steps. Down-sampling the signal to 50 Hz with linear interpolation on each sensor axis. Normalizing the signal reference frame,i.e., set the average position as the origin, the average hand pointingdirection as the x-axis, and the horizontal left as the y-axis. For each signal sample, deriving the 18 axes mentioned above from the raw sensor data. Low-pass filtering with a threshold frequency of 10 Hz. Trimming the start and end of the signal when the hand does not move. (Optional) Normalizing the whole signal in each sensor axis to zero mean and unit variance. (Optional) Normalizing thesignal length to 256 samples with linear interpolation. The last two steps of preprocessing are usually only needed for specific tasks. The samples of a signal are generated at a constant rate and each sample s i is associated with a timestamp \"ts i \". All signals created by the same user writing the same content can construct a set S = { s (1) , s (2) , ..., s (k) }, where \"k\" is essentially the \"seq\" attribute of a signal. Given such a set S, a template t can be generated by aligning all signals in S to the first signal and average all the algigned signals. The template is represented by the \" FMSignalTemplate \" class. A template has the same attributes as an ordinary signal. The aligning process is typically done through Dynamic Time Warping (DTW), which is also widely used for signal comparison and authentication tasks.","title":"In-Air-Handwriting Signal"},{"location":"arch/#datasets","text":"Currently, the following datasets are available. (1) ID-passcode : We asked each user to create two distinct meaningful strings as an ID string and a passcode. The content of the string is determined by the user. Such a string may include alphanumeric letters, characters in a language other than English, or meaningful symbols such as five-pointed stars. Once the strings are created, we ask the user to write each string in-the-air for 5 repetitions as registration and another 5 repetitions as login attempts, using each device. This simulates the normal sign-up and sign-in procedure. In total, there are 360 (strings) * 10 (repetitions) * 2 (devices) = 7,200 signals. In this dataset, the content of the string is determined by the user. We strongly recommend the users avoid using the ID or password they use in their daily lives, but we did not forbid the users to write their name as ID strings because most of the in-air-handwriting are illegible like a signature and the content is hard to read. 58 users wrote words in Chinese for both strings. The remaining 122 users wrote alphanumerical strings. We asked each user to create a unique ID string so that all 180 ID strings have unique contents. However, there are no such constraints for the passcodes. Surprisingly, all 180 passcode strings also have unique contents. In fact, there is only one ID string that has the same content as another passcode. They are created by different users, who both choose the string \"helloworld\" but for different purposes. As a general guideline, we discourage simple strings for passcode such as \"123456\", and we recommend that the length of an alphanumerical string be at least eight characters. However, it is not a strict restriction, and a few users still created simple and short strings like \"USA\" or \"abc123\". Many users chose a combination of letters and numbers like a traditional password typed on a keyboard, e.g., \"stevenC909\", or meaningful phrases, \\textit{e.g.}, \"PondLakeOcean\", while some users chose a combination without an obvious meaning, e.g., \"sqwz1457\", and one user drew three five-pointed stars as a passcode. For privacy reasons, the contents of the ID and passcode are not disclosed. (2) ID-passcode-collision : We asked 10 skilled imposters to imitate the in-air-handwriting of the ID and passcode generated by the users in the \"ID-passcode\" dataset. In this setting, the imposters know the semantic meaning of the strings written by the legitimate users, but the imposters have not seen the legitimate users writing the ID and passcode in the air, which simulates the case of ID or passcode collision, or spoofing attack with semantic leakage. For each string in the \"ID-passcode\" dataset, we ask each imposter to write it with 5 repetitions using each device. In total, there are 360 (strings) * 10 (imposters) * 5 (repetitions) * 2 (devices) = 36,000 signals. (3) ID-passcode-spoofing : Similar to the \"ID-passcode-collision\" dataset, we asked 10 skilled imposters to imitate the in-air-handwriting of the ID and passcode generated by the users in the \"ID-passcode\" dataset. In this setting, the imposters can watch the recorded video of the in-air-handwriting and they will be informed with the semantic meaning of the in-air-handwriting. There are 180 string in the \"ID-passcode\" dataset where the user allows us to record a video of the hand movement (exactly 90 ID strings and 90 passcodes corresponding to 90 users). For each of the 180 strings, we ask each imposter to write it with 5 repetitions using each device. In total, there are 360 (strings) * 10 (imposters) * 5 (repetitions) * 2 (devices) = 18,000 signals. (4) ID-passcode-persistence : We kept collecting the sign-in in-air-handwriting of a subset of the users in the \"ID-passcode\" dataset for a period of about 4 weeks, which simulates login activity in the long term. In that dataset, the user wrote each string 5 repetitions as registration, while in this dataset, besides the registration, the users wrote the strings for the account ID and the account passcode 5 repetitions in a day as a session. There are 10 sessions in total and the data of each session is collected in a different day. 40 users participated in this dataset. In total there are 80 (strings) * 10 (imposters) * 5 (repetitions) * 2 (devices) = 8,000 data samples. (5) word-210 : We asked 10 users to write 210 English words and another 10 users to write 210 Chinese words, with 5 repetitions for each word using both devices. The user is asked to write in a legible way. In total, there are 2 (languages) * 210 (strings) * 10 (writers) * 5 (repetitions) * 2 (devices) = 42,000 data samples. (6) Usability Survey : We asked the participating users to fill a survey on the usability of gesture sign-in system with various sensors and different types of gestures. 100 users responded to the survey. Besides, we are currently working on an extension of the \"word-210\" dataset, named word-10k . As the name suggests, this dataset contains 10,000 English words and 10,000 Chinese words, where each English word is written by at least 10 different users with one repetition and each Chinese word is written by at least 10 different users with one repetition. In total, there will be at least 400,000 signals. It is currently work-in-progress and this dataset construction is supposed to be finished by the end of year 2021. Currently, the \"word-210\" dataset is openly available here . If you would like to use other datasets related to in-air-handwriting of ID and passcode, please send an email application to us (see the \"Authors\" section in the home page ).","title":"Datasets"},{"location":"arch/#data-collection-protocols","text":"The detailed procedure for the Leap Motion controller device is shown in Figure 4. The data collection is done on several identical Linux desktop and Linux laptop machines. On each machine, three Linux console terminals are opened, one for the Leap Motion daemon process (i.e., typing \"sudo leapd\" in the commandline), one for the Leap Motion control panel as well as the visualizer (typing \"LeapControlPanel --showsettings\" and then launch the \"diagnose visualizer\"), and the last for the actual data collection program (typing \"python ./client_leap.py xxx.txt\" in the commandline or launch the client program with a GUI). At the beginning of the writing of one string, the participant typically hover the hand above the sensor, like that in the following figure. Once the data collection starts, i.e., immediately after the \"client_leap.py\" script executes or the \"start/stop\" button on the GUI client is clicked, the hand starts to move. At the end of the writing of one string, the hand restores to the initial position or stop at the last stroke. The data collection program can be stopped by the user, i.e., press the \"space\" key or clicking the \"start/stop\" button (typically for the \"word-210\" dataset), or it can automatically stop if the user's hand stops moving for roughly 1 second (typically for the datasets related to ID string and passcode). The participant can write from left to right or just write every letter at the same place. Figure 4: Data collection procedure for the Leap Motion controller device. The procedure for the data glove is similar. Only one Linux console terminal is needed for the actual data collection program. Different from the Leap Motion controller where the user must write within the field of view of the sensor, the data glove does not have such constraints. The user can just start moving after the data collection program starts to collect data. When the user finishes writing, the data collection program can be stopped in the same way as that for the Leap Motion controller. Each captured handwriting signal is an individually named file. In the \"ID-passcode\" dataset, for the ID string, it is typically \"id_id_xx.csv\", where \"xx\" the sequence number of the repetition. For example, if the ID string is \"alice\", the file is named as \"alice_alice_0.csv\" for the first repetition. For the passcode, similarly, it is \"id_passcode_xx.csv\". For example, if the ID string is \"alice\" and the passcode is \"FMKit\", the file name is \"alice_FMKit_0.csv\". If the user chooses to write in Chinese, pinyin is used in the file name to indicate the content. To protect the privacy, We removed any tags and metadata that is sensitive to user identity. Files storing the data are renamed to something like \"user0_user0_0.csv\" for an ID string and \"user0_passcode0_0.csv\" for a passcode. In this way, we can immediately know which user generates which signal for what content from the file name while debugging the code and tuning trained models. For the \"\"ID-passcode-collision\" datset and the \"ID-passcode-spoofing\" dataset, the procedure of spoofing with semantic leakage is similar to the \"sign-in\" step in the \"ID-passcode\" dataset, i.e., only five repetitions for each string. The file name is in the format of \"collision_string_xx.csv\" or \"spoof_string_xx.csv\". For example, if the imposter is designated to be \"spoof8\", and the spoofed string is \"FMKit\", the file name is \"spoof8_FMKit_0.csv\" for the first repetition. To facilitate dataset loading and saving, an alternative naming scheme with a slight different difference is also used. It also follows the format \"collision_string_xx.csv\" or \"spoof_string_xx.csv\". All imposters are just designated simply as \"collision\" or \"spoof\". However, \"spoof_string_0.csv\" to \"spoof_string_4.csv\" are the five repetitions for the first imposter, \"spoof_string_5.csv\" to \"spoof_string_9.csv\" are the five repetitions for the second imposter, and so on. For the same privacy reasons, the \"string\" part in the file name are renamed to something like \"user0\" or \"passcode0\". For the long-term persistence study dataset, the procedure and file name convention are the same as sign-up and sign-in. However, the sequence number of repetitions will linearly increase. For example, if the ID string is \"alice\" and the passcode is \"FMKit\", for the five signals in registration, the file name will be \"alice_FMKit_0.csv\" to \"alice_FMKit_4.csv\". For the first login session, the file names will be \"alice_FMKit_5.csv\" to \"alice_FMKit_9.csv\". Similarly, for the second login session, the file names will be increased to \"alice_FMKit_10.csv\" to \"alice_FMKit_14.csv\", and so on. For the same privacy reasons, the files are renamed in the same pattern as that for the \"ID-passcode\" dataset. For the \"word-210\" dataset, the procedure and file name convention are the same as the collision dataset and the spoofing dataset. Instead of using \"spoofer\", \"user\" is used in the file name. For example, if the participant is designated as \"user8\", and it writes the English words \"agree\", for the first repetition, the file name would be \"user8_agree_01.csv\". The same alternative naming scheme is also used, i.e., \"user_agree_0.csv\" to \"user_agree_4.csv\" are the five repetitions for the first user, \"user_agree_5.csv\" to \"user_agree_9.csv\" are the five repetitions for the second user, and so on. For Chinese words, pinyin is used in the file name. These files do not have privacy issues, and hence, they are not anonymized.","title":"Data Collection Protocols"},{"location":"arch/#supported-research-tasks","text":"A signal in any of the first five datasets can be represented as a tuple (s, y), where \"s\" is the signal data, and \"y\" is the label indicating the content of the string (i.e., the \"cid\"). For example, in the \"ID-passcode\" dataset, there are 180 different \"y\" labels for ID strings and another 180 different \"y\" labels for passcodes. Based on this definition, we propose the following three types of tasks. User authentication. User identification. Word recognition.","title":"Supported Research Tasks"},{"location":"arch/#user-authentication","text":"The user authentication task is essentially a binary classification problem, which serves as the function of \"typing a password\" over the gesture interface. In this task, each of the 360 passcode strings in the \"ID-passcode\" dataset is considered as the sign-in passcode of an account. Note that the ID strings are also used as the passcode for a separate account, which means each user has two accounts, one using the ID string as a passcode, and the other using the passcode string as a passcode. This is mainly due to the limited number of users in our datasets and using the ID strings for passcode purpose can essentially double the dataset. Using the \"ID-passcode\" dataset, the five signals for registration are used to construct templates and train discriminative models to construct the authentication system, and the five signals for login requests are used to test its performance. Specifically, consider an account has been constructed by the signals { s (1) , s (2) , ..., s (k) } all with the same label \"y\". Given another signal (s', y') from those testing signals in the \"ID-passcode\" dataset, the authentication system should accept the signal s' if y is the same as y', i.e., it is generated by the same person writing the same content; otherwise, the authentication system should reject it. Note that this binary classifier is specific to an account constructed by those signals with the label \"y\". For each account, there is a unique binary classifer. We call those testing signals with label y' == y the positive testing signals, and those testing signals with label y' != y the negative testing signals respectively. The signals in the \"ID-passcode-collision\" and \"ID-passcode-spoofing\" datasets are used to evaluate the authentication system performance in scenarios with adversaries, i.e., all of them are negative testing signals that should be rejected. The signals in the \"ID-passcode-persistence\" dataset are used to evaluate the authentication system performance in the long term, i.e., all of them are positive testing signals that should be accepted. Due to the imbalance of the number of positive testing signals (only five or a few more) and the number of negative testing signals (potentially thousands or more) for one account, we use the evaluation metrics commonly used in biometrics systems such as False Accept Rate (FAR) and False Reject Rate (FRR), instead of precision and recall. The are defined as follows. FAR = #{false accepts} / #{negative testing signals} FRR = #{false rejects} / #{positive testing signals} Here \"#{}\" means the number of elements in a set. Note that FAR and FRR can be applied for one specific account or a collection of accounts. In the later case, the number of testing signals for each account must be the same. Otherwise, the formular must be changed to use the average of the FAR and FRR for each account. Usually, the authentication system has a configurable discriminative threshold that can be changed to trade off FAR and FRR. For example, if the threshold is smaller, there will be more false rejects but less false accepts. When FAR is equal to FRR, this rate is called the Equal Error Rate (EER). The EER is very convenient when comparing different authentication algorithms using the same dataset, since it is just one single number. When the threshold is set to a value such that the FAR is 0.001 or 0.0001, the corresponding FRR is called FRR@FAR=1e-3 or FRR@FAR=1e-4. They are also denoted as FAR1K and FAR10K in the biometrics community, which may be confusing for readers who are not familier with biometrics. These two metrics are more important for practical usage than the EER. Based on our datasets, we set up three different experiments for each account: (a) All testing signals are from the \"ID-passcode\" dataset. (b) All positive testing signals are from the \"ID-passcode\" dataset but all negative testing signals are from the \"ID-passcode-collision\" dataset. (c) All positive testing signals are from the \"ID-passcode\" dataset but all negative testing signals are from the \"ID-passcode-spoofing\" dataset. Note that currently we do not use the \"ID-passcode-persistence\" dataset for quantitative evaluation. The number of signals in that dataset is quite limited, which can cause bias or uncertainty. Instead, we mainly use that dataset for qualitative evaluation. The performance results are averaged over all accounts and baselines are provided in the \" FMKit paper \". They are obtained using a per-account SVM classifier on aligned and temporally normalized signals. See the \" FMCode paper \" for further details (note that the datasets used in the FMCode paper is different but the algorithm is similar).","title":"User Authentication"},{"location":"arch/#user-identification","text":"The user identification is essentially a classification problem, which serves as the function of \"typing an account ID\". In this task, each of the 360 strings in the first dataset is considered as an account ID. Using the \"ID-passcode\" dataset, the five signals for registration are used to train the identification system (i.e., a classifier), and the five signals for login requests are used to test the performance of the identification system. Specifically, consider all accounts have been created and the identification system has been set up. Given another signal (s, y) from those testing signals in the \"ID-passcode\" dataset, the identification system predict the label of s as y', and y' should be the same as y, i.e., it should recognize the signal s is generated by the same person writing the same content. Different from user authentication, this classification is not specific to a specific account. There is only one system-wide classifier. Also different from a passcode, an ID string is usually not a secret. Besides predicting one single label, this task can be formulated as retrieving the top-k candidate accounts given a signal s. Together with the user authentication system, a login system can take both the in-air-handwriting of an ID and a passcode to first narrow down to one or a few candidate accounts using the ID and then check each candidate account using the passcode to authenticate the user. In this case, the ID does not needed to be returned to the user. Based on our datasets, we set up two different types of experiments. For closed-set identification, the system will always locate at least one account, i.e., it returns the best top-k prediction no matter how bad it is. For open-set identification, the system may end up with no candidate account and reject the in-air-handwriting ID string, i.e., it returns best top-k predictions that above a certain threshold set by the identification algorithm. Note that currently we only set up these experiments using the \"ID-passcode\" dataset. We plan to set up more experiments using the other datasets in the near future. However, in a realistic setting, the collision and spoofing data cannot be obtained, and hence, they are in general not available for training models. Instead, they should only be used for performance evaluation. The performance metrics are the top-1 and top-5 identification accuracy, i.e., the same as those metrics in traditional classification problems. The performance results are averaged over all accounts and baselines are provided in the \" FMKit paper \". They are obtained using neural network models. See the \" FMCode paper \" and the \" FMHash paper \" for further details (note that the datasets used in these paper are different but the algorithm is similar).","title":"User Identification"},{"location":"arch/#in-air-handwriting-word-recognition","text":"In-air-handwriting word recognition is essentially another classification problem similar to user identification. However, the label of each signal is the content from a word lexicon of the \"word-210\" dataset instead of a set of user account IDs. Meanwhile, in this task, behaviors variations from different people writing the same word need to be tolerated. For example, one person may write the same letter \"O\" clockwise but another person may write it counterclockwise. Also, variation of stroke sequences need to considered. For example, when writing the same letter \"t\", one person may write the horizontal stroke as the last stroke but another person may write it as the first stroke. These problems are challenging especially on our dataset with a limited number of writers. Using the \"word-210\" dataset, the signals from nine users are used to tain the recognizer, and the signals of the remaining one user are used to test the performance of the recognizer. This is repeated for ten times by selecting the data from each user as testing data (i.e., 10-fold cross validation). All experiments are closed-set, i.e., the recognizer will always provide the best predictions. Experiments using the data of writing English and the data of writing Chinese are conducted independently. The performance metrics are the average top-1 and the average top-5 classification accuracy among the ten experiment repetitions. The performance results are averaged over all accounts and baselines are provided in the \" FMKit paper \". They are obtained using similar neural network models as those in the user identification task. Current results are on a dataset with a small lexicon and we believe it would be more challenging with a large lexicon.","title":"In-Air-Handwriting Word Recognition"},{"location":"arch/#reference","text":"[1] Gonzalo Bailador, Carmen Sanchez-Avila, Javier Guerra-Casanova, and Alberto de Santos Sierra, \"Analysis of patternrecognition techniques for in-air signature biometrics\", Pattern Recognition , 2011. [2] Gradeigh D Clark and Janne Lindqvist, \"Engineering gesture-based authentication systems\", IEEE Pervasive Computing , 2015. [3] Euan Freeman, Stephen Brewster, and Vuokko Lantz, \"Do that, there: an interaction technique for addressing in-air ges-ture systems\", CHI , 2016. [4] Ji Gan and Weiqiang Wang, \"In-air handwritten english wordrecognition using attention recurrent translator\", Neural Com-puting and Applications , 2017. [5] Eiji Hayashi, Manuel Maas, and Jason I Hong, \"Wave to me: user identification using body lengths and natural gestures\", SIGCHI Conference on Human Factors in Computing Systems , 2014. [6] Duo Lu, Dijiang Huang, Yuli Deng, and Adel Alshamrani, \"Multifactor user authentication with in-air-handwriting and hand geometry\", IAPR International Conference on Biometrics (ICB) , 2018. [7] Duo Lu, Dijiang Huang, and Anshul Rai, \"FMHash: Deep hashing of in-air-handwriting for user identification\", IEEE International Conference on Communications (ICC) , 2019. [8] Duo Lu, Kai Xu, and Dijiang Huang, \"A data driven in-air-handwriting biometric authentication system\", IEEE International Joint Conference on Biometrics (IJCB) , 2017. [9] Keenan R May, Thomas M Gable, and Bruce N Walker, \"Designing an in-vehicle air gesture set using elicitation methods\", International Conference on Automotive User Interfaces and Interactive Vehicular Applications , 2017. [10] Thammathip Piumsomboon, Adrian Clark, Mark Billinghurst, and Andy Cockburn, \"User-defined gestures for augmented reality\", IFIP Conference on Human-Computer Interaction , 2013. [11] Xiwen Qu, Weiqiang Wang, and Ke Lu, \"In-air handwritten Chinese character recognition using discriminative projection based on locality-sensitive sparse representation\", International Conference on Pattern Recognition (ICPR) , 2016. [12] Napa Sae-Bae, Jonathan Wu, Nasir Memon, Janusz Konrad, and Prakash Ishwar, \"Emerging NUI-based methods for user authentication: A new taxonomy and survey\", IEEE Transactions on Biometrics, Behavior, and Identity Science , 2019. [13] Jing Tian, Chengzhang Qu, Wenyuan Xu, and Song Wang. \"Kinwrite: Handwriting-based authentication using kinect\", NDSS ,2013. [14] Koji Tsukada and Michiaki Yasumura, \"Ubi-Finger: Gesture input device for mobile use\", UbiComp , 2001. [15] Ning Xu, Weiqiang Wang, and Xiwen Qu, \"Recognition of in-air handwritten Chinese character based on leap motion controller\", International Conference on Image and Graphics , 2015.","title":"Reference"},{"location":"fmsignal-reference/","text":"fmsignal module This module is the core of the fmkit framework, which is designed to facilitate researches on in-air-handwriting related research. Author: Duo Lu < duolu.cs@gmail.com > Version: 0.1 License: MIT Updated on Feb. 7, 2020, version 0.1 Created on Aug 14, 2017, draft The MIT License Copyright 2017-2021 Duo Lu < duolu.cs@gmail.com > Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. FMSignal 3D finger motion signal (after preprocessing, device agnostic). This is the data structure for a finger motion signal. The signal is a time series containing samples of physical states of one point on a hand, captured by a 3D camera device or a wearable data glove device. This is the class the abstracts the signal data structure after preprocessing, and it is device agnostic. Attributes: Name Type Description length int length of the time series (i.e., number of samples). dim int dimension of each sample (i.e., number of sensor axes). ts ndarray timestamps of each sample, in a len dimensional vector. data ndarray the actual time series data, in a len * dim matrix. user str the user who creates this signal. cid str the unique id indicating the content of the signal. seq int the sequence id in a set when loaded from a dataset. NOTE : There are several ways to create an FMSignal object. (1) Preprocess a raw signal, i.e., \"raw_signal.preprocess()\". (2) Load data from a file with the class method \"construct_from_file()\". (3) Deep copy from an existing FMSignal object, i.e., \"signal.copy()\". (4) Align to a template or another signal to generate an aligned signal, i.e., \"signal.align_to(another_signal)\" (5) Modify an existing FMSignal object to generate a new signal, which is basically only used for data agumentation. It is not recommended to directly construct an FMSignal object using its constructor since the attributes may be inconsistent. Instead, please only use those previously mentioned methods to create an FMSignal object. NOTE : Timestamp is always in ms and frequency is always in Hz. NOTE : \"ts\" and \"data\" both have \"dtype == np.float32\". Currently, a signal has the following 18 sensor axes, i.e., \"dim\" is 18, and the \"data\" field has the shape of (len, 18). axes description 0-2 position in x-y-z 3-5 speed in x-y-z, currently just the derivative of the position 6-8 acceleration in x-y-z, currently just the derivative of speed 9-11 orientation, i.e., the x, y, z components of the quaternion 12-14 angular speed, currently just the derivative of the orientation 15-17 angular acceleration, just the derivative of the angular speed A signal may also have the following optional attributes. attributes description len_origin The length before alignment (only for aligned signals). dist DTW alignment distant (only for aligned signals). a2to1_start Alignment index start array (only for aligned signals). a2to1_end Alignment index end array (only for aligned signals). NOTE : \"user\", \"cid\", and \"seq\" are only needed to print information for debugging. Use the class \"FMSignalDesc\" to obtain the meta data of the signal for more details. Typically, the signal file is named as \"user_cid_seq.txt\" (or \".csv\", or \".npy\"). For example, given a file \"duolu_duolu_01.txt\", the \"user\" label is \"duolu\", the \"cid\" label is also \"duolu\", indicating the content is about writing the string \"duolu\", and the \"seq\" is 1, indicating the repetition #1. Usually, for privacy issues, \"user\" label and \"cid\" label are anonymous strings since they only need to be distinctive instead of meaningful. For example, \"user00_id00_01.txt\" means the \"user\" label is \"user00\", the \"id\" label is \"id00\", and the seq is 1. NOTE : The raw signal file may have two different formats, i.e., either in Comma Separated Value (\".csv\") or in NumPy binary format (\".npy\"). However, the content structure is the same, which is essentially a matrix, where the rows are the samples at a certain time and the columns are the data from a specific sensor axis. See the \"Data Format Details\" document for more information. __init__ ( self , length = 0 , dim = 0 , ts = None , data = None , user = '' , cid = '' , seq = 0 ) special Constructor. See the class attributes for the meaning of the arguments. NOTE : This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal, or use the \"align_to()\" method to obtain an aligned signal. Source code in code_fmkit/fmsignal.py def __init__ ( self , length = 0 , dim = 0 , ts = None , data = None , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the class attributes for the meaning of the arguments. **NOTE**: This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal, or use the \"align_to()\" method to obtain an aligned signal. \"\"\" self . length = length self . dim = dim self . ts = ts self . data = data self . user = user self . cid = cid self . seq = seq __str__ ( self ) special Convert the meta info of the signal to a human readable string. Currently, the string is \"user_cid_seq\". Parameters: Name Type Description Default None None No arguments. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def __str__ ( self ): \"\"\"Convert the meta info of the signal to a human readable string. Currently, the string is \"user_cid_seq\". Args: None (None): No arguments. Returns: None: No return value. \"\"\" return \" %s _ %s _ %d \" % ( self . user , self . cid , self . seq ) align_to ( self , template , window = 0 , penalty = 0 , method = 'c' , keep_dist_matrix = False ) Get another signal by aligning the signal to a template signal. NOTE : The alignment is done using Dynamic Time Warping (DTW). Parameters: Name Type Description Default template FMSignal The template signal. required window int The DTW alignment window. 0 penalty int The DTW element-wise missalign penalty. 0 method string Implementation method, either \"c\" or \"python\". 'c' keep_dist_matrix bool Indicating whether to keep the DTW result, i.e., the \"dist_matrix\". False Returns: Type Description FMSignal The constructed signal object. Source code in code_fmkit/fmsignal.py def align_to ( self , template , window = 0 , penalty = 0 , method = DTW_METHOD , keep_dist_matrix = False ): \"\"\"Get another signal by aligning the signal to a template signal. **NOTE**: The alignment is done using Dynamic Time Warping (DTW). Args: template (FMSignal): The template signal. window (int): The DTW alignment window. penalty (int): The DTW element-wise missalign penalty. method (string): Implementation method, either \"c\" or \"python\". keep_dist_matrix (bool): Indicating whether to keep the DTW result, i.e., the \"dist_matrix\". Returns: FMSignal: The constructed signal object. \"\"\" length_new = template . length ts_new = template . ts . copy () #print(template.data.shape) #print(self.data.shape) if method == \"python\" : tup = dtw ( template . data , self . data , window , penalty ) elif method == \"c\" : tup = dtw_c ( template . data , self . data , window , penalty ) else : raise ValueError ( \"Unkown DTW implementation method ( %s )!\" % method ) ( _dist , matrix , _d , a2to1_start , a2to1_end , _s , _e , data_new ) = tup signal = FMSignal ( length_new , self . dim , ts_new , data_new , self . user , self . cid , self . seq ) signal . len_origin = self . length signal . a2to1_start = a2to1_start signal . a2to1_end = a2to1_end if keep_dist_matrix : signal . dist_matrix = matrix return signal all_close_to ( self , signal ) Check whether this signal is almost identical to another signal. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Parameters: Name Type Description Default signal FMSignal The other signal to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , signal ): \"\"\"Check whether this signal is almost identical to another signal. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Args: signal (FMSignal): The other signal to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( signal , FMSignal ): return False if self . length != signal . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , signal . ts , atol = 1e-6 ) r2 = np . allclose ( self . data , signal . data , atol = 1e-6 ) return r1 and r2 amplitude_normalize ( self ) Normalize the amplitude of each sensor axes. NOTE : The ratios of x-y-z axes of one type, e.g., position, acc, etc., are not perserved. Parameters: Name Type Description Default None None No argument. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def amplitude_normalize ( self ): \"\"\"Normalize the amplitude of each sensor axes. **NOTE**: The ratios of x-y-z axes of one type, e.g., position, acc, etc., are not perserved. Args: None (None): No argument. Returns: None: No return value. \"\"\" data = self . data mean = np . mean ( data , axis = 0 ) std = np . std ( data , axis = 0 ) for j in range ( self . dim ): data [:, j ] = np . divide ( data [:, j ] - mean [ j ], std [ j ]) construct_from_file ( fn , mode , user = '' , cid = '' , seq = 0 ) classmethod Construct a signal by loading data from a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format (currently either \"csv\" or \"npy\"). required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignal The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is unknown. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Construct a signal by loading data from a file. Args: fn (string): The file name (without extension). mode (string): The file format (currently either \"csv\" or \"npy\"). user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignal: The constructed signal object. Raises: ValueError: If the \"mode\" is unknown. FileNotFoundError: If the file does not exist. \"\"\" signal = FMSignal ( 0 , 0 , None , None ) signal . load_from_file ( fn , mode ) signal . user = user signal . cid = cid signal . seq = seq return signal copy ( self ) Deep copy of the signal. Parameters: Name Type Description Default None None No arguments. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def copy ( self ): \"\"\"Deep copy of the signal. Args: None (None): No arguments. Returns: None: No return value. \"\"\" signal = FMSignal ( self . length , self . dim , self . data . copy (), self . ts . copy (), self . user , self . cid , self . seq ) return signal distance_to ( self , other ) Calculate the element-wise absolute distance of two signals. NOTE : The other signal must be already aligned to this signal, or their lengths must be the same. Parameters: Name Type Description Default other FMSignal The other signal. required Returns: Type Description ndarray An array of the absolute difference of the two signals. Exceptions: Type Description ValueError If their lengths are different. Source code in code_fmkit/fmsignal.py def distance_to ( self , other ): \"\"\"Calculate the element-wise absolute distance of two signals. **NOTE**: The other signal must be already aligned to this signal, or their lengths must be the same. Args: other (FMSignal): The other signal. Returns: ndarray: An array of the absolute difference of the two signals. Raises: ValueError: If their lengths are different. \"\"\" if self . length != other . length : raise ValueError ( \"Incompatible signal lengths %d and %d .\" % ( self . length , other . length )) return np . absolute ( self . data - other . data ) filter ( self , sample_freq , cut_freq ) Low-pass filtering on the signal (in place). NOTE : It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. NOTE : This method use NumPy FFT and IFFT. It modifies the signal. Parameters: Name Type Description Default sample_freq float sample frequency of this signal. required cut_freq float low pass filtering cutoff frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def filter ( self , sample_freq , cut_freq ): \"\"\"Low-pass filtering on the signal (in place). **NOTE**: It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. **NOTE**: This method use NumPy FFT and IFFT. It modifies the signal. Args: sample_freq (float): sample frequency of this signal. cut_freq (float): low pass filtering cutoff frequency. Returns: None: No return value. \"\"\" l = self . length data = self . data cut_l = int ( cut_freq * l / sample_freq ) dft_co = np . fft . fft ( data , l , axis = 0 ) for i in range ( cut_l , l - cut_l ): dft_co [ i ] = 0 + 0 j ifft_c = np . fft . ifft ( dft_co , l , axis = 0 ) ifft = ifft_c . astype ( np . float32 ) for i in range ( l ): self . data [ i ] = ifft [ i ] get_orientation ( self ) Obtain orientation as a series of rotation matrices and quaternions. Parameters: Name Type Description Default None None No argument. required Returns: Type Description tuple A tuple of the following representing the orientation. ndarray: The rotation matrices (l-by-3-by-3). list: The unit quaternions. Source code in code_fmkit/fmsignal.py def get_orientation ( self ): \"\"\"Obtain orientation as a series of rotation matrices and quaternions. Args: None (None): No argument. Returns: tuple: A tuple of the following representing the orientation. ndarray: The rotation matrices (l-by-3-by-3). list: The unit quaternions. \"\"\" l = self . length data = self . data rotms = np . zeros (( l , 3 , 3 )) qs = [ None ] * l for i in range ( l ): qx = data [ i , 9 ] qy = data [ i , 10 ] qz = data [ i , 11 ] qw = math . sqrt ( 1 - qx * qx - qy * qy - qz * qz ) q = Quaternion ( qw , qx , qy , qz ) qs [ i ] = q rotms [ i ] = q . to_rotation_matrix () return rotms , qs load_alignment_index ( self , fn , mode ) Load the alignment indicies from a NumPy binary file (.npy). NOTE : The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None no return value. Exceptions: Type Description ValueError If the \"mode\" is unknown. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py def load_alignment_index ( self , fn , mode ): \"\"\"Load the alignment indicies from a NumPy binary file (.npy). **NOTE**: The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: no return value. Raises: ValueError: If the \"mode\" is unknown. FileNotFoundError: If the file does not exist. \"\"\" if mode == \"csv\" : fn += \".csv\" array = np . loadtxt ( fn , dtype = np . int32 , delimiter = \",\" ) elif mode == \"npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . int32 else : raise ValueError ( \"Unknown mode: \" + mode ) self . a2to1_start = array [:, 0 ] self . a2to1_end = array [:, 1 ] self . length_origin = self . a2to1_end [ - 1 ] load_from_file ( self , fn , mode ) Load the signal from a file. NOTE : This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"Load the signal from a file. **NOTE**: This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"csv\" : fn += \".csv\" array = np . loadtxt ( fn , dtype = np . float32 , delimiter = \",\" ) elif mode == \"npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 else : raise ValueError ( \"Unknown mode: \" + mode ) # NOTE: These \"copy()\" force the \"ts\" and \"data\" to have proper C-like # array in memory, which is crucial for \"dtw_c()\"!!! ts = array [:, 0 : 1 ] . copy () data = array [:, 1 :] . copy () length = data . shape [ 0 ] dim = data . shape [ 1 ] self . length = length self . dim = dim self . ts = ts self . data = data pertube_amplitude ( self , axis , time , s_window , scale , sigma ) Pertube the signal at the specified time. NOTE : This method is used in data augmentation. It adds a Gaussian shape pertubation signal segment to the original signal. This method changes the signal. Parameters: Name Type Description Default axis int The specified axis to pertube. required time int The specified time to pertube. required s_window int The pertubation smooth window size (greater than 0). required scale float The scale factor of the pertubation (pos or neg). required sigma float The standard deviation of the Gaussian pertubation. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def pertube_amplitude ( self , axis , time , s_window , scale , sigma ): \"\"\"Pertube the signal at the specified time. **NOTE**: This method is used in data augmentation. It adds a Gaussian shape pertubation signal segment to the original signal. This method changes the signal. Args: axis (int): The specified axis to pertube. time (int): The specified time to pertube. s_window (int): The pertubation smooth window size (greater than 0). scale (float): The scale factor of the pertubation (pos or neg). sigma (float): The standard deviation of the Gaussian pertubation. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" l = self . length if axis < 0 or axis >= self . dim : raise ValueError ( 'Bad input axis ( %d )' % axis ) if s_window <= 0 or time < 0 or time >= l : raise ValueError ( 'Bad input time ( %d )' % time ) pertubation = scipy . signal . gaussian ( s_window * 2 , sigma ) * scale # Calculate the start indices. s_data = time - s_window s_pertube = 0 if s_data < 0 : s_pertube = - s_data s_data = 0 # Calculate the end indices. e_data = s_data + s_window * 2 e_pertube = s_window if e_data > l : e_pertube -= e_data - l e_data = l self . data [ s_data : e_data , axis ] += pertubation [ s_pertube : e_pertube ] pertube_amplitude_seg ( self , axis , time , window , s_window , scale , sigma ) Pertube the signal at a specified time for a segment. NOTE : This method is used in data augmentation. It adds a flat pertubation signal segment to the original signal with Gaussian smooth edges on both sides. This method changes the signal. Parameters: Name Type Description Default axis int The specified axis to pertube. required time int The specified time to pertube. required window int The pertubation window size (greater than 0). required s_window int The pertubation smooth window size (greater than 0). required scale float The scale factor of the pertubation (pos or neg). required sigma float The standard deviation of the Gaussian pertubation. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def pertube_amplitude_seg ( self , axis , time , window , s_window , scale , sigma ): \"\"\"Pertube the signal at a specified time for a segment. **NOTE**: This method is used in data augmentation. It adds a flat pertubation signal segment to the original signal with Gaussian smooth edges on both sides. This method changes the signal. Args: axis (int): The specified axis to pertube. time (int): The specified time to pertube. window (int): The pertubation window size (greater than 0). s_window (int): The pertubation smooth window size (greater than 0). scale (float): The scale factor of the pertubation (pos or neg). sigma (float): The standard deviation of the Gaussian pertubation. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" l = self . length if axis < 0 or axis >= self . dim : raise ValueError ( 'Bad input axis: ' + ' %d ' % axis ) if window <= 0 or s_window <= 0 : raise ValueError ( 'Bad input window ( %d ) or s_window ( %d )' % ( window , s_window )) if time < 0 or time + window >= l : raise ValueError ( 'Bad input time ( %d ) or window ( %d )' % ( time , window )) pertube_size = window + s_window * 2 pertube_seg = np . ones ( pertube_size , dtype = np . float32 ) * scale # NOTE: The peak of this Gaussian series is 1. smooth_edges = scipy . signal . gaussian ( s_window * 2 , sigma ) se_left = smooth_edges [: s_window ] se_right = smooth_edges [ s_window :] pertube_seg [: s_window ] = np . multiply ( pertube_seg [: s_window ], se_left ) pertube_seg [ - s_window :] = np . multiply ( pertube_seg [: s_window ], se_right ) s_data = time - s_window s_pertube = 0 if s_data < 0 : s_pertube = - s_data s_data = 0 e_data = time + window + s_window e_pertube = pertube_size if e_data >= l : e_pertube -= e_data - l e_data = l self . data [ s_data : e_data , axis ] += pertube_seg [ s_pertube : e_pertube ] resize ( self , length_new ) Resize the signal to the specified new length. NOTE : This method stretches the signal in time by linear interpolation. It is designed for temporal normalization. This method modifies the signal. Parameters: Name Type Description Default length_new int The specified new length. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def resize ( self , length_new ): \"\"\"Resize the signal to the specified new length. **NOTE**: This method stretches the signal in time by linear interpolation. It is designed for temporal normalization. This method modifies the signal. Args: length_new (int): The specified new length. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" if length_new < 0 : raise ValueError ( 'Bad new length ( %d ).' % length_new ) l = self . length d = self . dim data_new = np . zeros (( length_new , d ), np . float32 ) ts_new = np . zeros (( length_new ), np . float32 ) data = self . data ts = self . ts xp = np . linspace ( 0 , l - 1 , num = l ) x = np . linspace ( 0 , l - 1 , num = length_new ) for j in range ( d ): data_new [:, j ] = np . interp ( x , xp , data [:, j ]) ts_new [:] = np . interp ( x , xp , ts ) self . length = length_new self . ts = ts_new self . data = data_new resize_segment ( self , start , window , seg_length_new ) Resize a segment of the signal and keep other parts untouched. NOTE : This method is used in data augmentation. This method changes the signal. Parameters: Name Type Description Default start int The start of the segment to stretch. required window int The stretch window size (greater than 0). required seg_length_new int The specified new segment length. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def resize_segment ( self , start , window , seg_length_new ): \"\"\"Resize a segment of the signal and keep other parts untouched. **NOTE**: This method is used in data augmentation. This method changes the signal. Args: start (int): The start of the segment to stretch. window (int): The stretch window size (greater than 0). seg_length_new (int): The specified new segment length. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" end = start + window if window <= 0 : raise ValueError ( 'Bad window size ( %d ).' % window ) if seg_length_new < 0 : raise ValueError ( 'Bad new segment length ( %d ).' % seg_length_new ) if start < 0 or end >= self . length : raise ValueError ( 'Bad input start ( %d ) or window ( %d ).' % ( start , window )) sample_period = self . ts [ 1 ] - self . ts [ 0 ] l = self . length d = self . dim seg_l = end - start l_new = self . length - seg_l + seg_length_new delta_new = seg_l / seg_length_new seg_start_new = start seg_end_new = seg_start_new + seg_length_new data_new = np . zeros (( l_new , d ), np . float32 ) ts_new = np . zeros (( l_new , 1 ), np . float32 ) data = self . data # TODO: rewrite this with array splice and linear interpolation data_new [ 0 : start ] = data [ 0 : start ] data_new [ seg_end_new : l_new ] = data [ end : l ] for i in range ( seg_length_new ): it = start + i * delta_new ii_old = int ( math . floor ( it )) ii_new = start + i dt = it - ii_old # print(i, delta_new, it, ii) for v in range ( d ): rate = ( data [ ii_old ][ v ] - data [ ii_old ][ v ] if ii_old + 1 < l else data [ ii_old ][ v ] - data [ ii_old - 1 ][ v ] ) data_new [ ii_new ][ v ] = data [ ii_old ][ v ] + rate * dt for i in range ( l_new ): ts_new [ i ] = sample_period * i self . length = l_new self . dim = d self . ts = ts_new self . data = data_new save_alignment_index ( self , fn , mode ) Save the alignment indicies to a NumPy binary file (.npy). NOTE : The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Parameters: Name Type Description Default fn string file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_alignment_index ( self , fn , mode ): \"\"\"Save the alignment indicies to a NumPy binary file (.npy). **NOTE**: The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Args: fn (string): file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: No return value. \"\"\" l = self . length column_1 = self . a2to1_start . reshape (( l , 1 )) column_2 = self . a2to1_end . reshape (( l , 1 )) array = np . concatenate (( column_1 , column_2 ), axis = 1 ) if mode == \"csv\" : fn += \".csv\" np . savetxt ( fn , array , fmt = \" %d \" , delimiter = \", \" ) elif mode == \"npy\" : # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown mode: \" + mode ) save_to_file ( self , fn , mode ) Save the signal to a file. NOTE : Only six digits after the decimal point are kept when floating point numbers are converted to CSV strings. Parameters: Name Type Description Default fn string file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"Save the signal to a file. **NOTE**: Only six digits after the decimal point are kept when floating point numbers are converted to CSV strings. Args: fn (string): file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: No return value. \"\"\" l = self . length array = np . concatenate (( self . ts . reshape (( l , 1 )), self . data ), axis = 1 ) if mode == \"csv\" : fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"npy\" : assert array . dtype == np . float32 # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown mode: \" + mode ) shift_temporally ( self , shift ) Shift the signal in time. NOTE : This method is used in data augmentation. This method modifies the signal. Parameters: Name Type Description Default shift int The specified shift in time. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def shift_temporally ( self , shift ): \"\"\"Shift the signal in time. **NOTE**: This method is used in data augmentation. This method modifies the signal. Args: shift (int): The specified shift in time. Returns: None: No return value. \"\"\" data = self . data l = self . length d = self . dim xp = np . arange ( 0 , l , 1 , dtype = np . float32 ) x = xp + shift data_shift = np . zeros (( l , d ), dtype = np . float32 ) # TODO: Rewrite this using array splice. for j in range ( d ): data_shift [:, j ] = np . interp ( x , xp , data [:, j ]) self . data = data_shift stretch_axis ( self , axis , scale ) Stretch along a certain sensor axis. NOTE : This method is used in data augmentation. This method modifies the signal. Parameters: Name Type Description Default axis int The specified sensor axis to stretch. required scale float The intensity of the stretching. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def stretch_axis ( self , axis , scale ): \"\"\"Stretch along a certain sensor axis. **NOTE**: This method is used in data augmentation. This method modifies the signal. Args: axis (int): The specified sensor axis to stretch. scale (float): The intensity of the stretching. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" if axis < 0 or axis >= self . dim : raise ValueError ( 'Bad axis ( %d ).' % axis ) l = self . length offset_v = ( np . arange ( 0 , l , 1 ) - l / 2 ) * scale self . data [:, axis ] += offset_v swap_segment ( self , other , start , window , s_window ) Swap a segment of this signal with another signal. NOTE : This method is used in data augmentation. It generates two new signals, which are the signals after swapping. It is done on all axes. This method does not modify this signal or the other signal. Parameters: Name Type Description Default other FMSignal The other signal. required start int The start of the segment to swap. required window int The pertubation window size (greater than 0). required s_window int The pertubation smooth window size (greater than 0). required Returns: Type Description tuple A tuple containing the following. FMSignal: This signal after swapping. FMSignal: The other signal after swapping. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def swap_segment ( self , other , start , window , s_window ): \"\"\"Swap a segment of this signal with another signal. **NOTE**: This method is used in data augmentation. It generates two new signals, which are the signals after swapping. It is done on all axes. This method does not modify this signal or the other signal. Args: other (FMSignal): The other signal. start (int): The start of the segment to swap. window (int): The pertubation window size (greater than 0). s_window (int): The pertubation smooth window size (greater than 0). Returns: tuple: A tuple containing the following. FMSignal: This signal after swapping. FMSignal: The other signal after swapping. Raises: ValueError: If the input arguments are out of range. \"\"\" end = start + window l_min = min ( self . length , other . length ) if window <= 0 or s_window <= 0 : raise ValueError ( 'Bad input window ( %d ) or s_window ( %d )' % ( window , s_window )) if start < 0 or end >= l_min : raise ValueError ( 'Bad input start ( %d ) or window ( %d )' % ( start , window )) a = self . copy () b = other . copy () data_a = a . data ts_a = a . ts data_b = b . data ts_b = b . ts as1 = data_a [: start , :] as2 = data_a [ start : end , :] as3 = data_a [ end :, :] bs1 = data_b [: start , :] bs2 = data_b [ start : end , :] bs3 = data_b [ end :, :] ats1 = ts_a [: start ] ats2 = ts_a [ start : end ] ats3 = ts_a [ end :] bts1 = ts_b [: start ] bts2 = ts_b [ start : end ] bts3 = ts_b [ end :] data_a_new = np . concatenate ([ as1 , bs2 , as3 ], axis = 0 ) ts_a_new = np . concatenate ([ ats1 , bts2 , ats3 ], axis = 0 ) l_a = data_a_new . shape [ 0 ] data_b_new = np . concatenate ([ bs1 , as2 , bs3 ], axis = 0 ) ts_b_new = np . concatenate ([ bts1 , ats2 , bts3 ], axis = 0 ) l_b = data_b_new . shape [ 0 ] # Smooth the segment edges with linear interpolation. # TODO: Rewrite this using NumPy vectorized operation. if s_window != 0 : # Left margin ml_start = max ( 0 , start - s_window ) ml_end = min ( start + s_window , min ( l_a , l_b )) ml_length = ml_end - ml_start ml_factor = np . linspace ( 1 , 0 , ml_length , endpoint = True , dtype = np . float32 ) # print(margin1_start, margin1_end) for i , ii in zip ( range ( ml_start , ml_end ), range ( ml_length )): data_a_new [ i ] = ml_factor [ ii ] * data_a [ i ] \\ + ( 1 - ml_factor [ ii ]) * data_b [ i ] data_b_new [ i ] = ml_factor [ ii ] * data_b [ i ] \\ + ( 1 - ml_factor [ ii ]) * data_a [ i ] # Right margin mr_start = max ( 0 , end - s_window ) mr_end = min ( end + s_window , min ( l_a , l_b )) mr_length = mr_end - mr_start mr_factor = np . linspace ( 1 , 0 , mr_end - mr_start , endpoint = True , dtype = np . float32 ) # print(margin2_start, margin2_end) for i , ii in zip ( range ( mr_start , mr_end ), range ( mr_length )): data_a_new [ i ] = mr_factor [ ii ] * data_b [ i ] \\ + ( 1 - mr_factor [ ii ]) * data_a [ i ] data_b_new [ i ] = mr_factor [ ii ] * data_a [ i ] \\ + ( 1 - mr_factor [ ii ]) * data_b [ i ] a . data = data_a_new a . ts = ts_a_new a . len = l_a b . data = data_b_new b . ts = ts_b_new b . len = l_b return a , b FMSignalDesc A descriptor of a set of signals of the same writing content. Typically, these signals are generated by users or imposters writing the same content in multiple repetitions. If the contents are different, they are considered as different set of signals with different descriptors. NOTE : One descriptor object corresponds to one line in the meta file. Attributes: Name Type Description uid int A unique ID that orders all descriptors in a collections. Usually it is the line number of the descriptor in the meta file. user string A label indicating which user generates the signals. cid string A label indicating the content for classification tasks. Note that for spoofing attacks, i.e., different users are asked to write the same content, the signals have the same id_label. This label is used as the account ID for user identification and authentication purpose, and hence it gets the name \"id_label\". device string This indicates which type of device is used to obtain the signals. Currently it is either \"glove\" or \"leap\". start int The start repetition sequence number (inclusive). end int The end repetition sequence number (exclusive). These sequence numbers allow the database to only load a specified section of the data, which is very useful when spliting the dataset into training and testing set or dealing with data augmentation. fn_prefix string File name prefix, typically \"user_cid\". The full file name is \"fn_prefix\" + \"_\" + \"seq\" + \".csv\" or \".npy\", where \"seq\" indicate the specific repetition. content string The actual content that is written. __init__ ( self , uid , user , cid , device , start , end , fn_prefix , content ) special Constructor. See the class attributes for the meaning of the arguments. Source code in code_fmkit/fmsignal.py def __init__ ( self , uid , user , cid , device , start , end , fn_prefix , content ): \"\"\"Constructor. See the class attributes for the meaning of the arguments. \"\"\" self . uid = uid self . user = user self . cid = cid self . device = device self . start = start self . end = end self . fn_prefix = fn_prefix self . content = content __str__ ( self ) special Convert a descriptor to a human readable string representation. NOTE : Currently it is \"uid \\t user \\t cid \\t device\". Source code in code_fmkit/fmsignal.py def __str__ ( self ): \"\"\"Convert a descriptor to a human readable string representation. **NOTE**: Currently it is \"uid \\\\t user \\\\t cid \\\\t device\". \"\"\" return \" %8d \\t %20s \\t %20s \\t %8s \\t \" % ( self . uid , self . user , self . cid , self . device , ) construct_from_meta_file ( meta_fn ) classmethod Factory method to build list of FMSignalDesc from a metadata file. Parameters: Name Type Description Default meta_fn string The metadata file name. required Returns: Type Description list a list of descriptor objects. NOTE : The meta file contains a table with the following structure, (columns are seperated by commas): column type content 0 int uid 1 string user 2 string cid 3 string device 4 int start repetition sequence number 5 int end repetition sequence number 6 string file name prefix 7 string content Typically, the file name prefix field is just \"user_label_id_label\". See the \"data_example\" and \"meta_example\" folders for examples. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_meta_file ( cls , meta_fn ): \"\"\"Factory method to build list of FMSignalDesc from a metadata file. Args: meta_fn (string): The metadata file name. Returns: list: a list of descriptor objects. **NOTE**: The meta file contains a table with the following structure, (columns are seperated by commas): column | type | content -------|---------|-------------- 0 | int | uid 1 | string | user 2 | string | cid 3 | string | device 4 | int | start repetition sequence number 5 | int | end repetition sequence number 6 | string | file name prefix 7 | string | content Typically, the file name prefix field is just \"user_label_id_label\". See the \"data_example\" and \"meta_example\" folders for examples. \"\"\" descs = [] with open ( meta_fn , \"r\" ) as meta_fd : reader = csv . reader ( meta_fd ) for row in reader : if len ( row ) == 0 : continue if row [ 0 ] . startswith ( \"#\" ): continue strs = [] for column in row : strs . append ( column . lstrip () . rstrip ()) desc = cls ( int ( strs [ 0 ]), strs [ 1 ], strs [ 2 ], strs [ 3 ], int ( strs [ 4 ]), int ( strs [ 5 ]), strs [ 6 ], strs [ 7 ], ) descs . append ( desc ) return descs FMSignalGlove Raw finger motion signal collected by the data glove. This class represents the raw signal obtained from the data glove. The glove uses two BNO055 Inertial Measurement Units (IMU), one on the tip of the index finger and the other on the tip of the thumb. Attributes: Name Type Description length int The number of samples in this signal. ts ndarray Timestamp obtained from the device (1D vector). tsc ndarray Timestamp obtained from the client computer (1D vector). acc0 ndarray The linear acceleration obtained from the first IMU. gyro0 ndarray The angular speed obtained from the first IMU. gravity0 ndarray The gravity vector obtained from the first IMU. acc1 ndarray The linear acceleration obtained from the second IMU. gyro1 ndarray The angular speed obtained from the second IMU. gravity1 ndarray The gravity vector obtained from the second IMU. data ndarray The data after preprocessing. rotms ndarray The orientation of each smple in rotation matrices. qs list The orientation of each smple in unit quaternions. trajectory ndarray The motion trajectory of the selected IMU. NOTE : The raw sensor data such as \"acc0\" is a length * 3 matrix. NOTE : \"data\", \"rotms\", \"qs\", and \"trajectory\" are only available after preprocessing. Since a preprocessed signal (i.e., FMSignal object) contains the motion of only one point, in the preprocessing procedure, one IMU must be selected (i.e., by the \"point\" argument of \"preprocess()\"). The \"rotms\" is a length * 3 * 3 tensor. The \"qs\" is a list of Quaternion objects from the \"pyrotation\" module. The \"trajectory\" is a length * 3 matrix. NOTE : Although the BNO055 IMU can provide absolute orientation fused by the accelerometer, gyroscope. Additionally, it can provide linear acceleration with gravity removed. In our case, The IMU is set to NDOF mode (default mode, see BNO055 datasheet section 3.3). We use the linear acceleration but not the absolute orientation. Instead, we use a simple method to derive the orientation by integrating the angular speed. Since the signal usually has only a few seconds, this simple method is good enough. The raw file contains additional columns. See the \"Data Format Details\" document for more information. NOTE : The raw signal file may have two different formats, i.e., either in Comma Separated Value (\".csv\") or in NumPy binary format (\".npy\"). However, the content structure is the same, which is essentially a matrix, where the rows are the samples at a certain time and the columns are the data from a specific sensor axis. See the \"Data Format Details\" document for more information. There is another format called \"raw_internal\", which is used to resolve format issues in the data collected at the early stage of this project. It is now obsolete. __init__ ( self , user = '' , cid = '' , seq = 0 ) special Constructor. See the attributes of FMSignal for the meaning of the arguments. NOTE : This is only for internal usage. If an FMSignalGlove object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. Source code in code_fmkit/fmsignal.py def __init__ ( self , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the attributes of FMSignal for the meaning of the arguments. **NOTE**: This is only for internal usage. If an FMSignalGlove object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. \"\"\" self . user = user self . cid = cid self . seq = seq self . length = 0 self . ts = None self . tsc = None self . acc0 = None self . gyro0 = None self . gravity0 = None self . acc1 = None self . gyro1 = None self . gravity1 = None self . data = None self . qs = None self . rotms = None self . trajectory = None all_close_to ( self , signal ) Check whether this signal is almost identical to the other signal. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Parameters: Name Type Description Default signal FMSignalGlove The other signal to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , signal ): \"\"\"Check whether this signal is almost identical to the other signal. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Args: signal (FMSignalGlove): The other signal to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( signal , FMSignalGlove ): return False if self . length != signal . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , signal . ts , atol = 1e-6 ) r2 = np . allclose ( self . tsc , signal . tsc , atol = 1e-6 ) r3 = np . allclose ( self . acc0 , signal . acc0 , atol = 1e-6 ) r4 = np . allclose ( self . gyro0 , signal . gyro0 , atol = 1e-6 ) r5 = np . allclose ( self . gravity0 , signal . gravity0 , atol = 1e-6 ) r6 = np . allclose ( self . acc1 , signal . acc1 , atol = 1e-6 ) r7 = np . allclose ( self . gyro1 , signal . gyro1 , atol = 1e-6 ) r8 = np . allclose ( self . gravity1 , signal . gravity1 , atol = 1e-6 ) return r1 and r2 and r3 and r4 and r5 and r6 and r7 and r8 construct_from_file ( fn , mode , user = '' , cid = '' , seq = 0 ) classmethod Construct a signal by loading data from a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignalGlove The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is wrong. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Construct a signal by loading data from a file. Args: fn (string): The file name (without extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignalGlove: The constructed signal object. Raises: ValueError: If the \"mode\" is wrong. FileNotFoundError: If the file does not exist. \"\"\" signal = cls ( user , cid , seq ) signal . load_from_file ( fn , mode ) return signal convert_axes_to_standard_glove ( self , axes ) Convert a set of xyz data series to the standard glove axes. Parameters: Name Type Description Default axes ndarray The original data series. required Returns: Type Description None No return value. NOTE : This method is designed to handle \"raw_internal\" signals only. Source code in code_fmkit/fmsignal.py def convert_axes_to_standard_glove ( self , axes ): \"\"\"Convert a set of xyz data series to the standard glove axes. Args: axes (ndarray): The original data series. Returns: None: No return value. **NOTE**: This method is designed to handle \"raw_internal\" signals only. \"\"\" n = axes . shape [ 0 ] temp = np . zeros (( n , 1 ), np . float32 ) # x <= -y', y <= x' # (x, y) is standard glove. (x', y') is glove2 or glove3. temp [:, 0 ] = axes [:, 0 ] axes [:, 0 ] = - axes [:, 1 ] axes [:, 1 ] = temp [:, 0 ] convert_to_standard_glove ( self ) Convert raw data columns to standard glove reference frame. Parameters: Name Type Description Default none None No arguments. required Returns: Type Description None No return value. NOTE : This method is designed to handle \"raw_internal\" signals only. Source code in code_fmkit/fmsignal.py def convert_to_standard_glove ( self ): \"\"\"Convert raw data columns to standard glove reference frame. Args: none (None): No arguments. Returns: None: No return value. **NOTE**: This method is designed to handle \"raw_internal\" signals only. \"\"\" self . convert_axes_to_standard_glove ( self . acc0 ) self . convert_axes_to_standard_glove ( self . gyro0 ) self . convert_axes_to_standard_glove ( self . gravity0 ) self . convert_axes_to_standard_glove ( self . acc1 ) self . convert_axes_to_standard_glove ( self . gyro1 ) self . convert_axes_to_standard_glove ( self . gravity1 ) estimate_angular_states ( self , point ) Estimate orientation, angular speed, and angular acceleration. NOTE : Orientations are represented as the qx, qy, and qz components of a unit quaternion. For the data glove device, the angular speed is directly obtained from the sensor, and the angular po NOTE : Currently the beginning of the signal is used as the initial pose and the integration goes through the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def estimate_angular_states ( self , point ): \"\"\"Estimate orientation, angular speed, and angular acceleration. **NOTE**: Orientations are represented as the qx, qy, and qz components of a unit quaternion. For the data glove device, the angular speed is directly obtained from the sensor, and the angular po **NOTE**: Currently the beginning of the signal is used as the initial pose and the integration goes through the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". Returns: None: No return value. \"\"\" data = self . data l = self . length if point == \"tip\" : gyro = self . gyro0 elif point == \"center\" : gyro = self . gyro1 else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) q = Quaternion . identity () # rotation matrix of each data sample rotms = np . zeros (( l , 3 , 3 )) # quaternion of each data sample qs = [ None ] * l # Given 50 Hz, one timestep is 20 ms, i.e., 0.02 second timestep = 0.02 for i in range ( 0 , l ): qs [ i ] = q rotm = q . to_rotation_matrix () rotms [ i ] = rotm data [ i , 9 ] = q . x data [ i , 10 ] = q . y data [ i , 11 ] = q . z # z, y, x = rotation_matrix_to_euler_angles_zyx(rotm) # yaw, pitch, roll, gimbal_lock \\ # = rotation_matrix_to_euler_angles_zyx(rotm) # data[i, 9] = roll # data[i, 10] = pitch # data[i, 11] = yaw # assert not gimbal_lock # NOTE: Gyro output is in rad/s omega = gyro [ i ] q = Quaternion . integrate_local ( q , omega , timestep ) q . normalize () data [:, 12 : 15 ] = gyro data [:, 15 ] = np . gradient ( data [:, 12 ]) data [:, 16 ] = np . gradient ( data [:, 13 ]) data [:, 17 ] = np . gradient ( data [:, 14 ]) self . data = data self . rotms = rotms self . qs = qs estimate_linear_states ( self , point , wv = 0.2 , wp = 5 ) Estimate position, velocity and acceleration. NOTE : For the data glove device, the linear acceleration is directly obtained from the sensor. The position and velocity are derived by integrating the linear acceleration. NOTE : This method depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" Source code in code_fmkit/fmsignal.py def estimate_linear_states ( self , point , wv = 0.2 , wp = 5 ): \"\"\"Estimate position, velocity and acceleration. **NOTE**: For the data glove device, the linear acceleration is directly obtained from the sensor. The position and velocity are derived by integrating the linear acceleration. **NOTE**: This method depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" \"\"\" data = self . data l = self . length if point == \"tip\" : acc = self . acc0 elif point == \"center\" : acc = self . acc1 else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) trajectory = np . zeros (( l , 3 )) qs = self . qs # given 50 Hz, one timestep is 20 ms, i.e., 0.02 second timestep = 0.02 # dead reckoning using linear acceleration p = np . array (( 0 , 0 , 0 )) v_m = np . array (( 0 , 0 , 0 )) a_m = np . array (( 0 , 0 , 0 )) pp = np . array (( 200 , 0 , 0 )) for i in range ( 1 , l ): acc_local = acc [ i ] q = qs [ i ] a_m = q . rotate_a_point ( acc_local ) . reshape ( 3 ) pp_i = q . rotate_a_point ( pp ) . reshape ( 3 ) trajectory [ i , 0 : 3 ] = pp_i v_m = v_m + a_m * timestep # Now we add a correction term u = np . multiply ( v_m , np . abs ( v_m )) v_m = v_m - wv * u p = p + v_m * timestep + 0.5 * a_m * timestep * timestep #print(p) # Now we add a similar correction term. w = np . multiply ( p , np . abs ( p )) p = p - wp * w data [ i , 6 : 9 ] = a_m data [ i , 3 : 6 ] = v_m data [ i , 0 : 3 ] = p * 1000 # position is in mm trajectory [:, 0 ] -= 200 self . trajectory = trajectory filter ( self , sample_freq , cut_freq ) Low-pass filtering on the signal. NOTE : It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default sample_freq float sample frequency of this signal. required cut_freq float low pass filtering cutoff frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def filter ( self , sample_freq , cut_freq ): \"\"\"Low-pass filtering on the signal. **NOTE**: It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: sample_freq (float): sample frequency of this signal. cut_freq (float): low pass filtering cutoff frequency. Returns: None: No return value. \"\"\" l = self . length data = self . data cut_l = int ( cut_freq * l / sample_freq ) dft_co = np . fft . fft ( data , l , axis = 0 ) for i in range ( cut_l , l - cut_l ): dft_co [ i ] = 0 + 0 j ifft_c = np . fft . ifft ( dft_co , l , axis = 0 ) # NOTE: This must be converted to \"np.float32\"! ifft = ifft_c . real . astype ( np . float32 ) for i in range ( l ): self . data [ i ] = ifft [ i ] load_from_buffer_raw ( self , array ) Load data from a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default array ndarray The buffer. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw ( self , array ): \"\"\"Load data from a NumPy ndarray. **NOTE**: This is only for internal usage. Args: array (ndarray): The buffer. Returns: None: No return value. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] assert m == 20 , \"Wrong raw file format: m = %d \" % m self . length = l self . tsc = array [:, 0 ] . flatten () self . ts = array [:, 1 ] . flatten () self . acc0 = array [:, 2 : 5 ] self . gyro0 = array [:, 5 : 8 ] self . gravity0 = array [:, 8 : 11 ] self . acc1 = array [:, 11 : 14 ] self . gyro1 = array [:, 14 : 17 ] self . gravity1 = array [:, 17 : 20 ] load_from_buffer_raw_internal ( self , array ) Load from a file directly obtained by the data collection client. Parameters: Name Type Description Default array ndarray The buffer, which is a numpy ndarrary. required Returns: Type Description None No return value. CAUTION: Do not use this method directly. Instead, uses the class method FMSignalGlove.construct_from_file() instead. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw_internal ( self , array ): \"\"\"Load from a file directly obtained by the data collection client. Args: array (ndarray): The buffer, which is a numpy ndarrary. Returns: None: No return value. CAUTION: Do not use this method directly. Instead, uses the class method FMSignalGlove.construct_from_file() instead. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] self . length = l if m == 25 : # NOTE: This is the early format, with only one timestamp. ts = array [:, 0 ] . flatten () tsc = np . zeros ( l , dtype = np . float32 ) acc0 = array [:, 1 : 4 ] gyro0 = array [:, 4 : 7 ] gravity0 = array [:, 7 : 10 ] acc1 = array [:, 13 : 16 ] gyro1 = array [:, 16 : 19 ] gravity1 = array [:, 19 : 22 ] elif m == 34 : # NOTE: This is the current format, with two timestamps. ts = array [:, 1 ] . flatten () tsc = array [:, 0 ] . flatten () # Use an offset to reduce the size of tsc so that it can fit into # the float32 type. tsc -= 1514764800 acc0 = array [:, 2 : 5 ] gyro0 = array [:, 5 : 8 ] gravity0 = array [:, 11 : 14 ] acc1 = array [:, 18 : 21 ] gyro1 = array [:, 21 : 24 ] gravity1 = array [:, 27 : 30 ] else : raise ValueError ( \"Unknown format: m = %d \" % m ) # Fix any timestamp anormaly # NOTE: The device timestamps in glove data are in millisecond. for i in range ( l - 1 ): if ts [ i + 1 ] < ts [ i ]: ts [ i + 1 ] = ts [ i ] + 20 self . ts = ts . astype ( np . float32 ) self . tsc = tsc . astype ( np . float32 ) self . acc0 = acc0 . astype ( np . float32 ) self . gyro0 = gyro0 . astype ( np . float32 ) self . gravity0 = gravity0 . astype ( np . float32 ) self . acc1 = acc1 . astype ( np . float32 ) self . gyro1 = gyro1 . astype ( np . float32 ) self . gravity1 = gravity1 . astype ( np . float32 ) load_from_file ( self , fn , mode ) General interface to load the raw signal from a file. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"General interface to load the raw signal from a file. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"raw_internal\" : fn += \".txt\" # NOTE: The \"dtype\" needs to be np.float64 for the raw timestamps! array = np . loadtxt ( fn , np . float64 , delimiter = \",\" ) self . load_from_buffer_raw_internal ( array ) elif mode == \"raw_csv\" : fn += \".csv\" array = np . loadtxt ( fn , np . float32 , delimiter = \",\" ) self . load_from_buffer_raw ( array ) elif mode == \"raw_npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 self . load_from_buffer_raw ( array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode ) pose_normalize ( self , start , end , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ) Normalize the position and orientation of the signal. NOTE : This method expect a start index and an end index, where the signal segment between the start and the end is used to calculate the average pointing direction. Hence, it should be called after \"prepare_trim_by_xxx()\". NOTE : This normalization step depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" Parameters: Name Type Description Default start int The start time index of the signal for normalization. required end int The end time index of the signal for normalization. required p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description None No return value. Exceptions: Type Description ValueError If the \"point\" is wrong or the \"start\" or \"end\" is bad. Source code in code_fmkit/fmsignal.py def pose_normalize ( self , start , end , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Normalize the position and orientation of the signal. **NOTE**: This method expect a start index and an end index, where the signal segment between the start and the end is used to calculate the average pointing direction. Hence, it should be called after \"prepare_trim_by_xxx()\". **NOTE**: This normalization step depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" Args: start (int): The start time index of the signal for normalization. end (int): The end time index of the signal for normalization. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: None: No return value. Raises: ValueError: If the \"point\" is wrong or the \"start\" or \"end\" is bad. \"\"\" data = self . data rotms = self . rotms qs = self . qs vi = np . array (( 1.0 , 0 , 0 ), np . float32 ) . reshape (( 3 , 1 )) # vj = np.array((0, 1.0, 0), np.float32).reshape((3, 1)) vk = np . array (( 0 , 0 , 1.0 ), np . float32 ) . reshape (( 3 , 1 )) # find the approximated average pointing direction as vx # find the approximated average downward direction as vz vxs = np . matmul ( rotms [ start : end ], vi ) vzs = np . matmul ( rotms [ start : end ], vk ) vx = np . mean ( vxs , axis = 0 ) . flatten () vz = np . mean ( vzs , axis = 0 ) . flatten () vx = vx / np . linalg . norm ( vx ) vz = vz / np . linalg . norm ( vz ) vy = np . cross ( vz , vx ) vy = vy / np . linalg . norm ( vy ) vz = np . cross ( vx , vy ) vz = vz / np . linalg . norm ( vz ) vx = vx . reshape (( 3 , 1 )) vy = vy . reshape (( 3 , 1 )) vz = vz . reshape (( 3 , 1 )) R_g2l = np . concatenate (( vx , vy , vz ), axis = 1 ) normalize_rotation_matrix ( R_g2l ) R_l2g = R_g2l . transpose () R_offset = euler_zyx_to_rotation_matrix ( p_yaw , p_pitch , p_roll ) R_l2g = np . matmul ( R_offset , R_l2g ) for i in range ( self . length ): rotm = np . matmul ( R_l2g , rotms [ i ]) rotm = normalize_rotation_matrix ( rotm ) q = Quaternion . construct_from_rotation_matrix ( rotm ) rotms [ i ] = rotm qs [ i ] = q # Now we derive the three Tait-Bryan angles # CAUTION: yaw first, then pitch, then roll # i.e., z-y-x intrinsic rotation (east, north, sky) # yaw, pitch, roll, gimbal_lock \\ # = rotation_matrix_to_euler_angles_zyx(rotm) # # data[i, 9] = roll # data[i, 10] = pitch # data[i, 11] = yaw # Tait-Bryan angles have singularity. # Use quaternion components instead. data [ i , 9 ] = q . x data [ i , 10 ] = q . y data [ i , 11 ] = q . z # verify using the gravity vector # self.data[i, 3:6] = np.matmul(rotms[i], gravity0[i].reshape((3, 1))).reshape(3) # apply pose offset on angular speed ov = data [:, 12 : 15 ] . T ov = np . matmul ( R_offset , ov ) data [:, 12 : 15 ] = ov . T data [:, 15 ] = np . gradient ( data [:, 12 ]) data [:, 16 ] = np . gradient ( data [:, 13 ]) data [:, 17 ] = np . gradient ( data [:, 14 ]) prepare_trim_by_acc ( self , point , threshold ) Determine the indicies for the start and end of the finger motion. NOTE : The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. NOTE : This method is only used in the preprocessing procedure. This method DOES NOT modify the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to detect the hand motion. required Returns: Type Description None No return value. NOTE : The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. Source code in code_fmkit/fmsignal.py def prepare_trim_by_acc ( self , point , threshold ): \"\"\"Determine the indicies for the start and end of the finger motion. **NOTE**: The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. **NOTE**: This method is only used in the preprocessing procedure. This method **DOES NOT** modify the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to detect the hand motion. Returns: None: No return value. **NOTE**: The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. \"\"\" if point == \"tip\" : data = self . acc0 elif point == \"center\" : data = self . acc1 else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) l = self . length acc = data . copy () a = np . linalg . norm ( acc , axis = 1 ) a_std = np . std ( a ) # NOTE: We cannot subtract the mean of acceleration here. an = np . divide ( a , a_std ) start = 0 for i in range ( l ): if abs ( an [ i ]) > threshold : start = i - 5 break start = max ( start , 0 ) end = 0 for i in range ( l - 1 , 0 , - 1 ): if abs ( an [ i ]) > threshold : end = i + 5 break end = min ( end , l ) return ( start , end ) preprocess ( self , point , threshold = 0.2 , cut_freq = 10 , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ) Preprocess the signal. NOTE : This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to trim the signal without hand motion. 0.2 cut_freq float Low pass filtering cutoff frequency. 10 p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description FMSignal The preprocessed signal. NOTE : The default argument values are typically good enough. Source code in code_fmkit/fmsignal.py def preprocess ( self , point , threshold = 0.2 , cut_freq = 10 , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Preprocess the signal. **NOTE**: This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to trim the signal without hand motion. cut_freq (float): Low pass filtering cutoff frequency. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: FMSignal: The preprocessed signal. **NOTE**: The default argument values are typically good enough. \"\"\" dim = 18 data = np . zeros (( self . length , dim ), dtype = np . float32 ) self . dim = dim self . data = data start , end = self . prepare_trim_by_acc ( point , threshold ) self . estimate_angular_states ( point ) self . pose_normalize ( start , end , p_yaw , p_pitch , p_roll ) self . estimate_linear_states ( point ) sample_freq = self . length / ( self . ts [ self . length - 1 ]) * 1000.0 #self.filter(sample_freq, cut_freq) #self.trim(start, end) assert self . ts . dtype == np . float32 assert self . data . dtype == np . float32 signal = FMSignal ( self . length , self . dim , self . ts , self . data , self . user , self . cid , self . seq ) return signal save_to_buffer_raw ( self ) Save the raw signal to a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default None None No argument. required Returns: Type Description ndarray The buffer. Source code in code_fmkit/fmsignal.py def save_to_buffer_raw ( self ): \"\"\"Save the raw signal to a NumPy ndarray. **NOTE**: This is only for internal usage. Args: None (None): No argument. Returns: ndarray: The buffer. \"\"\" array = np . zeros (( self . length , 20 ), dtype = np . float32 ) array [:, 0 ] = self . tsc array [:, 1 ] = self . ts array [:, 2 : 5 ] = self . acc0 array [:, 5 : 8 ] = self . gyro0 array [:, 8 : 11 ] = self . gravity0 array [:, 11 : 14 ] = self . acc1 array [:, 14 : 17 ] = self . gyro1 array [:, 17 : 20 ] = self . gravity1 return array save_to_file ( self , fn , mode ) General interface to save the raw signal to a file. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"General interface to save the raw signal to a file. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. \"\"\" if mode == \"raw_csv\" : array = self . save_to_buffer_raw () fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"raw_npy\" : array = self . save_to_buffer_raw () # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode ) trim ( self , start , end ) Trim the start and end of the signal where the hand does not move. NOTE : The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default start int The start index, i.e., data[start:end, :] will be kept. required end int The end index, i.e., data[start:end, :] will be kept. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def trim ( self , start , end ): \"\"\"Trim the start and end of the signal where the hand does not move. **NOTE**: The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: start (int): The start index, i.e., data[start:end, :] will be kept. end (int): The end index, i.e., data[start:end, :] will be kept. Returns: None: No return value. \"\"\" l_new = end - start # NOTE: These \"copy()\" force the \"ts\" and \"data\" to have proper C-like # array in memory, which is crucial for \"dtw_c()\"!!! self . data = self . data [ start : end , :] . copy () self . ts = self . ts [ start : end ] . copy () ts0 = self . ts [ 0 ] self . ts -= ts0 self . length = l_new if self . qs is not None : self . qs = self . qs [ start : end ] if self . rotms is not None : self . rotms = self . rotms [ start : end ] if self . trajectory is not None : self . trajectory = self . trajectory [ start : end ] FMSignalLeap Raw finger motion signal collected by the Leap Motion controller. This class represents the raw signal obtained from the Leap Motion sensor. An FMSignal object can be obtained by preprocessing this raw signal, where the preprocessing is essentially the main purpose of this FMSignalLeap class. It has the following additional attributes. Attributes: Name Type Description length int The number of samples in this signal. ts ndarray Timestamp obtained from the device (1D vector). tsc ndarray Timestamp obtained from the client computer (1D vector). tip ndarray Position of the index finger tip (length * 3 matrix). center ndarray Position of the palm center (length * 3 matrix). joints ndarray Position of each joint (length * 5 * 5 * 3 tensor). confs ndarray Confidence value of each sample (1D vector). valids ndarray Whether the sample is valid (1D vector). data ndarray The data after preprocessing. rotms ndarray The orientation of each smple in rotation matrices. qs list The orientation of each smple in unit quaternions. trajectory ndarray The motion trajectory of the selected point. NOTE : The \"joints\" is a length * 5 * 5 * 3 tensor, i.e., 5 fingers, 5 joints on each finger, and 3 coordinates for each joint. The sequence of fingers are [thumb, index finger, middle finger, ring finger, little finger]. The sequence of joints are from the end of the palm to the tip of the finger. For example, \"joints[:, 1, 0, :]\" is the trajectory of the palm end of the index finger, and \"joints[:, 1, 4, :]\" is the trajectory of the tip of the index finger. Note that the thumb has only four joints, i.e., \"joints[:, 0, 0, :]\" and \"joints[:, 0, 1, :]\" are identical. NOTE : The preprocessed signal contains the motion of only one point on the hand, which can be derived either from the center of the hand or the tip of the index finger. This is controlled by the \"point\" argument of the \"preprocess()\" method. NOTE : The raw signal file may have two different formats, i.e., either in Comma Separated Value (\".csv\") or in NumPy binary format (\".npy\"). However, the content structure is the same, which is essentially a matrix, where the rows are the samples at a certain time and the columns are the data from a specific sensor axis. See the \"Data Format Details\" document for more information. There is another format called \"raw_internal\", which is used to resolve format issues in the data collected at the early stage of this project. It is now obsolete. __init__ ( self , user = '' , cid = '' , seq = 0 ) special Constructor. See the attributes of FMSignal for the meaning of the arguments. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. Source code in code_fmkit/fmsignal.py def __init__ ( self , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the attributes of FMSignal for the meaning of the arguments. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. \"\"\" self . user = user self . cid = cid self . seq = seq self . length = 0 self . ts = None self . tsc = None self . tip = None self . center = None self . joints = None self . confs = None self . valids = None self . data = None self . qs = None self . rotms = None self . trajectory = None all_close_to ( self , signal ) Check whether this signal is almost identical to the other signal. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Parameters: Name Type Description Default signal FMSignalLeap The other signal to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , signal ): \"\"\"Check whether this signal is almost identical to the other signal. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Args: signal (FMSignalLeap): The other signal to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( signal , FMSignalLeap ): return False if self . length != signal . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , signal . ts , atol = 1e-6 ) r2 = np . allclose ( self . tsc , signal . tsc , atol = 1e-6 ) r3 = np . allclose ( self . tip , signal . tip , atol = 1e-6 ) r4 = np . allclose ( self . center , signal . center , atol = 1e-6 ) r5 = np . allclose ( self . joints , signal . joints , atol = 1e-6 ) r6 = np . allclose ( self . confs , signal . confs , atol = 1e-6 ) r7 = np . allclose ( self . valids , signal . valids , atol = 1e-6 ) return r1 and r2 and r3 and r4 and r5 and r6 and r7 construct_from_file ( fn , mode , user = '' , cid = '' , seq = 0 ) classmethod Construct a signal by loading data from a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignalLeap The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is wrong. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Construct a signal by loading data from a file. Args: fn (string): The file name (without extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignalLeap: The constructed signal object. Raises: ValueError: If the \"mode\" is wrong. FileNotFoundError: If the file does not exist. \"\"\" signal = FMSignalLeap ( user , cid , seq ) signal . load_from_file ( fn , mode ) return signal estimate_angular_states ( self , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ) Estimate orientation, angular speed, and angular acceleration. NOTE : Orientations are represented as the qx, qy, and qz components of a unit quaternion. It is obtained by the position of the joints of the hand. NOTE : Currently, the angular speed is the relative local differential of the angular position. The angular acceleration is just the differential of the angular speed, not the real angular acceleration. In this way, even if the reference frame changes, the angular speed will not change. Hence, we add three purtubation angles to change the local reference frame a bit as needed, mainly for data augmentation usage. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. This method should be called after the pose normalization step. NOTE : Currently, this method iterates through each sample, which is relatively slow. Parameters: Name Type Description Default p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def estimate_angular_states ( self , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Estimate orientation, angular speed, and angular acceleration. **NOTE**: Orientations are represented as the qx, qy, and qz components of a unit quaternion. It is obtained by the position of the joints of the hand. **NOTE**: Currently, the angular speed is the relative local differential of the angular position. The angular acceleration is just the differential of the angular speed, not the real angular acceleration. In this way, even if the reference frame changes, the angular speed will not change. Hence, we add three purtubation angles to change the local reference frame a bit as needed, mainly for data augmentation usage. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. This method should be called after the pose normalization step. **NOTE**: Currently, this method iterates through each sample, which is relatively slow. Args: p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: None: No return value. \"\"\" data = self . data ts = self . ts # rotation matrix of each data sample rotms = np . zeros (( self . length , 3 , 3 )) # pose offset, for augmentation R_offset = euler_zyx_to_rotation_matrix ( p_yaw , p_pitch , p_roll ) # quaternion of each data sample qs = [ None ] * self . length omega_pre = np . asarray (( 0.0 , 0.0 , 0.0 )) for i in range ( self . length ): joints = self . joints [ i ] # Origin is the near end of the index finger. # p0 = joints[1, 1] p0 = joints [ 1 , 0 ] # Pointing direction is from the near end to the next joint along # the index finger. # p1 = joints[1, 2] p1 = joints [ 1 , 1 ] # The side direction is from the near end of the index finger to # the near end of the little finger. # p2 = joints[4, 1] p2 = joints [ 4 , 0 ] # derive the pose represented in three orthogonal vectors, # i.e., vx, vy, vz # Note that here vx is the general pointing direction, vz is the # general palm facing direction vx = p1 - p0 vy_prime = p0 - p2 vz = np . cross ( vx , vy_prime ) if np . linalg . norm ( vx ) <= 1e-6 : print ( i , p0 , p1 ) # most of the time the palm is facing downward, so we flip the # axes here to set up a local reference frame where the z-axis # is always upward. # CAUTION: There are chances that the sensor wrongly recognize the # right hand as the palm facing upward. Similarly, there are cases # that the right hand is wrongly identified as the left hand. In # either cases, we just always make the z-axis upward. # if vz[2] < 0: # vz = -vz vy = np . cross ( vz , vx ) vz = np . cross ( vx , vy ) vx = vx / np . linalg . norm ( vx ) vy = vy / np . linalg . norm ( vy ) vz = vz / np . linalg . norm ( vz ) vx = vx . reshape (( 3 , 1 )) vy = vy . reshape (( 3 , 1 )) vz = vz . reshape (( 3 , 1 )) # CAUTION: this is just an approximation of a rotation matrix, # and it may not be perfectly northonormal!!! rotm = np . concatenate (( vx , vy , vz ), axis = 1 ) q = Quaternion . construct_from_rotation_matrix ( rotm ) # print(q, q.norm()) # u = rotation_matrix_to_angle_axis(rotm) if i > 0 : pv = qs [ i - 1 ] . to_vector () qv = q . to_vector () p1 = np . linalg . norm ( pv - qv ) p2 = np . linalg . norm ( pv + qv ) if p1 > p2 : q = q . negate () # Now since it is a unit quaternion encoding the rotation, we # convert it back to a rotation matrix for future usage # rotm = q.to_rotation_matrix() qs [ i ] = q rotms [ i ] = rotm # Now we derive the three Tait-Bryan angles # CAUTION: yaw first, then pitch, then roll # i.e., z-y-x intrinsic rotation (east, north, sky) # yaw, pitch, roll, gimbal_lock \\ # = rotation_matrix_to_euler_angles_zyx(rotm) # # data[i, 9] = roll # data[i, 10] = pitch # data[i, 11] = yaw # # assert not gimbal_lock # Tait-Bryan angles have singularity. # Use quaternion components instead. data [ i , 9 ] = q . x data [ i , 10 ] = q . y data [ i , 11 ] = q . z # data[i, 9:12] = u if i > 0 : timestep = ts [ i ] - ts [ i - 1 ] if timestep > 0 : p = qs [ i - 1 ] omega = Quaternion . differentiate_local ( p , q , timestep ) else : omega = omega_pre omega_pre = omega data [ i , 12 ] = omega [ 0 ] * 1000 data [ i , 13 ] = omega [ 1 ] * 1000 data [ i , 14 ] = omega [ 2 ] * 1000 data [ 0 , 12 ] = data [ 1 , 12 ] data [ 0 , 13 ] = data [ 1 , 13 ] data [ 0 , 14 ] = data [ 1 , 14 ] ov = data [:, 12 : 15 ] . T ov = np . matmul ( R_offset , ov ) data [:, 12 : 15 ] = ov . T data [:, 15 ] = np . gradient ( data [:, 12 ]) data [:, 16 ] = np . gradient ( data [:, 13 ]) data [:, 17 ] = np . gradient ( data [:, 14 ]) #print(data.dtype) self . data = data self . dim = 18 self . rotms = rotms self . qs = qs estimate_linear_states ( self , point ) Estimate position, velocity and acceleration. NOTE : For the Leap Motion device, only the position is directly obtained from the device. The velocity and acceleration are derived by differentiating the the position. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def estimate_linear_states ( self , point ): \"\"\"Estimate position, velocity and acceleration. **NOTE**: For the Leap Motion device, only the position is directly obtained from the device. The velocity and acceleration are derived by differentiating the the position. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". Returns: None: No return value. \"\"\" data = self . data # print(data.dtype) if point == \"tip\" : # Use the tip of the index finger. data [:, 0 : 3 ] = self . tip self . trajectory = self . tip . copy () elif point == \"center\" : # Use the center of the palm. data [:, 0 : 3 ] = self . center self . trajectory = self . center . copy () else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) data [:, 3 ] = np . gradient ( data [:, 0 ]) data [:, 4 ] = np . gradient ( data [:, 1 ]) data [:, 5 ] = np . gradient ( data [:, 2 ]) data [:, 6 ] = np . gradient ( data [:, 3 ]) data [:, 7 ] = np . gradient ( data [:, 4 ]) data [:, 8 ] = np . gradient ( data [:, 5 ]) # print(data.dtype) self . data = data filter ( self , sample_freq , cut_freq ) Low-pass filtering on the signal. NOTE : It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default sample_freq float sample frequency of this signal. required cut_freq float low pass filtering cutoff frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def filter ( self , sample_freq , cut_freq ): \"\"\"Low-pass filtering on the signal. **NOTE**: It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: sample_freq (float): sample frequency of this signal. cut_freq (float): low pass filtering cutoff frequency. Returns: None: No return value. \"\"\" l = self . length data = self . data cut_l = int ( cut_freq * l / sample_freq ) dft_co = np . fft . fft ( data , l , axis = 0 ) for i in range ( cut_l , l - cut_l ): dft_co [ i ] = 0 + 0 j ifft_c = np . fft . ifft ( dft_co , l , axis = 0 ) # NOTE: This must be converted to \"np.float32\"! ifft = ifft_c . real . astype ( np . float32 ) #print(ifft.dtype) self . data = ifft fix_missing_samples ( self ) Fix missing data samples by linear interpolation. NOTE : This is only for internal usage. The missing samples are mainly caused by the motion of the hand which are outside the field of the view of the sensor. This procedure assumes that the first sample is always valid! Since it uses linear interpolation, it will not work well with too many missing samples. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default None None No argument. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def fix_missing_samples ( self ): \"\"\"Fix missing data samples by linear interpolation. **NOTE**: This is only for internal usage. The missing samples are mainly caused by the motion of the hand which are outside the field of the view of the sensor. This procedure assumes that the first sample is always valid! Since it uses linear interpolation, it will not work well with too many missing samples. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: None (None): No argument. Returns: None: No return value. \"\"\" l = self . length i = 0 while i < l - 1 : # Find the start index of a missing segment. while i < l - 1 : if self . valids [ i ] == 0 : break else : i += 1 # Find the end index of a missing segment. j = i while j < l - 1 : if self . valids [ j ] == 1 : break else : j += 1 # If missing points found between i and j, fix them. # If no missing point found, just skip. if i < j : # print(i, j) start_ts = self . ts [ i - 1 ] end_ts = self . ts [ j ] start_tip = self . tip [ i - 1 ] end_tip = self . tip [ j ] length_tip = ( end_tip - start_tip ) start_center = self . center [ i - 1 ] end_center = self . center [ j ] length_center = ( end_center - start_center ) start_joints = self . joints [ i - 1 ] end_joints = self . joints [ j ] length_joints = ( end_joints - start_joints ) for k in range ( i , j ): k_ts = self . ts [ k ] rate = ( k_ts - start_ts ) * 1.0 / ( end_ts - start_ts ) self . tip [ k ] = start_tip + length_tip * rate self . center [ k ] = start_center + length_center * rate self . joints [ k ] = start_joints + length_joints * rate self . valids [ k ] = 1 # Find another missing sement in the next iteration i = j load_from_buffer_raw ( self , array ) Load data from a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default array ndarray The buffer. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw ( self , array ): \"\"\"Load data from a NumPy ndarray. **NOTE**: This is only for internal usage. Args: array (ndarray): The buffer. Returns: None: No return value. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] assert m == 2 + 3 + 3 + 75 + 2 , \"Wrong raw file format: m = %d \" % m self . length = l self . ts = array [:, 1 ] . flatten () self . tsc = array [:, 0 ] . flatten () offset_tip = 2 offset_center = 2 + 3 offset_joints = 2 + 3 + 3 self . tip = array [:, offset_tip : offset_tip + 3 ] self . center = array [:, offset_center : offset_center + 3 ] # Load joint positions self . joints = np . zeros (( l , 5 , 5 , 3 ), np . float32 ) for j in range ( 5 ): for k in range ( 5 ): index = offset_joints + j * 5 * 3 + k * 3 self . joints [:, j , k , :] = array [:, index : index + 3 ] # Load confidences and valid flags self . confs = array [:, - 2 ] self . valids = array [:, - 1 ] load_from_buffer_raw_internal ( self , array ) Load data from a NumPy ndarray in the \"raw_internal\" format. NOTE : This is only for internal usage. Parameters: Name Type Description Default array ndarray The buffer. required Returns: Type Description None No Return value. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw_internal ( self , array ): \"\"\"Load data from a NumPy ndarray in the \"raw_internal\" format. **NOTE**: This is only for internal usage. Args: array (ndarray): The buffer. Returns: None: No Return value. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] # --------- process timestamp ------ if m == 133 or m == 93 : # NOTE: This is the old format, with only one timestamp. offset_base = 1 ts = array [:, 0 ] . flatten () tsc = np . zeros ( l , np . float32 ) elif m == 134 : # CATUION: the current format, with two timestamps. offset_base = 2 ts = array [:, 1 ] . flatten () tsc = array [:, 0 ] . flatten () # Use an offset to reduce the size of tsc so that it can fit into # the float32 type. tsc -= 1514764800 else : raise ValueError ( \"Unknown data file format!: m = %d \" % m ) for i in range ( l ): # fix timestamp wraping over maximum of uint32 if i > 0 and ts [ i ] < ts [ i - 1 ]: ts [ i ] += 4294967295.0 # Fix timestamp offset and convert timestamp to millisecond # CAUTION: timestamp must start from 0! Other methods such as filtering # depend on this assumption! ts0 = ts [ 0 ] ts -= ts0 ts /= 1000 # --------- process point coordinate and joint coordinate ------ offset_tip = offset_base offset_center = offset_base + 6 offset_joints = offset_base + 6 + 9 data_tip = np . zeros (( l , 3 ), np . float32 ) # NOTE: Axes mapping: yzx -> xyz data_tip [:, 0 ] = array [:, offset_tip + 2 ] data_tip [:, 1 ] = array [:, offset_tip + 0 ] data_tip [:, 2 ] = array [:, offset_tip + 1 ] data_center = np . zeros (( l , 3 ), np . float32 ) # NOTE: Axes mapping: yzx -> xyz data_center [:, 0 ] = array [:, offset_center + 2 ] data_center [:, 1 ] = array [:, offset_center + 0 ] data_center [:, 2 ] = array [:, offset_center + 1 ] data_joints = np . zeros (( l , 5 , 5 , 3 ), np . float32 ) # Load joint positions for j in range ( 5 ): for k in range ( 5 ): index = j * 5 * 3 + k * 3 # NOTE: Axes mapping: yzx -> xyz data_joints [:, j , k , 0 ] = array [:, offset_joints + index + 2 ] data_joints [:, j , k , 1 ] = array [:, offset_joints + index + 0 ] data_joints [:, j , k , 2 ] = array [:, offset_joints + index + 1 ] # Load confidences and valid flags confs = array [:, - 2 ] valids = array [:, - 1 ] self . length = l self . ts = ts . astype ( np . float32 ) self . tsc = tsc . astype ( np . float32 ) self . tip = data_tip self . center = data_center self . joints = data_joints self . confs = confs . astype ( np . float32 ) self . valids = valids . astype ( np . float32 ) load_from_file ( self , fn , mode ) General interface to load the raw signal from a file. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"General interface to load the raw signal from a file. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"raw_internal\" : fn += \".txt\" # NOTE: The \"dtype\" needs to be np.float64 for the raw timestamps! array = np . loadtxt ( fn , np . float64 , delimiter = \",\" ) self . load_from_buffer_raw_internal ( array ) elif mode == \"raw_csv\" : fn += \".csv\" array = np . loadtxt ( fn , np . float32 , delimiter = \",\" ) self . load_from_buffer_raw ( array ) elif mode == \"raw_npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 self . load_from_buffer_raw ( array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode ) pose_normalize ( self , point , start , end , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ) Normalize the position and orientation of the signal. NOTE : The new x-axis is the average of the pointing direction, the new z-axis is the vertical up direction of the leap motion sensor (assuming the sensor is placed on a horizontal surface), and the new y-axis is determined by the new x-axis and y-axis. NOTE : The three angles in the argument are offsets that applied during the normalization in radians. This can be used in orientation purtubation for data augmentation or correcting the pointing direction. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required start int The start time index of the signal for normalization. required end int The end time index of the signal for normalization. required p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description None No return value. Exceptions: Type Description ValueError If the \"point\" is wrong or the \"start\" or \"end\" is bad. Source code in code_fmkit/fmsignal.py def pose_normalize ( self , point , start , end , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Normalize the position and orientation of the signal. **NOTE**: The new x-axis is the average of the pointing direction, the new z-axis is the vertical up direction of the leap motion sensor (assuming the sensor is placed on a horizontal surface), and the new y-axis is determined by the new x-axis and y-axis. **NOTE**: The three angles in the argument are offsets that applied during the normalization in radians. This can be used in orientation purtubation for data augmentation or correcting the pointing direction. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". start (int): The start time index of the signal for normalization. end (int): The end time index of the signal for normalization. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: None: No return value. Raises: ValueError: If the \"point\" is wrong or the \"start\" or \"end\" is bad. \"\"\" l = self . length if start < 0 and end >= l and end <= start : raise ValueError ( \"Bad start and end indices: %d , %d .\" \\ % ( start , end )) # Find the average position. if point == \"tip\" : # Use the tip of the index finger. pos = self . tip [ start : end ] elif point == \"center\" : # Use the center of the palm. pos = self . center [ start : end ] else : raise ValueError ( \"Unknown point type: %s .\" % str ( point )) pos_mean = np . mean ( pos , axis = 0 ) # Position normalization. self . translate ( - pos_mean ) # Find the average orientation. data_joints = self . joints if point == \"tip\" : # Use the direction of the middle segment of the index finger. p0 = data_joints [ start : end , 1 , 1 , :] p1 = data_joints [ start : end , 1 , 2 , :] elif point == \"center\" : # Use the direction of the last segment of the middle finger. p0 = data_joints [ start : end , 2 , 0 , :] p1 = data_joints [ start : end , 2 , 1 , :] else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) vx = np . mean ( p1 - p0 , axis = 0 ) vz_t = np . asarray (( 0.0 , 0.0 , 1.0 ), np . float32 ) vy = np . cross ( vz_t , vx ) vz = np . cross ( vx , vy ) vx = vx / np . linalg . norm ( vx ) vy = vy / np . linalg . norm ( vy ) vz = vz / np . linalg . norm ( vz ) vx = vx . reshape (( 3 , 1 )) vy = vy . reshape (( 3 , 1 )) vz = vz . reshape (( 3 , 1 )) # Orientation normalization. # NOTE: \"p_yaw\", \"p_pitch\", \"p_roll\" are orientation pertubation. They # are all in radian. R_g2l = np . concatenate (( vx , vy , vz ), axis = 1 ) R_l2g = R_g2l . transpose () R_offset = euler_zyx_to_rotation_matrix ( p_yaw , p_pitch , p_roll ) R_l2g = np . matmul ( R_offset , R_l2g ) self . rotate ( R_l2g ) prepare_trim_by_velocity ( self , point , threshold ) Determine the indicies for the start and end of the finger motion. NOTE : The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. NOTE : This method is only used in the preprocessing procedure. This method DOES NOT modify the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to detect the hand motion. required Returns: Type Description None No return value. NOTE : The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. Source code in code_fmkit/fmsignal.py def prepare_trim_by_velocity ( self , point , threshold ): \"\"\"Determine the indicies for the start and end of the finger motion. **NOTE**: The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. **NOTE**: This method is only used in the preprocessing procedure. This method **DOES NOT** modify the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to detect the hand motion. Returns: None: No return value. **NOTE**: The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. \"\"\" if point == \"tip\" : # Use the tip of the index finger. pos = self . tip elif point == \"center\" : # Use the center of the palm. pos = self . center else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) vel = pos . copy () l = self . length # The \"start\" and \"end\" are determined by the relative velocity. It is # calculated here by taking gradient of the position and then # normalizing it. vel [:, 0 ] = np . gradient ( pos [:, 0 ]) vel [:, 1 ] = np . gradient ( pos [:, 1 ]) vel [:, 2 ] = np . gradient ( pos [:, 2 ]) v = np . linalg . norm ( vel , axis = 1 ) v_std = np . std ( v ) # NOTE: We cannot subtract the mean of velocity here. vn = np . divide ( v , v_std ) # Determine the start start = 0 for i in range ( l ): if abs ( vn [ i ]) > threshold : start = i - 5 break start = max ( start , 0 ) end = 0 for i in range ( l - 1 , 0 , - 1 ): if abs ( vn [ i ]) > threshold : end = i + 5 break end = min ( end , l ) # print(self.id_label, self.seq, l, start, l - end) return ( start , end ) preprocess ( self , point , threshold = 0.2 , cut_freq = 10 , re_freq = 50 , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ) Preprocess the signal. NOTE : This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to trim the signal without hand motion. 0.2 cut_freq float Low pass filtering cutoff frequency. 10 re_freq float Resampling frequency. 50 p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description FMSignal The preprocessed signal. NOTE : The default argument values are typically good enough. Source code in code_fmkit/fmsignal.py def preprocess ( self , point , threshold = 0.2 , cut_freq = 10 , re_freq = 50 , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Preprocess the signal. **NOTE**: This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to trim the signal without hand motion. cut_freq (float): Low pass filtering cutoff frequency. re_freq (float): Resampling frequency. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: FMSignal: The preprocessed signal. **NOTE**: The default argument values are typically good enough. \"\"\" self . fix_missing_samples () self . resample ( re_freq ) start , end = self . prepare_trim_by_velocity ( point , threshold ) self . pose_normalize ( point , start , end , p_yaw , p_pitch , p_roll ) # For the Leap Motion device, position is directly observable. dim = 18 data = np . zeros (( self . length , dim ), dtype = np . float32 ) self . dim = dim self . data = data self . estimate_linear_states ( point ) self . estimate_angular_states ( p_yaw , p_pitch , p_roll ) self . filter ( re_freq , cut_freq ) self . trim ( start , end ) assert self . ts . dtype == np . float32 assert self . data . dtype == np . float32 signal = FMSignal ( self . length , self . dim , self . ts , self . data , self . user , self . cid , self . seq ) return signal resample ( self , re_freq ) Resample the signal at a specified frequency. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. This method uses linear interpolation for resampling. Parameters: Name Type Description Default re_freq float Resampling frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def resample ( self , re_freq ): \"\"\"Resample the signal at a specified frequency. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. This method uses linear interpolation for resampling. Args: re_freq (float): Resampling frequency. Returns: None: No return value. \"\"\" ts = self . ts l = self . length duration = ts [ l - 1 ] - ts [ 0 ] step = 1000.0 / re_freq l_new = int ( duration / 1000.0 * re_freq ) ts_re = np . arange ( 0 , step * l_new , step , dtype = np . float32 ) a_tip_re = np . zeros (( l_new , 3 ), dtype = np . float32 ) for j in range ( 3 ): a_tip_re [:, j ] = np . interp ( ts_re , ts , self . tip [:, j ]) a_center_re = np . zeros (( l_new , 3 ), dtype = np . float32 ) for j in range ( 3 ): a_center_re [:, j ] = np . interp ( ts_re , ts , self . center [:, j ]) data_joints_re = np . zeros (( l_new , 5 , 5 , 3 ), np . float32 ) for j in range ( 5 ): for k in range ( 5 ): for v in range ( 3 ): data_joints_re [:, j , k , v ] = np . interp ( ts_re , ts , self . joints [:, j , k , v ] ) confs_resample = np . interp ( ts_re , ts , self . confs ) . astype ( np . float32 ) valids_resample = np . ones ( l_new , dtype = np . float32 ) # NOTE: Make sure they all have \"dtype == np.float32\"! # print(ts_re.dtype) # print(a_tip_re.dtype) # print(a_center_re.dtype) # print(data_joints_re.dtype) # print(confs_resample.dtype) # print(valids_resample.dtype) self . length = l_new self . ts = ts_re self . tip = a_tip_re self . center = a_center_re self . joints = data_joints_re self . confs = confs_resample self . valids = valids_resample rotate ( self , R ) Rotate the signal coorindate reference frame. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default R ndarray The 3-by-3 rotation matrix. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def rotate ( self , R ): \"\"\"Rotate the signal coorindate reference frame. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: R (ndarray): The 3-by-3 rotation matrix. Returns: None: No return value. \"\"\" pv = self . tip [:, 0 : 3 ] . T pv = np . matmul ( R , pv ) self . tip [:, 0 : 3 ] = pv . T pv = self . center [:, 0 : 3 ] . T pv = np . matmul ( R , pv ) self . center [:, 0 : 3 ] = pv . T for j in range ( 5 ): for k in range ( 5 ): pv = self . joints [:, j , k ] . T pv = np . matmul ( R , pv ) self . joints [:, j , k ] = pv . T save_to_buffer_raw ( self ) Save the raw signal to a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default None None No argument. required Returns: Type Description ndarray The buffer. Source code in code_fmkit/fmsignal.py def save_to_buffer_raw ( self ): \"\"\"Save the raw signal to a NumPy ndarray. **NOTE**: This is only for internal usage. Args: None (None): No argument. Returns: ndarray: The buffer. \"\"\" m = 2 + 3 + 3 + 75 + 2 array = np . zeros (( self . length , m ), np . float32 ) array [:, 0 ] = self . tsc array [:, 1 ] = self . ts offset_tip = 2 offset_center = 2 + 3 offset_joints = 2 + 3 + 3 array [:, offset_tip : offset_tip + 3 ] = self . tip array [:, offset_center : offset_center + 3 ] = self . center for j in range ( 5 ): for k in range ( 5 ): index = offset_joints + j * 5 * 3 + k * 3 array [:, index : index + 3 ] = self . joints [:, j , k , :] array [:, - 2 ] = self . confs array [:, - 1 ] = self . valids return array save_to_file ( self , fn , mode ) General interface to save the raw signal to a file. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"General interface to save the raw signal to a file. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. \"\"\" if mode == \"raw_csv\" : array = self . save_to_buffer_raw () fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"raw_npy\" : array = self . save_to_buffer_raw () # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode ) translate ( self , t ) Translate the signal coorindate reference frame. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default t ndarray The 3D translation vector. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def translate ( self , t ): \"\"\"Translate the signal coorindate reference frame. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: t (ndarray): The 3D translation vector. Returns: None: No return value. \"\"\" self . tip += t self . center += t for j in range ( 5 ): for k in range ( 5 ): self . joints [:, j , k ] += t trim ( self , start , end ) Trim the start and the end where the hand does not move. NOTE : The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Source code in code_fmkit/fmsignal.py def trim ( self , start , end ): \"\"\"Trim the start and the end where the hand does not move. **NOTE**: The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. \"\"\" l_new = end - start # NOTE: These \"copy()\" force the \"ts\" and \"data\" to have proper C-like # array in memory, which is crucial for \"dtw_c()\"!!! self . data = self . data [ start : end , :] . copy () self . ts = self . ts [ start : end ] . copy () ts0 = self . ts [ 0 ] self . ts -= ts0 self . length = l_new if self . qs is not None : self . qs = self . qs [ start : end ] if self . rotms is not None : self . rotms = self . rotms [ start : end ] if self . trajectory is not None : self . trajectory = self . trajectory [ start : end ] self . tip = self . tip [ start : end ] self . center = self . center [ start : end ] self . joints = self . joints [ start : end ] self . confs = self . confs [ start : end ] self . valids = self . valids [ start : end ] FMSignalTemplate FMSignal signal template constructed from a collection of signals. In most cases, template is identical to a signal (preprocessed, sensor agnostic) with a few additional attributes. Note that this class is derived from the class \"FMSignal\". Attributes: Name Type Description variance ndarray The variance of the signal (length * 18 matrix). signals_aligned ndarray The signals for constructing the template. NOTE : The variance is calculates at sample level, so it has the same length and dimension as the data, i.e., a length * 18 matrix. NOTE : The \"signals_aligned\" is only valid if it is constructed from a collection of signals, i.e., by calling \"construct_from_signals()\". It is not valid if the template is loaded from a file. __init__ ( self , length = 0 , dim = 0 , ts = None , data = None , variance = None , signals_aligned = None , user = '' , cid = '' , seq = 0 ) special Constructor. See the attributes of FMSignal for the meaning of the arguments. Source code in code_fmkit/fmsignal.py def __init__ ( self , length = 0 , dim = 0 , ts = None , data = None , variance = None , signals_aligned = None , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the attributes of FMSignal for the meaning of the arguments. \"\"\" FMSignal . __init__ ( self , length , dim , ts , data , user , cid , seq ) self . variance = variance self . signals_aligned = signals_aligned all_close_to ( self , template ) Check whether this template is almost identical to another template. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two templates must have the same type and length. Parameters: Name Type Description Default template FMSignalTemplate The other template to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , template ): \"\"\"Check whether this template is almost identical to another template. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two templates must have the same type and length. Args: template (FMSignalTemplate): The other template to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( template , FMSignal ): return False if self . length != template . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , template . ts , atol = 1e-6 ) r2 = np . allclose ( self . data , template . data , atol = 1e-6 ) r3 = np . allclose ( self . variance , template . variance , atol = 1e-6 ) return r1 and r2 and r3 construct_from_file ( fn , mode , user = '' , cid = '' , seq = 0 ) classmethod Factory method to build the signal by loading a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignalTemplate The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is wrong. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Factory method to build the signal by loading a file. Args: fn (string): The file name (without extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignalTemplate: The constructed signal object. Raises: ValueError: If the \"mode\" is wrong. FileNotFoundError: If the file does not exist. \"\"\" template = cls () template . load_from_file ( fn , mode ) template . user = user template . cid = cid template . seq = seq return template construct_from_signals ( signals , template_index , window = 50 , penalty = 0 ) classmethod Construct the template by aligning and average a set of signals. Parameters: Name Type Description Default signals list The collection of signals (FMSignal objects). required template_index int The index indicating the alignment. required window int Alignment window, see \"dtw()\". 50 penalty int Element-wise misalignment penalty, see \"dtw()\". 0 NOTE : The \"signals\" should be a collection of signals Source code in code_fmkit/fmsignal.py @classmethod def construct_from_signals ( cls , signals , template_index , window = 50 , penalty = 0 ): \"\"\"Construct the template by aligning and average a set of signals. Args: signals (list): The collection of signals (FMSignal objects). template_index (int): The index indicating the alignment. window (int): Alignment window, see \"dtw()\". penalty (int): Element-wise misalignment penalty, see \"dtw()\". **NOTE**: The \"signals\" should be a collection of signals \"\"\" signal_t = signals [ template_index ] signals_aligned = [ signal_t ] k = len ( signals ) # construct signal template length = signal_t . length dim = signal_t . dim ts = signal_t . ts . copy () data = signal_t . data . copy () variance = np . zeros ( signal_t . data . shape , signal_t . data . dtype ) for signal in signals : if signal == signal_t : continue signal_aligned = signal . align_to ( signal_t , window , penalty ) signals_aligned . append ( signal_aligned ) data += signal_aligned . data data /= k for signal_aligned in signals_aligned : variance += np . square ( signal_aligned . data - data ) variance /= k template = cls ( length , dim , ts , data , variance , signals_aligned , signal_t . user , signal_t . cid , signal_t . seq ) return template load_from_file ( self , fn , mode ) General interface to load the template from a file. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"General interface to load the template from a file. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"csv\" : fn += \".csv\" array = np . loadtxt ( fn , dtype = np . float32 , delimiter = \",\" ) assert array . shape [ 1 ] == 37 l = array . shape [ 0 ] d = 18 ts = array [:, 0 : 1 ] data_and_variance = array [:, 1 :] data = data_and_variance [:, : d ] variance = data_and_variance [:, d :] elif mode == \"npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 assert array . shape [ 1 ] == 37 l = array . shape [ 0 ] d = 18 ts = array [:, 0 : 1 ] data = array [:, 1 :( d + 1 )] variance = array [:, ( d + 1 ):] else : raise ValueError ( \"Unknown file mode %s !\" % mode ) assert d == 18 self . length = l self . dim = d self . ts = ts self . data = data self . variance = variance save_to_file ( self , fn , mode ) General interface to save the template to a file. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"General interface to save the template to a file. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. \"\"\" l = self . length array_tup = ( self . ts . reshape (( l , 1 )), self . data , self . variance ) array = np . concatenate ( array_tup , axis = 1 ) if mode == \"csv\" : fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"npy\" : assert array . dtype == np . float32 # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode ) update ( self , new_signal , factor ) Update the template with a new signal. Parameters: Name Type Description Default new_signal FMSignal The new signal S used to update the template. required factor float The update factor, i.e., T_{new} = (1-factor) T_{old} + S factor. required Returns: Type Description None No return value. NOTE : The \"new_signal\" must be already aligned to the template. Source code in code_fmkit/fmsignal.py def update ( self , new_signal , factor ): \"\"\"Update the template with a new signal. Args: new_signal (FMSignal): The new signal S used to update the template. factor (float): The update factor, i.e., T_{new} = (1-factor)*T_{old} + S*factor. Returns: None: No return value. **NOTE**: The \"new_signal\" must be already aligned to the template. \"\"\" # update the signal template self . data = self . data * ( 1 - factor ) + new_signal . data * factor dtw ( series_1 , series_2 , window = 0 , penalty = 0 ) Dynamic Time Warping (DTW) on two multidimensional time series. SEE : Dynamic Time Warping NOTE : This is the python implementation. It iteratively accesses each element of the time series array, which could be very slow. Parameters: Name Type Description Default series_1 ndarray The first array, n-by-d numpy ndarray. required series_2 ndarray The second array, m-by-d numpy ndarray. required window int The window constraint, by default no constraint. 0 penalty float The misalign penalty, by default zero. 0 Returns: Type Description tuple A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Exceptions: Type Description ValueError If the input series have incompatible dimensions. Source code in code_fmkit/fmsignal.py def dtw ( series_1 , series_2 , window = 0 , penalty = 0 ): \"\"\"Dynamic Time Warping (DTW) on two multidimensional time series. **SEE**: [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) **NOTE**: This is the python implementation. It iteratively accesses each element of the time series array, which could be very slow. Args: series_1 (ndarray): The first array, n-by-d numpy ndarray. series_2 (ndarray): The second array, m-by-d numpy ndarray. window (int): The window constraint, by default no constraint. penalty (float): The misalign penalty, by default zero. Returns: tuple: A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Raises: ValueError: If the input series have incompatible dimensions. \"\"\" if not isinstance ( series_1 , np . ndarray ) \\ or not isinstance ( series_2 , np . ndarray ) \\ or len ( series_1 . shape ) != 2 or len ( series_2 . shape ) != 2 \\ or series_1 . dtype != np . float32 or series_2 . dtype != np . float32 : raise ValueError ( 'Input series must be l-by-d NumPy ndarrays!' ) n = series_1 . shape [ 0 ] m = series_2 . shape [ 0 ] d1 = series_1 . shape [ 1 ] d2 = series_2 . shape [ 1 ] if d1 != d2 : raise ValueError ( 'Input series must have the same dimension!' ) if series_1 . dtype != np . float32 or series_2 . dtype != np . float32 : raise ValueError ( 'Input series must have \"dtype == np.float32\"!' ) # NOTE: By default, the window is set to a sufficiently large value (m * 2) # to essentially remove the window constraint. if window <= 0 : window = m * 2 # These are the distance matrix and the direction table. dist_matrix = np . zeros (( n + 1 , m + 1 ), np . float32 ) direction = np . zeros (( n + 1 , m + 1 ), np . int32 ) # These are the index mapping to align series_2 to series_1. a2to1_start = np . zeros ( n , np . int32 ) a2to1_end = np . zeros ( n , np . int32 ) # These are the index mapping to align series_1 to series_2. a1to2_start = np . zeros ( m , np . int32 ) a1to2_end = np . zeros ( m , np . int32 ) # Initialization. dist_matrix . fill ( 1e6 ) dist_matrix [ 0 , 0 ] = 0 direction [ 0 , 0 ] = 0 #dist_matrix[:, 0] = 0 #dist_matrix[0, :] = 0 # find the warping path for i in range ( 1 , n + 1 ): jj = int ( float ( m ) / n * i ) start = jj - window if jj - window > 1 else 1 end = jj + window if jj + window < m + 1 else m + 1 for j in range ( start , end ): # CAUTION: series_1[0] and series_2[0] mapps to dists[1][1], # and i, j here are indexing dists instead of the series, # i.e., dists[i][j] is comparing series_1[i - 1] and series_2[j - 1] cost = np . linalg . norm ( series_1 [ i - 1 ] - series_2 [ j - 1 ]) min_dist = dist_matrix [ i - 1 , j - 1 ] direction [ i , j ] = 1 # 1 stands for diagonal if dist_matrix [ i - 1 , j ] + penalty < min_dist : min_dist = dist_matrix [ i - 1 , j ] + penalty direction [ i , j ] = 2 # 2 stands for the i direction if dist_matrix [ i ][ j - 1 ] + penalty < min_dist : min_dist = dist_matrix [ i ][ j - 1 ] + penalty direction [ i , j ] = 4 # 4 stands for the j direction dist_matrix [ i ][ j ] = cost + min_dist # trace back the warping path to find element-wise mapping # print('warping path done') a2to1_start [ n - 1 ] = m - 1 a2to1_end [ n - 1 ] = m - 1 a1to2_start [ m - 1 ] = n - 1 a1to2_end [ m - 1 ] = n - 1 i = n j = m while True : if direction [ i , j ] == 2 : # the i direction i -= 1 a2to1_start [ i - 1 ] = j - 1 a2to1_end [ i - 1 ] = j - 1 a1to2_start [ j - 1 ] = i - 1 elif direction [ i , j ] == 4 : # the j direction j -= 1 a1to2_start [ j - 1 ] = i - 1 a1to2_end [ j - 1 ] = i - 1 a2to1_start [ i - 1 ] = j - 1 elif direction [ i , j ] == 1 : # the diagonal direction i -= 1 j -= 1 if i == 0 and j == 0 : break a2to1_start [ i - 1 ] = j - 1 a2to1_end [ i - 1 ] = j - 1 a1to2_start [ j - 1 ] = i - 1 a1to2_end [ j - 1 ] = i - 1 else : # direction[i][j] == 0, the corner break series_2to1 = np . zeros ( series_1 . shape , series_1 . dtype ) for i , jj , kk in zip ( range ( n ), a2to1_start , a2to1_end ): if jj == kk : series_2to1 [ i ] = series_2 [ jj ] else : series_2to1 [ i ] = np . mean ( series_2 [ jj : kk + 1 , :], axis = 0 ) return dist_matrix [ n , m ], dist_matrix [ 1 :, 1 :], direction , \\ a2to1_start , a2to1_end , a1to2_start , a1to2_end , series_2to1 dtw_c ( series_1 , series_2 , window = 0 , penalty = 0 ) Python wrapper of the Dynamic Time Warping (DTW) implemented in C. SEE : Dynamic Time Warping SEE : The \"fmkit_cutils\" package in this project has the implementation. NOTE : This is a Python wrapper of the C implementation, which is relative fast compared to the pure Python implementation. NOTE : The input series must have \"dtype == np.float32\". Parameters: Name Type Description Default series_1 ndarray The first array, n-by-d numpy ndarray. required series_2 ndarray The second array, m-by-d numpy ndarray. required window int The window constraint, by default no constraint. 0 penalty float The misalign penalty, by default zero. 0 Returns: Type Description tuple A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Exceptions: Type Description ValueError If the input series have incompatible dimensions. Source code in code_fmkit/fmsignal.py def dtw_c ( series_1 , series_2 , window = 0 , penalty = 0 ): \"\"\"Python wrapper of the Dynamic Time Warping (DTW) implemented in C. **SEE**: [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) **SEE**: The \"fmkit_cutils\" package in this project has the implementation. **NOTE**: This is a Python wrapper of the C implementation, which is relative fast compared to the pure Python implementation. **NOTE**: The input series must have \"dtype == np.float32\". Args: series_1 (ndarray): The first array, n-by-d numpy ndarray. series_2 (ndarray): The second array, m-by-d numpy ndarray. window (int, optional): The window constraint, by default no constraint. penalty (float, optional): The misalign penalty, by default zero. Returns: tuple: A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Raises: ValueError: If the input series have incompatible dimensions. \"\"\" if not isinstance ( series_1 , np . ndarray ) \\ or not isinstance ( series_2 , np . ndarray ) \\ or len ( series_1 . shape ) != 2 or len ( series_2 . shape ) != 2 : raise ValueError ( 'Input series must be l-by-d NumPy ndarrays!' ) n = series_1 . shape [ 0 ] m = series_2 . shape [ 0 ] d1 = series_1 . shape [ 1 ] d2 = series_2 . shape [ 1 ] if d1 != d2 : raise ValueError ( 'Input series must have the same dimension!' ) if series_1 . dtype != np . float32 or series_2 . dtype != np . float32 : raise ValueError ( 'Input series must have \"dtype == np.float32\"!' ) if window <= 0 : window = m * 2 # print('begin dtw_c()') # NOTE: It may be problematic to manage the memory and Python object # life-cycle in C code, and hence, we allocate space here in the wrapper. dist_matrix = np . zeros (( n + 1 , m + 1 ), np . float32 ) direction = np . zeros (( n + 1 , m + 1 ), np . int32 ) # These are the index mapping to align series_2 to series_1. a2to1_start = np . zeros ( n , np . int32 ) a2to1_end = np . zeros ( n , np . int32 ) # These are the index mapping to align series_1 to series_2. a1to2_start = np . zeros ( m , np . int32 ) a1to2_end = np . zeros ( m , np . int32 ) series_2to1 = np . zeros ( series_1 . shape , np . float32 ) # Initialization. dist_matrix . fill ( 1e6 ) dist = fmkit_utilities . dtw_c ( series_1 , series_2 , series_1 . shape [ 1 ], n , m , window , penalty , dist_matrix , direction , a2to1_start , a2to1_end , a1to2_start , a1to2_end , series_2to1 , ) # print('end dtw_c()') return dist , dist_matrix [ 1 :, 1 :], direction , \\ a2to1_start , a2to1_end , a1to2_start , a1to2_end , series_2to1 normalize_warping_path_a2to1 ( a2to1_start , a2to1_end , n = 100 ) Normalize the warping path from l2-by-l1 to n-by-n. Parameters: Name Type Description Default a2to1_start ndarray The alignment starting indices from 2 to 1. required a2to1_end ndarray The alignment ending indices from 2 to 1. required n int The size of the warping path after normalization. 100 Returns: Type Description (ndarray) The \"a2to1_start\" after normalization. (ndarray): The \"a2to1_end\" after normalization. Exceptions: Type Description ValueError If the input arrays have wrong type or value. Source code in code_fmkit/fmsignal.py def normalize_warping_path_a2to1 ( a2to1_start , a2to1_end , n = 100 ): \"\"\"Normalize the warping path from l2-by-l1 to n-by-n. Args: a2to1_start (ndarray): The alignment starting indices from 2 to 1. a2to1_end (ndarray): The alignment ending indices from 2 to 1. n (int): The size of the warping path after normalization. Returns: (ndarray): The \"a2to1_start\" after normalization. (ndarray): The \"a2to1_end\" after normalization. Raises: ValueError: If the input arrays have wrong type or value. \"\"\" if not isinstance ( a2to1_start , np . ndarray ) \\ or not isinstance ( a2to1_end , np . ndarray ) \\ or len ( a2to1_start . shape ) != 1 or len ( a2to1_end . shape ) != 1 \\ or a2to1_start . dtype != np . int or a2to1_end . dtype != np . int : raise ValueError ( 'Input series must be two 1D NumPy arrays!' ) assert a2to1_start . shape [ 0 ] == a2to1_end . shape [ 0 ] assert np . all (( a2to1_end - a2to1_start ) >= 0 ) assert n > 0 l1 = a2to1_start . shape [ 0 ] l2 = a2to1_end [ - 1 ] xp = np . arange ( l1 ) x_n = np . linspace ( 0 , l1 - 1 , n ) a2to1_start_n = np . interp ( x_n , xp , a2to1_start ) a2to1_start_n = a2to1_start_n / l2 * ( n - 1 ) a2to1_end_n = np . interp ( x_n , xp , a2to1_end ) a2to1_end_n = a2to1_end_n / l2 * ( n - 1 ) return a2to1_start_n . astype ( np . int32 ), a2to1_end_n . astype ( np . int32 ) warping_path_to_xy_sequences ( a2to1_start , a2to1_end ) Convert the warping path from alignment indices to xy coordinates. Parameters: Name Type Description Default a2to1_start ndarray The alignment starting indices from 2 to 1. required a2to1_end ndarray The alignment ending indices from 2 to 1. required Returns: Type Description (list) The x coordinates. (list): The y coordinates. Exceptions: Type Description ValueError If the input arrays have wrong type or value. Source code in code_fmkit/fmsignal.py def warping_path_to_xy_sequences ( a2to1_start , a2to1_end ): \"\"\"Convert the warping path from alignment indices to xy coordinates. Args: a2to1_start (ndarray): The alignment starting indices from 2 to 1. a2to1_end (ndarray): The alignment ending indices from 2 to 1. Returns: (list): The x coordinates. (list): The y coordinates. Raises: ValueError: If the input arrays have wrong type or value. \"\"\" if not isinstance ( a2to1_start , np . ndarray ) \\ or not isinstance ( a2to1_end , np . ndarray ) \\ or len ( a2to1_start . shape ) != 1 or len ( a2to1_end . shape ) != 1 \\ or a2to1_start . dtype != np . int or a2to1_end . dtype != np . int : raise ValueError ( 'Input series must be two 1D NumPy arrays!' ) assert a2to1_start . shape [ 0 ] == a2to1_end . shape [ 0 ] assert np . all (( a2to1_end - a2to1_start ) >= 0 ) xs = [] ys = [] for i , ( start , end ) in enumerate ( zip ( a2to1_start , a2to1_end )): for j in range ( start , end + 1 ): xs . append ( i ) ys . append ( j ) #print(i, j, start, end) return xs , ys","title":"fmsignal"},{"location":"fmsignal-reference/#fmsignal-module","text":"","title":"fmsignal module"},{"location":"fmsignal-reference/#fmsignal","text":"This module is the core of the fmkit framework, which is designed to facilitate researches on in-air-handwriting related research. Author: Duo Lu < duolu.cs@gmail.com > Version: 0.1 License: MIT Updated on Feb. 7, 2020, version 0.1 Created on Aug 14, 2017, draft The MIT License Copyright 2017-2021 Duo Lu < duolu.cs@gmail.com > Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"fmsignal"},{"location":"fmsignal-reference/#fmsignal.FMSignal","text":"3D finger motion signal (after preprocessing, device agnostic). This is the data structure for a finger motion signal. The signal is a time series containing samples of physical states of one point on a hand, captured by a 3D camera device or a wearable data glove device. This is the class the abstracts the signal data structure after preprocessing, and it is device agnostic. Attributes: Name Type Description length int length of the time series (i.e., number of samples). dim int dimension of each sample (i.e., number of sensor axes). ts ndarray timestamps of each sample, in a len dimensional vector. data ndarray the actual time series data, in a len * dim matrix. user str the user who creates this signal. cid str the unique id indicating the content of the signal. seq int the sequence id in a set when loaded from a dataset. NOTE : There are several ways to create an FMSignal object. (1) Preprocess a raw signal, i.e., \"raw_signal.preprocess()\". (2) Load data from a file with the class method \"construct_from_file()\". (3) Deep copy from an existing FMSignal object, i.e., \"signal.copy()\". (4) Align to a template or another signal to generate an aligned signal, i.e., \"signal.align_to(another_signal)\" (5) Modify an existing FMSignal object to generate a new signal, which is basically only used for data agumentation. It is not recommended to directly construct an FMSignal object using its constructor since the attributes may be inconsistent. Instead, please only use those previously mentioned methods to create an FMSignal object. NOTE : Timestamp is always in ms and frequency is always in Hz. NOTE : \"ts\" and \"data\" both have \"dtype == np.float32\". Currently, a signal has the following 18 sensor axes, i.e., \"dim\" is 18, and the \"data\" field has the shape of (len, 18). axes description 0-2 position in x-y-z 3-5 speed in x-y-z, currently just the derivative of the position 6-8 acceleration in x-y-z, currently just the derivative of speed 9-11 orientation, i.e., the x, y, z components of the quaternion 12-14 angular speed, currently just the derivative of the orientation 15-17 angular acceleration, just the derivative of the angular speed A signal may also have the following optional attributes. attributes description len_origin The length before alignment (only for aligned signals). dist DTW alignment distant (only for aligned signals). a2to1_start Alignment index start array (only for aligned signals). a2to1_end Alignment index end array (only for aligned signals). NOTE : \"user\", \"cid\", and \"seq\" are only needed to print information for debugging. Use the class \"FMSignalDesc\" to obtain the meta data of the signal for more details. Typically, the signal file is named as \"user_cid_seq.txt\" (or \".csv\", or \".npy\"). For example, given a file \"duolu_duolu_01.txt\", the \"user\" label is \"duolu\", the \"cid\" label is also \"duolu\", indicating the content is about writing the string \"duolu\", and the \"seq\" is 1, indicating the repetition #1. Usually, for privacy issues, \"user\" label and \"cid\" label are anonymous strings since they only need to be distinctive instead of meaningful. For example, \"user00_id00_01.txt\" means the \"user\" label is \"user00\", the \"id\" label is \"id00\", and the seq is 1. NOTE : The raw signal file may have two different formats, i.e., either in Comma Separated Value (\".csv\") or in NumPy binary format (\".npy\"). However, the content structure is the same, which is essentially a matrix, where the rows are the samples at a certain time and the columns are the data from a specific sensor axis. See the \"Data Format Details\" document for more information.","title":"FMSignal"},{"location":"fmsignal-reference/#fmsignal.FMSignal.__init__","text":"Constructor. See the class attributes for the meaning of the arguments. NOTE : This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal, or use the \"align_to()\" method to obtain an aligned signal. Source code in code_fmkit/fmsignal.py def __init__ ( self , length = 0 , dim = 0 , ts = None , data = None , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the class attributes for the meaning of the arguments. **NOTE**: This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal, or use the \"align_to()\" method to obtain an aligned signal. \"\"\" self . length = length self . dim = dim self . ts = ts self . data = data self . user = user self . cid = cid self . seq = seq","title":"__init__()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.__str__","text":"Convert the meta info of the signal to a human readable string. Currently, the string is \"user_cid_seq\". Parameters: Name Type Description Default None None No arguments. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def __str__ ( self ): \"\"\"Convert the meta info of the signal to a human readable string. Currently, the string is \"user_cid_seq\". Args: None (None): No arguments. Returns: None: No return value. \"\"\" return \" %s _ %s _ %d \" % ( self . user , self . cid , self . seq )","title":"__str__()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.align_to","text":"Get another signal by aligning the signal to a template signal. NOTE : The alignment is done using Dynamic Time Warping (DTW). Parameters: Name Type Description Default template FMSignal The template signal. required window int The DTW alignment window. 0 penalty int The DTW element-wise missalign penalty. 0 method string Implementation method, either \"c\" or \"python\". 'c' keep_dist_matrix bool Indicating whether to keep the DTW result, i.e., the \"dist_matrix\". False Returns: Type Description FMSignal The constructed signal object. Source code in code_fmkit/fmsignal.py def align_to ( self , template , window = 0 , penalty = 0 , method = DTW_METHOD , keep_dist_matrix = False ): \"\"\"Get another signal by aligning the signal to a template signal. **NOTE**: The alignment is done using Dynamic Time Warping (DTW). Args: template (FMSignal): The template signal. window (int): The DTW alignment window. penalty (int): The DTW element-wise missalign penalty. method (string): Implementation method, either \"c\" or \"python\". keep_dist_matrix (bool): Indicating whether to keep the DTW result, i.e., the \"dist_matrix\". Returns: FMSignal: The constructed signal object. \"\"\" length_new = template . length ts_new = template . ts . copy () #print(template.data.shape) #print(self.data.shape) if method == \"python\" : tup = dtw ( template . data , self . data , window , penalty ) elif method == \"c\" : tup = dtw_c ( template . data , self . data , window , penalty ) else : raise ValueError ( \"Unkown DTW implementation method ( %s )!\" % method ) ( _dist , matrix , _d , a2to1_start , a2to1_end , _s , _e , data_new ) = tup signal = FMSignal ( length_new , self . dim , ts_new , data_new , self . user , self . cid , self . seq ) signal . len_origin = self . length signal . a2to1_start = a2to1_start signal . a2to1_end = a2to1_end if keep_dist_matrix : signal . dist_matrix = matrix return signal","title":"align_to()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.all_close_to","text":"Check whether this signal is almost identical to another signal. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Parameters: Name Type Description Default signal FMSignal The other signal to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , signal ): \"\"\"Check whether this signal is almost identical to another signal. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Args: signal (FMSignal): The other signal to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( signal , FMSignal ): return False if self . length != signal . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , signal . ts , atol = 1e-6 ) r2 = np . allclose ( self . data , signal . data , atol = 1e-6 ) return r1 and r2","title":"all_close_to()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.amplitude_normalize","text":"Normalize the amplitude of each sensor axes. NOTE : The ratios of x-y-z axes of one type, e.g., position, acc, etc., are not perserved. Parameters: Name Type Description Default None None No argument. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def amplitude_normalize ( self ): \"\"\"Normalize the amplitude of each sensor axes. **NOTE**: The ratios of x-y-z axes of one type, e.g., position, acc, etc., are not perserved. Args: None (None): No argument. Returns: None: No return value. \"\"\" data = self . data mean = np . mean ( data , axis = 0 ) std = np . std ( data , axis = 0 ) for j in range ( self . dim ): data [:, j ] = np . divide ( data [:, j ] - mean [ j ], std [ j ])","title":"amplitude_normalize()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.construct_from_file","text":"Construct a signal by loading data from a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format (currently either \"csv\" or \"npy\"). required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignal The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is unknown. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Construct a signal by loading data from a file. Args: fn (string): The file name (without extension). mode (string): The file format (currently either \"csv\" or \"npy\"). user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignal: The constructed signal object. Raises: ValueError: If the \"mode\" is unknown. FileNotFoundError: If the file does not exist. \"\"\" signal = FMSignal ( 0 , 0 , None , None ) signal . load_from_file ( fn , mode ) signal . user = user signal . cid = cid signal . seq = seq return signal","title":"construct_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.copy","text":"Deep copy of the signal. Parameters: Name Type Description Default None None No arguments. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def copy ( self ): \"\"\"Deep copy of the signal. Args: None (None): No arguments. Returns: None: No return value. \"\"\" signal = FMSignal ( self . length , self . dim , self . data . copy (), self . ts . copy (), self . user , self . cid , self . seq ) return signal","title":"copy()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.distance_to","text":"Calculate the element-wise absolute distance of two signals. NOTE : The other signal must be already aligned to this signal, or their lengths must be the same. Parameters: Name Type Description Default other FMSignal The other signal. required Returns: Type Description ndarray An array of the absolute difference of the two signals. Exceptions: Type Description ValueError If their lengths are different. Source code in code_fmkit/fmsignal.py def distance_to ( self , other ): \"\"\"Calculate the element-wise absolute distance of two signals. **NOTE**: The other signal must be already aligned to this signal, or their lengths must be the same. Args: other (FMSignal): The other signal. Returns: ndarray: An array of the absolute difference of the two signals. Raises: ValueError: If their lengths are different. \"\"\" if self . length != other . length : raise ValueError ( \"Incompatible signal lengths %d and %d .\" % ( self . length , other . length )) return np . absolute ( self . data - other . data )","title":"distance_to()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.filter","text":"Low-pass filtering on the signal (in place). NOTE : It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. NOTE : This method use NumPy FFT and IFFT. It modifies the signal. Parameters: Name Type Description Default sample_freq float sample frequency of this signal. required cut_freq float low pass filtering cutoff frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def filter ( self , sample_freq , cut_freq ): \"\"\"Low-pass filtering on the signal (in place). **NOTE**: It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. **NOTE**: This method use NumPy FFT and IFFT. It modifies the signal. Args: sample_freq (float): sample frequency of this signal. cut_freq (float): low pass filtering cutoff frequency. Returns: None: No return value. \"\"\" l = self . length data = self . data cut_l = int ( cut_freq * l / sample_freq ) dft_co = np . fft . fft ( data , l , axis = 0 ) for i in range ( cut_l , l - cut_l ): dft_co [ i ] = 0 + 0 j ifft_c = np . fft . ifft ( dft_co , l , axis = 0 ) ifft = ifft_c . astype ( np . float32 ) for i in range ( l ): self . data [ i ] = ifft [ i ]","title":"filter()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.get_orientation","text":"Obtain orientation as a series of rotation matrices and quaternions. Parameters: Name Type Description Default None None No argument. required Returns: Type Description tuple A tuple of the following representing the orientation. ndarray: The rotation matrices (l-by-3-by-3). list: The unit quaternions. Source code in code_fmkit/fmsignal.py def get_orientation ( self ): \"\"\"Obtain orientation as a series of rotation matrices and quaternions. Args: None (None): No argument. Returns: tuple: A tuple of the following representing the orientation. ndarray: The rotation matrices (l-by-3-by-3). list: The unit quaternions. \"\"\" l = self . length data = self . data rotms = np . zeros (( l , 3 , 3 )) qs = [ None ] * l for i in range ( l ): qx = data [ i , 9 ] qy = data [ i , 10 ] qz = data [ i , 11 ] qw = math . sqrt ( 1 - qx * qx - qy * qy - qz * qz ) q = Quaternion ( qw , qx , qy , qz ) qs [ i ] = q rotms [ i ] = q . to_rotation_matrix () return rotms , qs","title":"get_orientation()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.load_alignment_index","text":"Load the alignment indicies from a NumPy binary file (.npy). NOTE : The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None no return value. Exceptions: Type Description ValueError If the \"mode\" is unknown. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py def load_alignment_index ( self , fn , mode ): \"\"\"Load the alignment indicies from a NumPy binary file (.npy). **NOTE**: The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: no return value. Raises: ValueError: If the \"mode\" is unknown. FileNotFoundError: If the file does not exist. \"\"\" if mode == \"csv\" : fn += \".csv\" array = np . loadtxt ( fn , dtype = np . int32 , delimiter = \",\" ) elif mode == \"npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . int32 else : raise ValueError ( \"Unknown mode: \" + mode ) self . a2to1_start = array [:, 0 ] self . a2to1_end = array [:, 1 ] self . length_origin = self . a2to1_end [ - 1 ]","title":"load_alignment_index()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.load_from_file","text":"Load the signal from a file. NOTE : This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"Load the signal from a file. **NOTE**: This is only for internal usage. If an FMSignal object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"csv\" : fn += \".csv\" array = np . loadtxt ( fn , dtype = np . float32 , delimiter = \",\" ) elif mode == \"npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 else : raise ValueError ( \"Unknown mode: \" + mode ) # NOTE: These \"copy()\" force the \"ts\" and \"data\" to have proper C-like # array in memory, which is crucial for \"dtw_c()\"!!! ts = array [:, 0 : 1 ] . copy () data = array [:, 1 :] . copy () length = data . shape [ 0 ] dim = data . shape [ 1 ] self . length = length self . dim = dim self . ts = ts self . data = data","title":"load_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.pertube_amplitude","text":"Pertube the signal at the specified time. NOTE : This method is used in data augmentation. It adds a Gaussian shape pertubation signal segment to the original signal. This method changes the signal. Parameters: Name Type Description Default axis int The specified axis to pertube. required time int The specified time to pertube. required s_window int The pertubation smooth window size (greater than 0). required scale float The scale factor of the pertubation (pos or neg). required sigma float The standard deviation of the Gaussian pertubation. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def pertube_amplitude ( self , axis , time , s_window , scale , sigma ): \"\"\"Pertube the signal at the specified time. **NOTE**: This method is used in data augmentation. It adds a Gaussian shape pertubation signal segment to the original signal. This method changes the signal. Args: axis (int): The specified axis to pertube. time (int): The specified time to pertube. s_window (int): The pertubation smooth window size (greater than 0). scale (float): The scale factor of the pertubation (pos or neg). sigma (float): The standard deviation of the Gaussian pertubation. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" l = self . length if axis < 0 or axis >= self . dim : raise ValueError ( 'Bad input axis ( %d )' % axis ) if s_window <= 0 or time < 0 or time >= l : raise ValueError ( 'Bad input time ( %d )' % time ) pertubation = scipy . signal . gaussian ( s_window * 2 , sigma ) * scale # Calculate the start indices. s_data = time - s_window s_pertube = 0 if s_data < 0 : s_pertube = - s_data s_data = 0 # Calculate the end indices. e_data = s_data + s_window * 2 e_pertube = s_window if e_data > l : e_pertube -= e_data - l e_data = l self . data [ s_data : e_data , axis ] += pertubation [ s_pertube : e_pertube ]","title":"pertube_amplitude()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.pertube_amplitude_seg","text":"Pertube the signal at a specified time for a segment. NOTE : This method is used in data augmentation. It adds a flat pertubation signal segment to the original signal with Gaussian smooth edges on both sides. This method changes the signal. Parameters: Name Type Description Default axis int The specified axis to pertube. required time int The specified time to pertube. required window int The pertubation window size (greater than 0). required s_window int The pertubation smooth window size (greater than 0). required scale float The scale factor of the pertubation (pos or neg). required sigma float The standard deviation of the Gaussian pertubation. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def pertube_amplitude_seg ( self , axis , time , window , s_window , scale , sigma ): \"\"\"Pertube the signal at a specified time for a segment. **NOTE**: This method is used in data augmentation. It adds a flat pertubation signal segment to the original signal with Gaussian smooth edges on both sides. This method changes the signal. Args: axis (int): The specified axis to pertube. time (int): The specified time to pertube. window (int): The pertubation window size (greater than 0). s_window (int): The pertubation smooth window size (greater than 0). scale (float): The scale factor of the pertubation (pos or neg). sigma (float): The standard deviation of the Gaussian pertubation. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" l = self . length if axis < 0 or axis >= self . dim : raise ValueError ( 'Bad input axis: ' + ' %d ' % axis ) if window <= 0 or s_window <= 0 : raise ValueError ( 'Bad input window ( %d ) or s_window ( %d )' % ( window , s_window )) if time < 0 or time + window >= l : raise ValueError ( 'Bad input time ( %d ) or window ( %d )' % ( time , window )) pertube_size = window + s_window * 2 pertube_seg = np . ones ( pertube_size , dtype = np . float32 ) * scale # NOTE: The peak of this Gaussian series is 1. smooth_edges = scipy . signal . gaussian ( s_window * 2 , sigma ) se_left = smooth_edges [: s_window ] se_right = smooth_edges [ s_window :] pertube_seg [: s_window ] = np . multiply ( pertube_seg [: s_window ], se_left ) pertube_seg [ - s_window :] = np . multiply ( pertube_seg [: s_window ], se_right ) s_data = time - s_window s_pertube = 0 if s_data < 0 : s_pertube = - s_data s_data = 0 e_data = time + window + s_window e_pertube = pertube_size if e_data >= l : e_pertube -= e_data - l e_data = l self . data [ s_data : e_data , axis ] += pertube_seg [ s_pertube : e_pertube ]","title":"pertube_amplitude_seg()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.resize","text":"Resize the signal to the specified new length. NOTE : This method stretches the signal in time by linear interpolation. It is designed for temporal normalization. This method modifies the signal. Parameters: Name Type Description Default length_new int The specified new length. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def resize ( self , length_new ): \"\"\"Resize the signal to the specified new length. **NOTE**: This method stretches the signal in time by linear interpolation. It is designed for temporal normalization. This method modifies the signal. Args: length_new (int): The specified new length. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" if length_new < 0 : raise ValueError ( 'Bad new length ( %d ).' % length_new ) l = self . length d = self . dim data_new = np . zeros (( length_new , d ), np . float32 ) ts_new = np . zeros (( length_new ), np . float32 ) data = self . data ts = self . ts xp = np . linspace ( 0 , l - 1 , num = l ) x = np . linspace ( 0 , l - 1 , num = length_new ) for j in range ( d ): data_new [:, j ] = np . interp ( x , xp , data [:, j ]) ts_new [:] = np . interp ( x , xp , ts ) self . length = length_new self . ts = ts_new self . data = data_new","title":"resize()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.resize_segment","text":"Resize a segment of the signal and keep other parts untouched. NOTE : This method is used in data augmentation. This method changes the signal. Parameters: Name Type Description Default start int The start of the segment to stretch. required window int The stretch window size (greater than 0). required seg_length_new int The specified new segment length. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def resize_segment ( self , start , window , seg_length_new ): \"\"\"Resize a segment of the signal and keep other parts untouched. **NOTE**: This method is used in data augmentation. This method changes the signal. Args: start (int): The start of the segment to stretch. window (int): The stretch window size (greater than 0). seg_length_new (int): The specified new segment length. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" end = start + window if window <= 0 : raise ValueError ( 'Bad window size ( %d ).' % window ) if seg_length_new < 0 : raise ValueError ( 'Bad new segment length ( %d ).' % seg_length_new ) if start < 0 or end >= self . length : raise ValueError ( 'Bad input start ( %d ) or window ( %d ).' % ( start , window )) sample_period = self . ts [ 1 ] - self . ts [ 0 ] l = self . length d = self . dim seg_l = end - start l_new = self . length - seg_l + seg_length_new delta_new = seg_l / seg_length_new seg_start_new = start seg_end_new = seg_start_new + seg_length_new data_new = np . zeros (( l_new , d ), np . float32 ) ts_new = np . zeros (( l_new , 1 ), np . float32 ) data = self . data # TODO: rewrite this with array splice and linear interpolation data_new [ 0 : start ] = data [ 0 : start ] data_new [ seg_end_new : l_new ] = data [ end : l ] for i in range ( seg_length_new ): it = start + i * delta_new ii_old = int ( math . floor ( it )) ii_new = start + i dt = it - ii_old # print(i, delta_new, it, ii) for v in range ( d ): rate = ( data [ ii_old ][ v ] - data [ ii_old ][ v ] if ii_old + 1 < l else data [ ii_old ][ v ] - data [ ii_old - 1 ][ v ] ) data_new [ ii_new ][ v ] = data [ ii_old ][ v ] + rate * dt for i in range ( l_new ): ts_new [ i ] = sample_period * i self . length = l_new self . dim = d self . ts = ts_new self . data = data_new","title":"resize_segment()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.save_alignment_index","text":"Save the alignment indicies to a NumPy binary file (.npy). NOTE : The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Parameters: Name Type Description Default fn string file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_alignment_index ( self , fn , mode ): \"\"\"Save the alignment indicies to a NumPy binary file (.npy). **NOTE**: The alignment indicies are the \"a2to1_start\" and \"a2to1_end\" attributes. Args: fn (string): file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: No return value. \"\"\" l = self . length column_1 = self . a2to1_start . reshape (( l , 1 )) column_2 = self . a2to1_end . reshape (( l , 1 )) array = np . concatenate (( column_1 , column_2 ), axis = 1 ) if mode == \"csv\" : fn += \".csv\" np . savetxt ( fn , array , fmt = \" %d \" , delimiter = \", \" ) elif mode == \"npy\" : # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown mode: \" + mode )","title":"save_alignment_index()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.save_to_file","text":"Save the signal to a file. NOTE : Only six digits after the decimal point are kept when floating point numbers are converted to CSV strings. Parameters: Name Type Description Default fn string file name (without the \".csv\" or \".npy\" extension). required mode string The file format (currently either \"csv\" or \"npy\"). required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"Save the signal to a file. **NOTE**: Only six digits after the decimal point are kept when floating point numbers are converted to CSV strings. Args: fn (string): file name (without the \".csv\" or \".npy\" extension). mode (string): The file format (currently either \"csv\" or \"npy\"). Returns: None: No return value. \"\"\" l = self . length array = np . concatenate (( self . ts . reshape (( l , 1 )), self . data ), axis = 1 ) if mode == \"csv\" : fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"npy\" : assert array . dtype == np . float32 # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown mode: \" + mode )","title":"save_to_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.shift_temporally","text":"Shift the signal in time. NOTE : This method is used in data augmentation. This method modifies the signal. Parameters: Name Type Description Default shift int The specified shift in time. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def shift_temporally ( self , shift ): \"\"\"Shift the signal in time. **NOTE**: This method is used in data augmentation. This method modifies the signal. Args: shift (int): The specified shift in time. Returns: None: No return value. \"\"\" data = self . data l = self . length d = self . dim xp = np . arange ( 0 , l , 1 , dtype = np . float32 ) x = xp + shift data_shift = np . zeros (( l , d ), dtype = np . float32 ) # TODO: Rewrite this using array splice. for j in range ( d ): data_shift [:, j ] = np . interp ( x , xp , data [:, j ]) self . data = data_shift","title":"shift_temporally()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.stretch_axis","text":"Stretch along a certain sensor axis. NOTE : This method is used in data augmentation. This method modifies the signal. Parameters: Name Type Description Default axis int The specified sensor axis to stretch. required scale float The intensity of the stretching. required Returns: Type Description None No return value. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def stretch_axis ( self , axis , scale ): \"\"\"Stretch along a certain sensor axis. **NOTE**: This method is used in data augmentation. This method modifies the signal. Args: axis (int): The specified sensor axis to stretch. scale (float): The intensity of the stretching. Returns: None: No return value. Raises: ValueError: If the input arguments are out of range. \"\"\" if axis < 0 or axis >= self . dim : raise ValueError ( 'Bad axis ( %d ).' % axis ) l = self . length offset_v = ( np . arange ( 0 , l , 1 ) - l / 2 ) * scale self . data [:, axis ] += offset_v","title":"stretch_axis()"},{"location":"fmsignal-reference/#fmsignal.FMSignal.swap_segment","text":"Swap a segment of this signal with another signal. NOTE : This method is used in data augmentation. It generates two new signals, which are the signals after swapping. It is done on all axes. This method does not modify this signal or the other signal. Parameters: Name Type Description Default other FMSignal The other signal. required start int The start of the segment to swap. required window int The pertubation window size (greater than 0). required s_window int The pertubation smooth window size (greater than 0). required Returns: Type Description tuple A tuple containing the following. FMSignal: This signal after swapping. FMSignal: The other signal after swapping. Exceptions: Type Description ValueError If the input arguments are out of range. Source code in code_fmkit/fmsignal.py def swap_segment ( self , other , start , window , s_window ): \"\"\"Swap a segment of this signal with another signal. **NOTE**: This method is used in data augmentation. It generates two new signals, which are the signals after swapping. It is done on all axes. This method does not modify this signal or the other signal. Args: other (FMSignal): The other signal. start (int): The start of the segment to swap. window (int): The pertubation window size (greater than 0). s_window (int): The pertubation smooth window size (greater than 0). Returns: tuple: A tuple containing the following. FMSignal: This signal after swapping. FMSignal: The other signal after swapping. Raises: ValueError: If the input arguments are out of range. \"\"\" end = start + window l_min = min ( self . length , other . length ) if window <= 0 or s_window <= 0 : raise ValueError ( 'Bad input window ( %d ) or s_window ( %d )' % ( window , s_window )) if start < 0 or end >= l_min : raise ValueError ( 'Bad input start ( %d ) or window ( %d )' % ( start , window )) a = self . copy () b = other . copy () data_a = a . data ts_a = a . ts data_b = b . data ts_b = b . ts as1 = data_a [: start , :] as2 = data_a [ start : end , :] as3 = data_a [ end :, :] bs1 = data_b [: start , :] bs2 = data_b [ start : end , :] bs3 = data_b [ end :, :] ats1 = ts_a [: start ] ats2 = ts_a [ start : end ] ats3 = ts_a [ end :] bts1 = ts_b [: start ] bts2 = ts_b [ start : end ] bts3 = ts_b [ end :] data_a_new = np . concatenate ([ as1 , bs2 , as3 ], axis = 0 ) ts_a_new = np . concatenate ([ ats1 , bts2 , ats3 ], axis = 0 ) l_a = data_a_new . shape [ 0 ] data_b_new = np . concatenate ([ bs1 , as2 , bs3 ], axis = 0 ) ts_b_new = np . concatenate ([ bts1 , ats2 , bts3 ], axis = 0 ) l_b = data_b_new . shape [ 0 ] # Smooth the segment edges with linear interpolation. # TODO: Rewrite this using NumPy vectorized operation. if s_window != 0 : # Left margin ml_start = max ( 0 , start - s_window ) ml_end = min ( start + s_window , min ( l_a , l_b )) ml_length = ml_end - ml_start ml_factor = np . linspace ( 1 , 0 , ml_length , endpoint = True , dtype = np . float32 ) # print(margin1_start, margin1_end) for i , ii in zip ( range ( ml_start , ml_end ), range ( ml_length )): data_a_new [ i ] = ml_factor [ ii ] * data_a [ i ] \\ + ( 1 - ml_factor [ ii ]) * data_b [ i ] data_b_new [ i ] = ml_factor [ ii ] * data_b [ i ] \\ + ( 1 - ml_factor [ ii ]) * data_a [ i ] # Right margin mr_start = max ( 0 , end - s_window ) mr_end = min ( end + s_window , min ( l_a , l_b )) mr_length = mr_end - mr_start mr_factor = np . linspace ( 1 , 0 , mr_end - mr_start , endpoint = True , dtype = np . float32 ) # print(margin2_start, margin2_end) for i , ii in zip ( range ( mr_start , mr_end ), range ( mr_length )): data_a_new [ i ] = mr_factor [ ii ] * data_b [ i ] \\ + ( 1 - mr_factor [ ii ]) * data_a [ i ] data_b_new [ i ] = mr_factor [ ii ] * data_a [ i ] \\ + ( 1 - mr_factor [ ii ]) * data_b [ i ] a . data = data_a_new a . ts = ts_a_new a . len = l_a b . data = data_b_new b . ts = ts_b_new b . len = l_b return a , b","title":"swap_segment()"},{"location":"fmsignal-reference/#fmsignal.FMSignalDesc","text":"A descriptor of a set of signals of the same writing content. Typically, these signals are generated by users or imposters writing the same content in multiple repetitions. If the contents are different, they are considered as different set of signals with different descriptors. NOTE : One descriptor object corresponds to one line in the meta file. Attributes: Name Type Description uid int A unique ID that orders all descriptors in a collections. Usually it is the line number of the descriptor in the meta file. user string A label indicating which user generates the signals. cid string A label indicating the content for classification tasks. Note that for spoofing attacks, i.e., different users are asked to write the same content, the signals have the same id_label. This label is used as the account ID for user identification and authentication purpose, and hence it gets the name \"id_label\". device string This indicates which type of device is used to obtain the signals. Currently it is either \"glove\" or \"leap\". start int The start repetition sequence number (inclusive). end int The end repetition sequence number (exclusive). These sequence numbers allow the database to only load a specified section of the data, which is very useful when spliting the dataset into training and testing set or dealing with data augmentation. fn_prefix string File name prefix, typically \"user_cid\". The full file name is \"fn_prefix\" + \"_\" + \"seq\" + \".csv\" or \".npy\", where \"seq\" indicate the specific repetition. content string The actual content that is written.","title":"FMSignalDesc"},{"location":"fmsignal-reference/#fmsignal.FMSignalDesc.__init__","text":"Constructor. See the class attributes for the meaning of the arguments. Source code in code_fmkit/fmsignal.py def __init__ ( self , uid , user , cid , device , start , end , fn_prefix , content ): \"\"\"Constructor. See the class attributes for the meaning of the arguments. \"\"\" self . uid = uid self . user = user self . cid = cid self . device = device self . start = start self . end = end self . fn_prefix = fn_prefix self . content = content","title":"__init__()"},{"location":"fmsignal-reference/#fmsignal.FMSignalDesc.__str__","text":"Convert a descriptor to a human readable string representation. NOTE : Currently it is \"uid \\t user \\t cid \\t device\". Source code in code_fmkit/fmsignal.py def __str__ ( self ): \"\"\"Convert a descriptor to a human readable string representation. **NOTE**: Currently it is \"uid \\\\t user \\\\t cid \\\\t device\". \"\"\" return \" %8d \\t %20s \\t %20s \\t %8s \\t \" % ( self . uid , self . user , self . cid , self . device , )","title":"__str__()"},{"location":"fmsignal-reference/#fmsignal.FMSignalDesc.construct_from_meta_file","text":"Factory method to build list of FMSignalDesc from a metadata file. Parameters: Name Type Description Default meta_fn string The metadata file name. required Returns: Type Description list a list of descriptor objects. NOTE : The meta file contains a table with the following structure, (columns are seperated by commas): column type content 0 int uid 1 string user 2 string cid 3 string device 4 int start repetition sequence number 5 int end repetition sequence number 6 string file name prefix 7 string content Typically, the file name prefix field is just \"user_label_id_label\". See the \"data_example\" and \"meta_example\" folders for examples. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_meta_file ( cls , meta_fn ): \"\"\"Factory method to build list of FMSignalDesc from a metadata file. Args: meta_fn (string): The metadata file name. Returns: list: a list of descriptor objects. **NOTE**: The meta file contains a table with the following structure, (columns are seperated by commas): column | type | content -------|---------|-------------- 0 | int | uid 1 | string | user 2 | string | cid 3 | string | device 4 | int | start repetition sequence number 5 | int | end repetition sequence number 6 | string | file name prefix 7 | string | content Typically, the file name prefix field is just \"user_label_id_label\". See the \"data_example\" and \"meta_example\" folders for examples. \"\"\" descs = [] with open ( meta_fn , \"r\" ) as meta_fd : reader = csv . reader ( meta_fd ) for row in reader : if len ( row ) == 0 : continue if row [ 0 ] . startswith ( \"#\" ): continue strs = [] for column in row : strs . append ( column . lstrip () . rstrip ()) desc = cls ( int ( strs [ 0 ]), strs [ 1 ], strs [ 2 ], strs [ 3 ], int ( strs [ 4 ]), int ( strs [ 5 ]), strs [ 6 ], strs [ 7 ], ) descs . append ( desc ) return descs","title":"construct_from_meta_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove","text":"Raw finger motion signal collected by the data glove. This class represents the raw signal obtained from the data glove. The glove uses two BNO055 Inertial Measurement Units (IMU), one on the tip of the index finger and the other on the tip of the thumb. Attributes: Name Type Description length int The number of samples in this signal. ts ndarray Timestamp obtained from the device (1D vector). tsc ndarray Timestamp obtained from the client computer (1D vector). acc0 ndarray The linear acceleration obtained from the first IMU. gyro0 ndarray The angular speed obtained from the first IMU. gravity0 ndarray The gravity vector obtained from the first IMU. acc1 ndarray The linear acceleration obtained from the second IMU. gyro1 ndarray The angular speed obtained from the second IMU. gravity1 ndarray The gravity vector obtained from the second IMU. data ndarray The data after preprocessing. rotms ndarray The orientation of each smple in rotation matrices. qs list The orientation of each smple in unit quaternions. trajectory ndarray The motion trajectory of the selected IMU. NOTE : The raw sensor data such as \"acc0\" is a length * 3 matrix. NOTE : \"data\", \"rotms\", \"qs\", and \"trajectory\" are only available after preprocessing. Since a preprocessed signal (i.e., FMSignal object) contains the motion of only one point, in the preprocessing procedure, one IMU must be selected (i.e., by the \"point\" argument of \"preprocess()\"). The \"rotms\" is a length * 3 * 3 tensor. The \"qs\" is a list of Quaternion objects from the \"pyrotation\" module. The \"trajectory\" is a length * 3 matrix. NOTE : Although the BNO055 IMU can provide absolute orientation fused by the accelerometer, gyroscope. Additionally, it can provide linear acceleration with gravity removed. In our case, The IMU is set to NDOF mode (default mode, see BNO055 datasheet section 3.3). We use the linear acceleration but not the absolute orientation. Instead, we use a simple method to derive the orientation by integrating the angular speed. Since the signal usually has only a few seconds, this simple method is good enough. The raw file contains additional columns. See the \"Data Format Details\" document for more information. NOTE : The raw signal file may have two different formats, i.e., either in Comma Separated Value (\".csv\") or in NumPy binary format (\".npy\"). However, the content structure is the same, which is essentially a matrix, where the rows are the samples at a certain time and the columns are the data from a specific sensor axis. See the \"Data Format Details\" document for more information. There is another format called \"raw_internal\", which is used to resolve format issues in the data collected at the early stage of this project. It is now obsolete.","title":"FMSignalGlove"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.__init__","text":"Constructor. See the attributes of FMSignal for the meaning of the arguments. NOTE : This is only for internal usage. If an FMSignalGlove object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. Source code in code_fmkit/fmsignal.py def __init__ ( self , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the attributes of FMSignal for the meaning of the arguments. **NOTE**: This is only for internal usage. If an FMSignalGlove object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. \"\"\" self . user = user self . cid = cid self . seq = seq self . length = 0 self . ts = None self . tsc = None self . acc0 = None self . gyro0 = None self . gravity0 = None self . acc1 = None self . gyro1 = None self . gravity1 = None self . data = None self . qs = None self . rotms = None self . trajectory = None","title":"__init__()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.all_close_to","text":"Check whether this signal is almost identical to the other signal. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Parameters: Name Type Description Default signal FMSignalGlove The other signal to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , signal ): \"\"\"Check whether this signal is almost identical to the other signal. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Args: signal (FMSignalGlove): The other signal to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( signal , FMSignalGlove ): return False if self . length != signal . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , signal . ts , atol = 1e-6 ) r2 = np . allclose ( self . tsc , signal . tsc , atol = 1e-6 ) r3 = np . allclose ( self . acc0 , signal . acc0 , atol = 1e-6 ) r4 = np . allclose ( self . gyro0 , signal . gyro0 , atol = 1e-6 ) r5 = np . allclose ( self . gravity0 , signal . gravity0 , atol = 1e-6 ) r6 = np . allclose ( self . acc1 , signal . acc1 , atol = 1e-6 ) r7 = np . allclose ( self . gyro1 , signal . gyro1 , atol = 1e-6 ) r8 = np . allclose ( self . gravity1 , signal . gravity1 , atol = 1e-6 ) return r1 and r2 and r3 and r4 and r5 and r6 and r7 and r8","title":"all_close_to()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.construct_from_file","text":"Construct a signal by loading data from a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignalGlove The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is wrong. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Construct a signal by loading data from a file. Args: fn (string): The file name (without extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignalGlove: The constructed signal object. Raises: ValueError: If the \"mode\" is wrong. FileNotFoundError: If the file does not exist. \"\"\" signal = cls ( user , cid , seq ) signal . load_from_file ( fn , mode ) return signal","title":"construct_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.convert_axes_to_standard_glove","text":"Convert a set of xyz data series to the standard glove axes. Parameters: Name Type Description Default axes ndarray The original data series. required Returns: Type Description None No return value. NOTE : This method is designed to handle \"raw_internal\" signals only. Source code in code_fmkit/fmsignal.py def convert_axes_to_standard_glove ( self , axes ): \"\"\"Convert a set of xyz data series to the standard glove axes. Args: axes (ndarray): The original data series. Returns: None: No return value. **NOTE**: This method is designed to handle \"raw_internal\" signals only. \"\"\" n = axes . shape [ 0 ] temp = np . zeros (( n , 1 ), np . float32 ) # x <= -y', y <= x' # (x, y) is standard glove. (x', y') is glove2 or glove3. temp [:, 0 ] = axes [:, 0 ] axes [:, 0 ] = - axes [:, 1 ] axes [:, 1 ] = temp [:, 0 ]","title":"convert_axes_to_standard_glove()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.convert_to_standard_glove","text":"Convert raw data columns to standard glove reference frame. Parameters: Name Type Description Default none None No arguments. required Returns: Type Description None No return value. NOTE : This method is designed to handle \"raw_internal\" signals only. Source code in code_fmkit/fmsignal.py def convert_to_standard_glove ( self ): \"\"\"Convert raw data columns to standard glove reference frame. Args: none (None): No arguments. Returns: None: No return value. **NOTE**: This method is designed to handle \"raw_internal\" signals only. \"\"\" self . convert_axes_to_standard_glove ( self . acc0 ) self . convert_axes_to_standard_glove ( self . gyro0 ) self . convert_axes_to_standard_glove ( self . gravity0 ) self . convert_axes_to_standard_glove ( self . acc1 ) self . convert_axes_to_standard_glove ( self . gyro1 ) self . convert_axes_to_standard_glove ( self . gravity1 )","title":"convert_to_standard_glove()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.estimate_angular_states","text":"Estimate orientation, angular speed, and angular acceleration. NOTE : Orientations are represented as the qx, qy, and qz components of a unit quaternion. For the data glove device, the angular speed is directly obtained from the sensor, and the angular po NOTE : Currently the beginning of the signal is used as the initial pose and the integration goes through the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def estimate_angular_states ( self , point ): \"\"\"Estimate orientation, angular speed, and angular acceleration. **NOTE**: Orientations are represented as the qx, qy, and qz components of a unit quaternion. For the data glove device, the angular speed is directly obtained from the sensor, and the angular po **NOTE**: Currently the beginning of the signal is used as the initial pose and the integration goes through the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". Returns: None: No return value. \"\"\" data = self . data l = self . length if point == \"tip\" : gyro = self . gyro0 elif point == \"center\" : gyro = self . gyro1 else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) q = Quaternion . identity () # rotation matrix of each data sample rotms = np . zeros (( l , 3 , 3 )) # quaternion of each data sample qs = [ None ] * l # Given 50 Hz, one timestep is 20 ms, i.e., 0.02 second timestep = 0.02 for i in range ( 0 , l ): qs [ i ] = q rotm = q . to_rotation_matrix () rotms [ i ] = rotm data [ i , 9 ] = q . x data [ i , 10 ] = q . y data [ i , 11 ] = q . z # z, y, x = rotation_matrix_to_euler_angles_zyx(rotm) # yaw, pitch, roll, gimbal_lock \\ # = rotation_matrix_to_euler_angles_zyx(rotm) # data[i, 9] = roll # data[i, 10] = pitch # data[i, 11] = yaw # assert not gimbal_lock # NOTE: Gyro output is in rad/s omega = gyro [ i ] q = Quaternion . integrate_local ( q , omega , timestep ) q . normalize () data [:, 12 : 15 ] = gyro data [:, 15 ] = np . gradient ( data [:, 12 ]) data [:, 16 ] = np . gradient ( data [:, 13 ]) data [:, 17 ] = np . gradient ( data [:, 14 ]) self . data = data self . rotms = rotms self . qs = qs","title":"estimate_angular_states()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.estimate_linear_states","text":"Estimate position, velocity and acceleration. NOTE : For the data glove device, the linear acceleration is directly obtained from the sensor. The position and velocity are derived by integrating the linear acceleration. NOTE : This method depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" Source code in code_fmkit/fmsignal.py def estimate_linear_states ( self , point , wv = 0.2 , wp = 5 ): \"\"\"Estimate position, velocity and acceleration. **NOTE**: For the data glove device, the linear acceleration is directly obtained from the sensor. The position and velocity are derived by integrating the linear acceleration. **NOTE**: This method depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" \"\"\" data = self . data l = self . length if point == \"tip\" : acc = self . acc0 elif point == \"center\" : acc = self . acc1 else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) trajectory = np . zeros (( l , 3 )) qs = self . qs # given 50 Hz, one timestep is 20 ms, i.e., 0.02 second timestep = 0.02 # dead reckoning using linear acceleration p = np . array (( 0 , 0 , 0 )) v_m = np . array (( 0 , 0 , 0 )) a_m = np . array (( 0 , 0 , 0 )) pp = np . array (( 200 , 0 , 0 )) for i in range ( 1 , l ): acc_local = acc [ i ] q = qs [ i ] a_m = q . rotate_a_point ( acc_local ) . reshape ( 3 ) pp_i = q . rotate_a_point ( pp ) . reshape ( 3 ) trajectory [ i , 0 : 3 ] = pp_i v_m = v_m + a_m * timestep # Now we add a correction term u = np . multiply ( v_m , np . abs ( v_m )) v_m = v_m - wv * u p = p + v_m * timestep + 0.5 * a_m * timestep * timestep #print(p) # Now we add a similar correction term. w = np . multiply ( p , np . abs ( p )) p = p - wp * w data [ i , 6 : 9 ] = a_m data [ i , 3 : 6 ] = v_m data [ i , 0 : 3 ] = p * 1000 # position is in mm trajectory [:, 0 ] -= 200 self . trajectory = trajectory","title":"estimate_linear_states()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.filter","text":"Low-pass filtering on the signal. NOTE : It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default sample_freq float sample frequency of this signal. required cut_freq float low pass filtering cutoff frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def filter ( self , sample_freq , cut_freq ): \"\"\"Low-pass filtering on the signal. **NOTE**: It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: sample_freq (float): sample frequency of this signal. cut_freq (float): low pass filtering cutoff frequency. Returns: None: No return value. \"\"\" l = self . length data = self . data cut_l = int ( cut_freq * l / sample_freq ) dft_co = np . fft . fft ( data , l , axis = 0 ) for i in range ( cut_l , l - cut_l ): dft_co [ i ] = 0 + 0 j ifft_c = np . fft . ifft ( dft_co , l , axis = 0 ) # NOTE: This must be converted to \"np.float32\"! ifft = ifft_c . real . astype ( np . float32 ) for i in range ( l ): self . data [ i ] = ifft [ i ]","title":"filter()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.load_from_buffer_raw","text":"Load data from a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default array ndarray The buffer. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw ( self , array ): \"\"\"Load data from a NumPy ndarray. **NOTE**: This is only for internal usage. Args: array (ndarray): The buffer. Returns: None: No return value. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] assert m == 20 , \"Wrong raw file format: m = %d \" % m self . length = l self . tsc = array [:, 0 ] . flatten () self . ts = array [:, 1 ] . flatten () self . acc0 = array [:, 2 : 5 ] self . gyro0 = array [:, 5 : 8 ] self . gravity0 = array [:, 8 : 11 ] self . acc1 = array [:, 11 : 14 ] self . gyro1 = array [:, 14 : 17 ] self . gravity1 = array [:, 17 : 20 ]","title":"load_from_buffer_raw()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.load_from_buffer_raw_internal","text":"Load from a file directly obtained by the data collection client. Parameters: Name Type Description Default array ndarray The buffer, which is a numpy ndarrary. required Returns: Type Description None No return value. CAUTION: Do not use this method directly. Instead, uses the class method FMSignalGlove.construct_from_file() instead. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw_internal ( self , array ): \"\"\"Load from a file directly obtained by the data collection client. Args: array (ndarray): The buffer, which is a numpy ndarrary. Returns: None: No return value. CAUTION: Do not use this method directly. Instead, uses the class method FMSignalGlove.construct_from_file() instead. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] self . length = l if m == 25 : # NOTE: This is the early format, with only one timestamp. ts = array [:, 0 ] . flatten () tsc = np . zeros ( l , dtype = np . float32 ) acc0 = array [:, 1 : 4 ] gyro0 = array [:, 4 : 7 ] gravity0 = array [:, 7 : 10 ] acc1 = array [:, 13 : 16 ] gyro1 = array [:, 16 : 19 ] gravity1 = array [:, 19 : 22 ] elif m == 34 : # NOTE: This is the current format, with two timestamps. ts = array [:, 1 ] . flatten () tsc = array [:, 0 ] . flatten () # Use an offset to reduce the size of tsc so that it can fit into # the float32 type. tsc -= 1514764800 acc0 = array [:, 2 : 5 ] gyro0 = array [:, 5 : 8 ] gravity0 = array [:, 11 : 14 ] acc1 = array [:, 18 : 21 ] gyro1 = array [:, 21 : 24 ] gravity1 = array [:, 27 : 30 ] else : raise ValueError ( \"Unknown format: m = %d \" % m ) # Fix any timestamp anormaly # NOTE: The device timestamps in glove data are in millisecond. for i in range ( l - 1 ): if ts [ i + 1 ] < ts [ i ]: ts [ i + 1 ] = ts [ i ] + 20 self . ts = ts . astype ( np . float32 ) self . tsc = tsc . astype ( np . float32 ) self . acc0 = acc0 . astype ( np . float32 ) self . gyro0 = gyro0 . astype ( np . float32 ) self . gravity0 = gravity0 . astype ( np . float32 ) self . acc1 = acc1 . astype ( np . float32 ) self . gyro1 = gyro1 . astype ( np . float32 ) self . gravity1 = gravity1 . astype ( np . float32 )","title":"load_from_buffer_raw_internal()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.load_from_file","text":"General interface to load the raw signal from a file. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"General interface to load the raw signal from a file. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"raw_internal\" : fn += \".txt\" # NOTE: The \"dtype\" needs to be np.float64 for the raw timestamps! array = np . loadtxt ( fn , np . float64 , delimiter = \",\" ) self . load_from_buffer_raw_internal ( array ) elif mode == \"raw_csv\" : fn += \".csv\" array = np . loadtxt ( fn , np . float32 , delimiter = \",\" ) self . load_from_buffer_raw ( array ) elif mode == \"raw_npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 self . load_from_buffer_raw ( array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode )","title":"load_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.pose_normalize","text":"Normalize the position and orientation of the signal. NOTE : This method expect a start index and an end index, where the signal segment between the start and the end is used to calculate the average pointing direction. Hence, it should be called after \"prepare_trim_by_xxx()\". NOTE : This normalization step depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" Parameters: Name Type Description Default start int The start time index of the signal for normalization. required end int The end time index of the signal for normalization. required p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description None No return value. Exceptions: Type Description ValueError If the \"point\" is wrong or the \"start\" or \"end\" is bad. Source code in code_fmkit/fmsignal.py def pose_normalize ( self , start , end , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Normalize the position and orientation of the signal. **NOTE**: This method expect a start index and an end index, where the signal segment between the start and the end is used to calculate the average pointing direction. Hence, it should be called after \"prepare_trim_by_xxx()\". **NOTE**: This normalization step depends on the orientation. Hence, it must be called after \"estimate_angular_states()\" Args: start (int): The start time index of the signal for normalization. end (int): The end time index of the signal for normalization. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: None: No return value. Raises: ValueError: If the \"point\" is wrong or the \"start\" or \"end\" is bad. \"\"\" data = self . data rotms = self . rotms qs = self . qs vi = np . array (( 1.0 , 0 , 0 ), np . float32 ) . reshape (( 3 , 1 )) # vj = np.array((0, 1.0, 0), np.float32).reshape((3, 1)) vk = np . array (( 0 , 0 , 1.0 ), np . float32 ) . reshape (( 3 , 1 )) # find the approximated average pointing direction as vx # find the approximated average downward direction as vz vxs = np . matmul ( rotms [ start : end ], vi ) vzs = np . matmul ( rotms [ start : end ], vk ) vx = np . mean ( vxs , axis = 0 ) . flatten () vz = np . mean ( vzs , axis = 0 ) . flatten () vx = vx / np . linalg . norm ( vx ) vz = vz / np . linalg . norm ( vz ) vy = np . cross ( vz , vx ) vy = vy / np . linalg . norm ( vy ) vz = np . cross ( vx , vy ) vz = vz / np . linalg . norm ( vz ) vx = vx . reshape (( 3 , 1 )) vy = vy . reshape (( 3 , 1 )) vz = vz . reshape (( 3 , 1 )) R_g2l = np . concatenate (( vx , vy , vz ), axis = 1 ) normalize_rotation_matrix ( R_g2l ) R_l2g = R_g2l . transpose () R_offset = euler_zyx_to_rotation_matrix ( p_yaw , p_pitch , p_roll ) R_l2g = np . matmul ( R_offset , R_l2g ) for i in range ( self . length ): rotm = np . matmul ( R_l2g , rotms [ i ]) rotm = normalize_rotation_matrix ( rotm ) q = Quaternion . construct_from_rotation_matrix ( rotm ) rotms [ i ] = rotm qs [ i ] = q # Now we derive the three Tait-Bryan angles # CAUTION: yaw first, then pitch, then roll # i.e., z-y-x intrinsic rotation (east, north, sky) # yaw, pitch, roll, gimbal_lock \\ # = rotation_matrix_to_euler_angles_zyx(rotm) # # data[i, 9] = roll # data[i, 10] = pitch # data[i, 11] = yaw # Tait-Bryan angles have singularity. # Use quaternion components instead. data [ i , 9 ] = q . x data [ i , 10 ] = q . y data [ i , 11 ] = q . z # verify using the gravity vector # self.data[i, 3:6] = np.matmul(rotms[i], gravity0[i].reshape((3, 1))).reshape(3) # apply pose offset on angular speed ov = data [:, 12 : 15 ] . T ov = np . matmul ( R_offset , ov ) data [:, 12 : 15 ] = ov . T data [:, 15 ] = np . gradient ( data [:, 12 ]) data [:, 16 ] = np . gradient ( data [:, 13 ]) data [:, 17 ] = np . gradient ( data [:, 14 ])","title":"pose_normalize()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.prepare_trim_by_acc","text":"Determine the indicies for the start and end of the finger motion. NOTE : The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. NOTE : This method is only used in the preprocessing procedure. This method DOES NOT modify the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to detect the hand motion. required Returns: Type Description None No return value. NOTE : The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. Source code in code_fmkit/fmsignal.py def prepare_trim_by_acc ( self , point , threshold ): \"\"\"Determine the indicies for the start and end of the finger motion. **NOTE**: The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. **NOTE**: This method is only used in the preprocessing procedure. This method **DOES NOT** modify the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to detect the hand motion. Returns: None: No return value. **NOTE**: The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. \"\"\" if point == \"tip\" : data = self . acc0 elif point == \"center\" : data = self . acc1 else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) l = self . length acc = data . copy () a = np . linalg . norm ( acc , axis = 1 ) a_std = np . std ( a ) # NOTE: We cannot subtract the mean of acceleration here. an = np . divide ( a , a_std ) start = 0 for i in range ( l ): if abs ( an [ i ]) > threshold : start = i - 5 break start = max ( start , 0 ) end = 0 for i in range ( l - 1 , 0 , - 1 ): if abs ( an [ i ]) > threshold : end = i + 5 break end = min ( end , l ) return ( start , end )","title":"prepare_trim_by_acc()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.preprocess","text":"Preprocess the signal. NOTE : This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to trim the signal without hand motion. 0.2 cut_freq float Low pass filtering cutoff frequency. 10 p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description FMSignal The preprocessed signal. NOTE : The default argument values are typically good enough. Source code in code_fmkit/fmsignal.py def preprocess ( self , point , threshold = 0.2 , cut_freq = 10 , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Preprocess the signal. **NOTE**: This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to trim the signal without hand motion. cut_freq (float): Low pass filtering cutoff frequency. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: FMSignal: The preprocessed signal. **NOTE**: The default argument values are typically good enough. \"\"\" dim = 18 data = np . zeros (( self . length , dim ), dtype = np . float32 ) self . dim = dim self . data = data start , end = self . prepare_trim_by_acc ( point , threshold ) self . estimate_angular_states ( point ) self . pose_normalize ( start , end , p_yaw , p_pitch , p_roll ) self . estimate_linear_states ( point ) sample_freq = self . length / ( self . ts [ self . length - 1 ]) * 1000.0 #self.filter(sample_freq, cut_freq) #self.trim(start, end) assert self . ts . dtype == np . float32 assert self . data . dtype == np . float32 signal = FMSignal ( self . length , self . dim , self . ts , self . data , self . user , self . cid , self . seq ) return signal","title":"preprocess()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.save_to_buffer_raw","text":"Save the raw signal to a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default None None No argument. required Returns: Type Description ndarray The buffer. Source code in code_fmkit/fmsignal.py def save_to_buffer_raw ( self ): \"\"\"Save the raw signal to a NumPy ndarray. **NOTE**: This is only for internal usage. Args: None (None): No argument. Returns: ndarray: The buffer. \"\"\" array = np . zeros (( self . length , 20 ), dtype = np . float32 ) array [:, 0 ] = self . tsc array [:, 1 ] = self . ts array [:, 2 : 5 ] = self . acc0 array [:, 5 : 8 ] = self . gyro0 array [:, 8 : 11 ] = self . gravity0 array [:, 11 : 14 ] = self . acc1 array [:, 14 : 17 ] = self . gyro1 array [:, 17 : 20 ] = self . gravity1 return array","title":"save_to_buffer_raw()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.save_to_file","text":"General interface to save the raw signal to a file. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"General interface to save the raw signal to a file. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. \"\"\" if mode == \"raw_csv\" : array = self . save_to_buffer_raw () fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"raw_npy\" : array = self . save_to_buffer_raw () # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode )","title":"save_to_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalGlove.trim","text":"Trim the start and end of the signal where the hand does not move. NOTE : The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default start int The start index, i.e., data[start:end, :] will be kept. required end int The end index, i.e., data[start:end, :] will be kept. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def trim ( self , start , end ): \"\"\"Trim the start and end of the signal where the hand does not move. **NOTE**: The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: start (int): The start index, i.e., data[start:end, :] will be kept. end (int): The end index, i.e., data[start:end, :] will be kept. Returns: None: No return value. \"\"\" l_new = end - start # NOTE: These \"copy()\" force the \"ts\" and \"data\" to have proper C-like # array in memory, which is crucial for \"dtw_c()\"!!! self . data = self . data [ start : end , :] . copy () self . ts = self . ts [ start : end ] . copy () ts0 = self . ts [ 0 ] self . ts -= ts0 self . length = l_new if self . qs is not None : self . qs = self . qs [ start : end ] if self . rotms is not None : self . rotms = self . rotms [ start : end ] if self . trajectory is not None : self . trajectory = self . trajectory [ start : end ]","title":"trim()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap","text":"Raw finger motion signal collected by the Leap Motion controller. This class represents the raw signal obtained from the Leap Motion sensor. An FMSignal object can be obtained by preprocessing this raw signal, where the preprocessing is essentially the main purpose of this FMSignalLeap class. It has the following additional attributes. Attributes: Name Type Description length int The number of samples in this signal. ts ndarray Timestamp obtained from the device (1D vector). tsc ndarray Timestamp obtained from the client computer (1D vector). tip ndarray Position of the index finger tip (length * 3 matrix). center ndarray Position of the palm center (length * 3 matrix). joints ndarray Position of each joint (length * 5 * 5 * 3 tensor). confs ndarray Confidence value of each sample (1D vector). valids ndarray Whether the sample is valid (1D vector). data ndarray The data after preprocessing. rotms ndarray The orientation of each smple in rotation matrices. qs list The orientation of each smple in unit quaternions. trajectory ndarray The motion trajectory of the selected point. NOTE : The \"joints\" is a length * 5 * 5 * 3 tensor, i.e., 5 fingers, 5 joints on each finger, and 3 coordinates for each joint. The sequence of fingers are [thumb, index finger, middle finger, ring finger, little finger]. The sequence of joints are from the end of the palm to the tip of the finger. For example, \"joints[:, 1, 0, :]\" is the trajectory of the palm end of the index finger, and \"joints[:, 1, 4, :]\" is the trajectory of the tip of the index finger. Note that the thumb has only four joints, i.e., \"joints[:, 0, 0, :]\" and \"joints[:, 0, 1, :]\" are identical. NOTE : The preprocessed signal contains the motion of only one point on the hand, which can be derived either from the center of the hand or the tip of the index finger. This is controlled by the \"point\" argument of the \"preprocess()\" method. NOTE : The raw signal file may have two different formats, i.e., either in Comma Separated Value (\".csv\") or in NumPy binary format (\".npy\"). However, the content structure is the same, which is essentially a matrix, where the rows are the samples at a certain time and the columns are the data from a specific sensor axis. See the \"Data Format Details\" document for more information. There is another format called \"raw_internal\", which is used to resolve format issues in the data collected at the early stage of this project. It is now obsolete.","title":"FMSignalLeap"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.__init__","text":"Constructor. See the attributes of FMSignal for the meaning of the arguments. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. Source code in code_fmkit/fmsignal.py def __init__ ( self , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the attributes of FMSignal for the meaning of the arguments. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" to load data from a file, or use the \"copy()\" method to duplicate a signal. \"\"\" self . user = user self . cid = cid self . seq = seq self . length = 0 self . ts = None self . tsc = None self . tip = None self . center = None self . joints = None self . confs = None self . valids = None self . data = None self . qs = None self . rotms = None self . trajectory = None","title":"__init__()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.all_close_to","text":"Check whether this signal is almost identical to the other signal. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Parameters: Name Type Description Default signal FMSignalLeap The other signal to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , signal ): \"\"\"Check whether this signal is almost identical to the other signal. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two signals must have the same type and length. Args: signal (FMSignalLeap): The other signal to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( signal , FMSignalLeap ): return False if self . length != signal . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , signal . ts , atol = 1e-6 ) r2 = np . allclose ( self . tsc , signal . tsc , atol = 1e-6 ) r3 = np . allclose ( self . tip , signal . tip , atol = 1e-6 ) r4 = np . allclose ( self . center , signal . center , atol = 1e-6 ) r5 = np . allclose ( self . joints , signal . joints , atol = 1e-6 ) r6 = np . allclose ( self . confs , signal . confs , atol = 1e-6 ) r7 = np . allclose ( self . valids , signal . valids , atol = 1e-6 ) return r1 and r2 and r3 and r4 and r5 and r6 and r7","title":"all_close_to()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.construct_from_file","text":"Construct a signal by loading data from a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignalLeap The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is wrong. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Construct a signal by loading data from a file. Args: fn (string): The file name (without extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignalLeap: The constructed signal object. Raises: ValueError: If the \"mode\" is wrong. FileNotFoundError: If the file does not exist. \"\"\" signal = FMSignalLeap ( user , cid , seq ) signal . load_from_file ( fn , mode ) return signal","title":"construct_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.estimate_angular_states","text":"Estimate orientation, angular speed, and angular acceleration. NOTE : Orientations are represented as the qx, qy, and qz components of a unit quaternion. It is obtained by the position of the joints of the hand. NOTE : Currently, the angular speed is the relative local differential of the angular position. The angular acceleration is just the differential of the angular speed, not the real angular acceleration. In this way, even if the reference frame changes, the angular speed will not change. Hence, we add three purtubation angles to change the local reference frame a bit as needed, mainly for data augmentation usage. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. This method should be called after the pose normalization step. NOTE : Currently, this method iterates through each sample, which is relatively slow. Parameters: Name Type Description Default p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def estimate_angular_states ( self , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Estimate orientation, angular speed, and angular acceleration. **NOTE**: Orientations are represented as the qx, qy, and qz components of a unit quaternion. It is obtained by the position of the joints of the hand. **NOTE**: Currently, the angular speed is the relative local differential of the angular position. The angular acceleration is just the differential of the angular speed, not the real angular acceleration. In this way, even if the reference frame changes, the angular speed will not change. Hence, we add three purtubation angles to change the local reference frame a bit as needed, mainly for data augmentation usage. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. This method should be called after the pose normalization step. **NOTE**: Currently, this method iterates through each sample, which is relatively slow. Args: p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: None: No return value. \"\"\" data = self . data ts = self . ts # rotation matrix of each data sample rotms = np . zeros (( self . length , 3 , 3 )) # pose offset, for augmentation R_offset = euler_zyx_to_rotation_matrix ( p_yaw , p_pitch , p_roll ) # quaternion of each data sample qs = [ None ] * self . length omega_pre = np . asarray (( 0.0 , 0.0 , 0.0 )) for i in range ( self . length ): joints = self . joints [ i ] # Origin is the near end of the index finger. # p0 = joints[1, 1] p0 = joints [ 1 , 0 ] # Pointing direction is from the near end to the next joint along # the index finger. # p1 = joints[1, 2] p1 = joints [ 1 , 1 ] # The side direction is from the near end of the index finger to # the near end of the little finger. # p2 = joints[4, 1] p2 = joints [ 4 , 0 ] # derive the pose represented in three orthogonal vectors, # i.e., vx, vy, vz # Note that here vx is the general pointing direction, vz is the # general palm facing direction vx = p1 - p0 vy_prime = p0 - p2 vz = np . cross ( vx , vy_prime ) if np . linalg . norm ( vx ) <= 1e-6 : print ( i , p0 , p1 ) # most of the time the palm is facing downward, so we flip the # axes here to set up a local reference frame where the z-axis # is always upward. # CAUTION: There are chances that the sensor wrongly recognize the # right hand as the palm facing upward. Similarly, there are cases # that the right hand is wrongly identified as the left hand. In # either cases, we just always make the z-axis upward. # if vz[2] < 0: # vz = -vz vy = np . cross ( vz , vx ) vz = np . cross ( vx , vy ) vx = vx / np . linalg . norm ( vx ) vy = vy / np . linalg . norm ( vy ) vz = vz / np . linalg . norm ( vz ) vx = vx . reshape (( 3 , 1 )) vy = vy . reshape (( 3 , 1 )) vz = vz . reshape (( 3 , 1 )) # CAUTION: this is just an approximation of a rotation matrix, # and it may not be perfectly northonormal!!! rotm = np . concatenate (( vx , vy , vz ), axis = 1 ) q = Quaternion . construct_from_rotation_matrix ( rotm ) # print(q, q.norm()) # u = rotation_matrix_to_angle_axis(rotm) if i > 0 : pv = qs [ i - 1 ] . to_vector () qv = q . to_vector () p1 = np . linalg . norm ( pv - qv ) p2 = np . linalg . norm ( pv + qv ) if p1 > p2 : q = q . negate () # Now since it is a unit quaternion encoding the rotation, we # convert it back to a rotation matrix for future usage # rotm = q.to_rotation_matrix() qs [ i ] = q rotms [ i ] = rotm # Now we derive the three Tait-Bryan angles # CAUTION: yaw first, then pitch, then roll # i.e., z-y-x intrinsic rotation (east, north, sky) # yaw, pitch, roll, gimbal_lock \\ # = rotation_matrix_to_euler_angles_zyx(rotm) # # data[i, 9] = roll # data[i, 10] = pitch # data[i, 11] = yaw # # assert not gimbal_lock # Tait-Bryan angles have singularity. # Use quaternion components instead. data [ i , 9 ] = q . x data [ i , 10 ] = q . y data [ i , 11 ] = q . z # data[i, 9:12] = u if i > 0 : timestep = ts [ i ] - ts [ i - 1 ] if timestep > 0 : p = qs [ i - 1 ] omega = Quaternion . differentiate_local ( p , q , timestep ) else : omega = omega_pre omega_pre = omega data [ i , 12 ] = omega [ 0 ] * 1000 data [ i , 13 ] = omega [ 1 ] * 1000 data [ i , 14 ] = omega [ 2 ] * 1000 data [ 0 , 12 ] = data [ 1 , 12 ] data [ 0 , 13 ] = data [ 1 , 13 ] data [ 0 , 14 ] = data [ 1 , 14 ] ov = data [:, 12 : 15 ] . T ov = np . matmul ( R_offset , ov ) data [:, 12 : 15 ] = ov . T data [:, 15 ] = np . gradient ( data [:, 12 ]) data [:, 16 ] = np . gradient ( data [:, 13 ]) data [:, 17 ] = np . gradient ( data [:, 14 ]) #print(data.dtype) self . data = data self . dim = 18 self . rotms = rotms self . qs = qs","title":"estimate_angular_states()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.estimate_linear_states","text":"Estimate position, velocity and acceleration. NOTE : For the Leap Motion device, only the position is directly obtained from the device. The velocity and acceleration are derived by differentiating the the position. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def estimate_linear_states ( self , point ): \"\"\"Estimate position, velocity and acceleration. **NOTE**: For the Leap Motion device, only the position is directly obtained from the device. The velocity and acceleration are derived by differentiating the the position. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". Returns: None: No return value. \"\"\" data = self . data # print(data.dtype) if point == \"tip\" : # Use the tip of the index finger. data [:, 0 : 3 ] = self . tip self . trajectory = self . tip . copy () elif point == \"center\" : # Use the center of the palm. data [:, 0 : 3 ] = self . center self . trajectory = self . center . copy () else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) data [:, 3 ] = np . gradient ( data [:, 0 ]) data [:, 4 ] = np . gradient ( data [:, 1 ]) data [:, 5 ] = np . gradient ( data [:, 2 ]) data [:, 6 ] = np . gradient ( data [:, 3 ]) data [:, 7 ] = np . gradient ( data [:, 4 ]) data [:, 8 ] = np . gradient ( data [:, 5 ]) # print(data.dtype) self . data = data","title":"estimate_linear_states()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.filter","text":"Low-pass filtering on the signal. NOTE : It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default sample_freq float sample frequency of this signal. required cut_freq float low pass filtering cutoff frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def filter ( self , sample_freq , cut_freq ): \"\"\"Low-pass filtering on the signal. **NOTE**: It is assumed that a hand can not move in very high frequency, so the high frequency components of the signal is filtered. This method uses NumPy FFT and IFFT. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: sample_freq (float): sample frequency of this signal. cut_freq (float): low pass filtering cutoff frequency. Returns: None: No return value. \"\"\" l = self . length data = self . data cut_l = int ( cut_freq * l / sample_freq ) dft_co = np . fft . fft ( data , l , axis = 0 ) for i in range ( cut_l , l - cut_l ): dft_co [ i ] = 0 + 0 j ifft_c = np . fft . ifft ( dft_co , l , axis = 0 ) # NOTE: This must be converted to \"np.float32\"! ifft = ifft_c . real . astype ( np . float32 ) #print(ifft.dtype) self . data = ifft","title":"filter()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.fix_missing_samples","text":"Fix missing data samples by linear interpolation. NOTE : This is only for internal usage. The missing samples are mainly caused by the motion of the hand which are outside the field of the view of the sensor. This procedure assumes that the first sample is always valid! Since it uses linear interpolation, it will not work well with too many missing samples. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default None None No argument. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def fix_missing_samples ( self ): \"\"\"Fix missing data samples by linear interpolation. **NOTE**: This is only for internal usage. The missing samples are mainly caused by the motion of the hand which are outside the field of the view of the sensor. This procedure assumes that the first sample is always valid! Since it uses linear interpolation, it will not work well with too many missing samples. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: None (None): No argument. Returns: None: No return value. \"\"\" l = self . length i = 0 while i < l - 1 : # Find the start index of a missing segment. while i < l - 1 : if self . valids [ i ] == 0 : break else : i += 1 # Find the end index of a missing segment. j = i while j < l - 1 : if self . valids [ j ] == 1 : break else : j += 1 # If missing points found between i and j, fix them. # If no missing point found, just skip. if i < j : # print(i, j) start_ts = self . ts [ i - 1 ] end_ts = self . ts [ j ] start_tip = self . tip [ i - 1 ] end_tip = self . tip [ j ] length_tip = ( end_tip - start_tip ) start_center = self . center [ i - 1 ] end_center = self . center [ j ] length_center = ( end_center - start_center ) start_joints = self . joints [ i - 1 ] end_joints = self . joints [ j ] length_joints = ( end_joints - start_joints ) for k in range ( i , j ): k_ts = self . ts [ k ] rate = ( k_ts - start_ts ) * 1.0 / ( end_ts - start_ts ) self . tip [ k ] = start_tip + length_tip * rate self . center [ k ] = start_center + length_center * rate self . joints [ k ] = start_joints + length_joints * rate self . valids [ k ] = 1 # Find another missing sement in the next iteration i = j","title":"fix_missing_samples()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.load_from_buffer_raw","text":"Load data from a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default array ndarray The buffer. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw ( self , array ): \"\"\"Load data from a NumPy ndarray. **NOTE**: This is only for internal usage. Args: array (ndarray): The buffer. Returns: None: No return value. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] assert m == 2 + 3 + 3 + 75 + 2 , \"Wrong raw file format: m = %d \" % m self . length = l self . ts = array [:, 1 ] . flatten () self . tsc = array [:, 0 ] . flatten () offset_tip = 2 offset_center = 2 + 3 offset_joints = 2 + 3 + 3 self . tip = array [:, offset_tip : offset_tip + 3 ] self . center = array [:, offset_center : offset_center + 3 ] # Load joint positions self . joints = np . zeros (( l , 5 , 5 , 3 ), np . float32 ) for j in range ( 5 ): for k in range ( 5 ): index = offset_joints + j * 5 * 3 + k * 3 self . joints [:, j , k , :] = array [:, index : index + 3 ] # Load confidences and valid flags self . confs = array [:, - 2 ] self . valids = array [:, - 1 ]","title":"load_from_buffer_raw()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.load_from_buffer_raw_internal","text":"Load data from a NumPy ndarray in the \"raw_internal\" format. NOTE : This is only for internal usage. Parameters: Name Type Description Default array ndarray The buffer. required Returns: Type Description None No Return value. Source code in code_fmkit/fmsignal.py def load_from_buffer_raw_internal ( self , array ): \"\"\"Load data from a NumPy ndarray in the \"raw_internal\" format. **NOTE**: This is only for internal usage. Args: array (ndarray): The buffer. Returns: None: No Return value. \"\"\" l = array . shape [ 0 ] m = array . shape [ 1 ] # --------- process timestamp ------ if m == 133 or m == 93 : # NOTE: This is the old format, with only one timestamp. offset_base = 1 ts = array [:, 0 ] . flatten () tsc = np . zeros ( l , np . float32 ) elif m == 134 : # CATUION: the current format, with two timestamps. offset_base = 2 ts = array [:, 1 ] . flatten () tsc = array [:, 0 ] . flatten () # Use an offset to reduce the size of tsc so that it can fit into # the float32 type. tsc -= 1514764800 else : raise ValueError ( \"Unknown data file format!: m = %d \" % m ) for i in range ( l ): # fix timestamp wraping over maximum of uint32 if i > 0 and ts [ i ] < ts [ i - 1 ]: ts [ i ] += 4294967295.0 # Fix timestamp offset and convert timestamp to millisecond # CAUTION: timestamp must start from 0! Other methods such as filtering # depend on this assumption! ts0 = ts [ 0 ] ts -= ts0 ts /= 1000 # --------- process point coordinate and joint coordinate ------ offset_tip = offset_base offset_center = offset_base + 6 offset_joints = offset_base + 6 + 9 data_tip = np . zeros (( l , 3 ), np . float32 ) # NOTE: Axes mapping: yzx -> xyz data_tip [:, 0 ] = array [:, offset_tip + 2 ] data_tip [:, 1 ] = array [:, offset_tip + 0 ] data_tip [:, 2 ] = array [:, offset_tip + 1 ] data_center = np . zeros (( l , 3 ), np . float32 ) # NOTE: Axes mapping: yzx -> xyz data_center [:, 0 ] = array [:, offset_center + 2 ] data_center [:, 1 ] = array [:, offset_center + 0 ] data_center [:, 2 ] = array [:, offset_center + 1 ] data_joints = np . zeros (( l , 5 , 5 , 3 ), np . float32 ) # Load joint positions for j in range ( 5 ): for k in range ( 5 ): index = j * 5 * 3 + k * 3 # NOTE: Axes mapping: yzx -> xyz data_joints [:, j , k , 0 ] = array [:, offset_joints + index + 2 ] data_joints [:, j , k , 1 ] = array [:, offset_joints + index + 0 ] data_joints [:, j , k , 2 ] = array [:, offset_joints + index + 1 ] # Load confidences and valid flags confs = array [:, - 2 ] valids = array [:, - 1 ] self . length = l self . ts = ts . astype ( np . float32 ) self . tsc = tsc . astype ( np . float32 ) self . tip = data_tip self . center = data_center self . joints = data_joints self . confs = confs . astype ( np . float32 ) self . valids = valids . astype ( np . float32 )","title":"load_from_buffer_raw_internal()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.load_from_file","text":"General interface to load the raw signal from a file. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"General interface to load the raw signal from a file. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"raw_internal\" : fn += \".txt\" # NOTE: The \"dtype\" needs to be np.float64 for the raw timestamps! array = np . loadtxt ( fn , np . float64 , delimiter = \",\" ) self . load_from_buffer_raw_internal ( array ) elif mode == \"raw_csv\" : fn += \".csv\" array = np . loadtxt ( fn , np . float32 , delimiter = \",\" ) self . load_from_buffer_raw ( array ) elif mode == \"raw_npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 self . load_from_buffer_raw ( array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode )","title":"load_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.pose_normalize","text":"Normalize the position and orientation of the signal. NOTE : The new x-axis is the average of the pointing direction, the new z-axis is the vertical up direction of the leap motion sensor (assuming the sensor is placed on a horizontal surface), and the new y-axis is determined by the new x-axis and y-axis. NOTE : The three angles in the argument are offsets that applied during the normalization in radians. This can be used in orientation purtubation for data augmentation or correcting the pointing direction. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required start int The start time index of the signal for normalization. required end int The end time index of the signal for normalization. required p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description None No return value. Exceptions: Type Description ValueError If the \"point\" is wrong or the \"start\" or \"end\" is bad. Source code in code_fmkit/fmsignal.py def pose_normalize ( self , point , start , end , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Normalize the position and orientation of the signal. **NOTE**: The new x-axis is the average of the pointing direction, the new z-axis is the vertical up direction of the leap motion sensor (assuming the sensor is placed on a horizontal surface), and the new y-axis is determined by the new x-axis and y-axis. **NOTE**: The three angles in the argument are offsets that applied during the normalization in radians. This can be used in orientation purtubation for data augmentation or correcting the pointing direction. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". start (int): The start time index of the signal for normalization. end (int): The end time index of the signal for normalization. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: None: No return value. Raises: ValueError: If the \"point\" is wrong or the \"start\" or \"end\" is bad. \"\"\" l = self . length if start < 0 and end >= l and end <= start : raise ValueError ( \"Bad start and end indices: %d , %d .\" \\ % ( start , end )) # Find the average position. if point == \"tip\" : # Use the tip of the index finger. pos = self . tip [ start : end ] elif point == \"center\" : # Use the center of the palm. pos = self . center [ start : end ] else : raise ValueError ( \"Unknown point type: %s .\" % str ( point )) pos_mean = np . mean ( pos , axis = 0 ) # Position normalization. self . translate ( - pos_mean ) # Find the average orientation. data_joints = self . joints if point == \"tip\" : # Use the direction of the middle segment of the index finger. p0 = data_joints [ start : end , 1 , 1 , :] p1 = data_joints [ start : end , 1 , 2 , :] elif point == \"center\" : # Use the direction of the last segment of the middle finger. p0 = data_joints [ start : end , 2 , 0 , :] p1 = data_joints [ start : end , 2 , 1 , :] else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) vx = np . mean ( p1 - p0 , axis = 0 ) vz_t = np . asarray (( 0.0 , 0.0 , 1.0 ), np . float32 ) vy = np . cross ( vz_t , vx ) vz = np . cross ( vx , vy ) vx = vx / np . linalg . norm ( vx ) vy = vy / np . linalg . norm ( vy ) vz = vz / np . linalg . norm ( vz ) vx = vx . reshape (( 3 , 1 )) vy = vy . reshape (( 3 , 1 )) vz = vz . reshape (( 3 , 1 )) # Orientation normalization. # NOTE: \"p_yaw\", \"p_pitch\", \"p_roll\" are orientation pertubation. They # are all in radian. R_g2l = np . concatenate (( vx , vy , vz ), axis = 1 ) R_l2g = R_g2l . transpose () R_offset = euler_zyx_to_rotation_matrix ( p_yaw , p_pitch , p_roll ) R_l2g = np . matmul ( R_offset , R_l2g ) self . rotate ( R_l2g )","title":"pose_normalize()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.prepare_trim_by_velocity","text":"Determine the indicies for the start and end of the finger motion. NOTE : The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. NOTE : This method is only used in the preprocessing procedure. This method DOES NOT modify the signal. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to detect the hand motion. required Returns: Type Description None No return value. NOTE : The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. Source code in code_fmkit/fmsignal.py def prepare_trim_by_velocity ( self , point , threshold ): \"\"\"Determine the indicies for the start and end of the finger motion. **NOTE**: The trimming process is split into two parts to accommodate other preprocessing steps. This method is the first part, which returns the start and end indices without actually throwing away the data samples when the hand is not moving. **NOTE**: This method is only used in the preprocessing procedure. This method **DOES NOT** modify the signal. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to detect the hand motion. Returns: None: No return value. **NOTE**: The threshold is relative. Typically some value between 0.2 to 0.5 would be good enough. \"\"\" if point == \"tip\" : # Use the tip of the index finger. pos = self . tip elif point == \"center\" : # Use the center of the palm. pos = self . center else : raise ValueError ( \"Unknown point type: %s \" % str ( point )) vel = pos . copy () l = self . length # The \"start\" and \"end\" are determined by the relative velocity. It is # calculated here by taking gradient of the position and then # normalizing it. vel [:, 0 ] = np . gradient ( pos [:, 0 ]) vel [:, 1 ] = np . gradient ( pos [:, 1 ]) vel [:, 2 ] = np . gradient ( pos [:, 2 ]) v = np . linalg . norm ( vel , axis = 1 ) v_std = np . std ( v ) # NOTE: We cannot subtract the mean of velocity here. vn = np . divide ( v , v_std ) # Determine the start start = 0 for i in range ( l ): if abs ( vn [ i ]) > threshold : start = i - 5 break start = max ( start , 0 ) end = 0 for i in range ( l - 1 , 0 , - 1 ): if abs ( vn [ i ]) > threshold : end = i + 5 break end = min ( end , l ) # print(self.id_label, self.seq, l, start, l - end) return ( start , end )","title":"prepare_trim_by_velocity()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.preprocess","text":"Preprocess the signal. NOTE : This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Parameters: Name Type Description Default point string The point on the hand, either \"tip\" or \"center\". required threshold float Threshold to trim the signal without hand motion. 0.2 cut_freq float Low pass filtering cutoff frequency. 10 re_freq float Resampling frequency. 50 p_yaw float The pertubation yaw angle in radian. 0 p_pitch float The pertubation pitch angle in radian. 0 p_roll float The pertubation roll angle in radian. 0 Returns: Type Description FMSignal The preprocessed signal. NOTE : The default argument values are typically good enough. Source code in code_fmkit/fmsignal.py def preprocess ( self , point , threshold = 0.2 , cut_freq = 10 , re_freq = 50 , p_yaw = 0 , p_pitch = 0 , p_roll = 0 ): \"\"\"Preprocess the signal. **NOTE**: This method follows all the preprocessing steps. See the \"Data Processing\" document for details. Args: point (string): The point on the hand, either \"tip\" or \"center\". threshold (float): Threshold to trim the signal without hand motion. cut_freq (float): Low pass filtering cutoff frequency. re_freq (float): Resampling frequency. p_yaw (float): The pertubation yaw angle in radian. p_pitch (float): The pertubation pitch angle in radian. p_roll (float): The pertubation roll angle in radian. Returns: FMSignal: The preprocessed signal. **NOTE**: The default argument values are typically good enough. \"\"\" self . fix_missing_samples () self . resample ( re_freq ) start , end = self . prepare_trim_by_velocity ( point , threshold ) self . pose_normalize ( point , start , end , p_yaw , p_pitch , p_roll ) # For the Leap Motion device, position is directly observable. dim = 18 data = np . zeros (( self . length , dim ), dtype = np . float32 ) self . dim = dim self . data = data self . estimate_linear_states ( point ) self . estimate_angular_states ( p_yaw , p_pitch , p_roll ) self . filter ( re_freq , cut_freq ) self . trim ( start , end ) assert self . ts . dtype == np . float32 assert self . data . dtype == np . float32 signal = FMSignal ( self . length , self . dim , self . ts , self . data , self . user , self . cid , self . seq ) return signal","title":"preprocess()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.resample","text":"Resample the signal at a specified frequency. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. This method uses linear interpolation for resampling. Parameters: Name Type Description Default re_freq float Resampling frequency. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def resample ( self , re_freq ): \"\"\"Resample the signal at a specified frequency. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. This method uses linear interpolation for resampling. Args: re_freq (float): Resampling frequency. Returns: None: No return value. \"\"\" ts = self . ts l = self . length duration = ts [ l - 1 ] - ts [ 0 ] step = 1000.0 / re_freq l_new = int ( duration / 1000.0 * re_freq ) ts_re = np . arange ( 0 , step * l_new , step , dtype = np . float32 ) a_tip_re = np . zeros (( l_new , 3 ), dtype = np . float32 ) for j in range ( 3 ): a_tip_re [:, j ] = np . interp ( ts_re , ts , self . tip [:, j ]) a_center_re = np . zeros (( l_new , 3 ), dtype = np . float32 ) for j in range ( 3 ): a_center_re [:, j ] = np . interp ( ts_re , ts , self . center [:, j ]) data_joints_re = np . zeros (( l_new , 5 , 5 , 3 ), np . float32 ) for j in range ( 5 ): for k in range ( 5 ): for v in range ( 3 ): data_joints_re [:, j , k , v ] = np . interp ( ts_re , ts , self . joints [:, j , k , v ] ) confs_resample = np . interp ( ts_re , ts , self . confs ) . astype ( np . float32 ) valids_resample = np . ones ( l_new , dtype = np . float32 ) # NOTE: Make sure they all have \"dtype == np.float32\"! # print(ts_re.dtype) # print(a_tip_re.dtype) # print(a_center_re.dtype) # print(data_joints_re.dtype) # print(confs_resample.dtype) # print(valids_resample.dtype) self . length = l_new self . ts = ts_re self . tip = a_tip_re self . center = a_center_re self . joints = data_joints_re self . confs = confs_resample self . valids = valids_resample","title":"resample()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.rotate","text":"Rotate the signal coorindate reference frame. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default R ndarray The 3-by-3 rotation matrix. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def rotate ( self , R ): \"\"\"Rotate the signal coorindate reference frame. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: R (ndarray): The 3-by-3 rotation matrix. Returns: None: No return value. \"\"\" pv = self . tip [:, 0 : 3 ] . T pv = np . matmul ( R , pv ) self . tip [:, 0 : 3 ] = pv . T pv = self . center [:, 0 : 3 ] . T pv = np . matmul ( R , pv ) self . center [:, 0 : 3 ] = pv . T for j in range ( 5 ): for k in range ( 5 ): pv = self . joints [:, j , k ] . T pv = np . matmul ( R , pv ) self . joints [:, j , k ] = pv . T","title":"rotate()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.save_to_buffer_raw","text":"Save the raw signal to a NumPy ndarray. NOTE : This is only for internal usage. Parameters: Name Type Description Default None None No argument. required Returns: Type Description ndarray The buffer. Source code in code_fmkit/fmsignal.py def save_to_buffer_raw ( self ): \"\"\"Save the raw signal to a NumPy ndarray. **NOTE**: This is only for internal usage. Args: None (None): No argument. Returns: ndarray: The buffer. \"\"\" m = 2 + 3 + 3 + 75 + 2 array = np . zeros (( self . length , m ), np . float32 ) array [:, 0 ] = self . tsc array [:, 1 ] = self . ts offset_tip = 2 offset_center = 2 + 3 offset_joints = 2 + 3 + 3 array [:, offset_tip : offset_tip + 3 ] = self . tip array [:, offset_center : offset_center + 3 ] = self . center for j in range ( 5 ): for k in range ( 5 ): index = offset_joints + j * 5 * 3 + k * 3 array [:, index : index + 3 ] = self . joints [:, j , k , :] array [:, - 2 ] = self . confs array [:, - 1 ] = self . valids return array","title":"save_to_buffer_raw()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.save_to_file","text":"General interface to save the raw signal to a file. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"General interface to save the raw signal to a file. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. \"\"\" if mode == \"raw_csv\" : array = self . save_to_buffer_raw () fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"raw_npy\" : array = self . save_to_buffer_raw () # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode )","title":"save_to_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.translate","text":"Translate the signal coorindate reference frame. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Parameters: Name Type Description Default t ndarray The 3D translation vector. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def translate ( self , t ): \"\"\"Translate the signal coorindate reference frame. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. Args: t (ndarray): The 3D translation vector. Returns: None: No return value. \"\"\" self . tip += t self . center += t for j in range ( 5 ): for k in range ( 5 ): self . joints [:, j , k ] += t","title":"translate()"},{"location":"fmsignal-reference/#fmsignal.FMSignalLeap.trim","text":"Trim the start and the end where the hand does not move. NOTE : The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. NOTE : This method is only used in the preprocessing procedure. This method modifies the signal. Source code in code_fmkit/fmsignal.py def trim ( self , start , end ): \"\"\"Trim the start and the end where the hand does not move. **NOTE**: The trimming process is split into two parts to accommodate other steps of preprocessing. This method is the second part, which throws away the data samples given the start and end indices. **NOTE**: This method is only used in the preprocessing procedure. This method modifies the signal. \"\"\" l_new = end - start # NOTE: These \"copy()\" force the \"ts\" and \"data\" to have proper C-like # array in memory, which is crucial for \"dtw_c()\"!!! self . data = self . data [ start : end , :] . copy () self . ts = self . ts [ start : end ] . copy () ts0 = self . ts [ 0 ] self . ts -= ts0 self . length = l_new if self . qs is not None : self . qs = self . qs [ start : end ] if self . rotms is not None : self . rotms = self . rotms [ start : end ] if self . trajectory is not None : self . trajectory = self . trajectory [ start : end ] self . tip = self . tip [ start : end ] self . center = self . center [ start : end ] self . joints = self . joints [ start : end ] self . confs = self . confs [ start : end ] self . valids = self . valids [ start : end ]","title":"trim()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate","text":"FMSignal signal template constructed from a collection of signals. In most cases, template is identical to a signal (preprocessed, sensor agnostic) with a few additional attributes. Note that this class is derived from the class \"FMSignal\". Attributes: Name Type Description variance ndarray The variance of the signal (length * 18 matrix). signals_aligned ndarray The signals for constructing the template. NOTE : The variance is calculates at sample level, so it has the same length and dimension as the data, i.e., a length * 18 matrix. NOTE : The \"signals_aligned\" is only valid if it is constructed from a collection of signals, i.e., by calling \"construct_from_signals()\". It is not valid if the template is loaded from a file.","title":"FMSignalTemplate"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.__init__","text":"Constructor. See the attributes of FMSignal for the meaning of the arguments. Source code in code_fmkit/fmsignal.py def __init__ ( self , length = 0 , dim = 0 , ts = None , data = None , variance = None , signals_aligned = None , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Constructor. See the attributes of FMSignal for the meaning of the arguments. \"\"\" FMSignal . __init__ ( self , length , dim , ts , data , user , cid , seq ) self . variance = variance self . signals_aligned = signals_aligned","title":"__init__()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.all_close_to","text":"Check whether this template is almost identical to another template. NOTE : The criteria of \"identical\" is defined by \"np.allclose()\". The two templates must have the same type and length. Parameters: Name Type Description Default template FMSignalTemplate The other template to compare. required Returns: Type Description bool True if they are almost identical; False otherwise. Source code in code_fmkit/fmsignal.py def all_close_to ( self , template ): \"\"\"Check whether this template is almost identical to another template. **NOTE**: The criteria of \"identical\" is defined by \"np.allclose()\". The two templates must have the same type and length. Args: template (FMSignalTemplate): The other template to compare. Returns: bool: True if they are almost identical; False otherwise. \"\"\" if not isinstance ( template , FMSignal ): return False if self . length != template . length : return False # NOTE: The CSV format only stores six digits after the decimal point. # Hence, \"atol\" can not be smaller than 1e-6. r1 = np . allclose ( self . ts , template . ts , atol = 1e-6 ) r2 = np . allclose ( self . data , template . data , atol = 1e-6 ) r3 = np . allclose ( self . variance , template . variance , atol = 1e-6 ) return r1 and r2 and r3","title":"all_close_to()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.construct_from_file","text":"Factory method to build the signal by loading a file. Parameters: Name Type Description Default fn string The file name (without extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required user string The user who creates this signal. '' cid string The unique id indicating the content of the signal. '' seq int The sequence id in a set when loaded from a dataset. 0 Returns: Type Description FMSignalTemplate The constructed signal object. Exceptions: Type Description ValueError If the \"mode\" is wrong. FileNotFoundError If the file does not exist. Source code in code_fmkit/fmsignal.py @classmethod def construct_from_file ( cls , fn , mode , user = \"\" , cid = \"\" , seq = 0 ): \"\"\"Factory method to build the signal by loading a file. Args: fn (string): The file name (without extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". user (string): The user who creates this signal. cid (string): The unique id indicating the content of the signal. seq (int): The sequence id in a set when loaded from a dataset. Returns: FMSignalTemplate: The constructed signal object. Raises: ValueError: If the \"mode\" is wrong. FileNotFoundError: If the file does not exist. \"\"\" template = cls () template . load_from_file ( fn , mode ) template . user = user template . cid = cid template . seq = seq return template","title":"construct_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.construct_from_signals","text":"Construct the template by aligning and average a set of signals. Parameters: Name Type Description Default signals list The collection of signals (FMSignal objects). required template_index int The index indicating the alignment. required window int Alignment window, see \"dtw()\". 50 penalty int Element-wise misalignment penalty, see \"dtw()\". 0 NOTE : The \"signals\" should be a collection of signals Source code in code_fmkit/fmsignal.py @classmethod def construct_from_signals ( cls , signals , template_index , window = 50 , penalty = 0 ): \"\"\"Construct the template by aligning and average a set of signals. Args: signals (list): The collection of signals (FMSignal objects). template_index (int): The index indicating the alignment. window (int): Alignment window, see \"dtw()\". penalty (int): Element-wise misalignment penalty, see \"dtw()\". **NOTE**: The \"signals\" should be a collection of signals \"\"\" signal_t = signals [ template_index ] signals_aligned = [ signal_t ] k = len ( signals ) # construct signal template length = signal_t . length dim = signal_t . dim ts = signal_t . ts . copy () data = signal_t . data . copy () variance = np . zeros ( signal_t . data . shape , signal_t . data . dtype ) for signal in signals : if signal == signal_t : continue signal_aligned = signal . align_to ( signal_t , window , penalty ) signals_aligned . append ( signal_aligned ) data += signal_aligned . data data /= k for signal_aligned in signals_aligned : variance += np . square ( signal_aligned . data - data ) variance /= k template = cls ( length , dim , ts , data , variance , signals_aligned , signal_t . user , signal_t . cid , signal_t . seq ) return template","title":"construct_from_signals()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.load_from_file","text":"General interface to load the template from a file. NOTE : This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Exceptions: Type Description ValueError if the \"mode\" is unknown. FileNotFoundError if the file does not exist. Source code in code_fmkit/fmsignal.py def load_from_file ( self , fn , mode ): \"\"\"General interface to load the template from a file. **NOTE**: This is only for internal usage. If an FMSignalLeap object is needed, use the class method \"construct_from_file()\" instead. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. Raises: ValueError: if the \"mode\" is unknown. FileNotFoundError: if the file does not exist. \"\"\" if mode == \"csv\" : fn += \".csv\" array = np . loadtxt ( fn , dtype = np . float32 , delimiter = \",\" ) assert array . shape [ 1 ] == 37 l = array . shape [ 0 ] d = 18 ts = array [:, 0 : 1 ] data_and_variance = array [:, 1 :] data = data_and_variance [:, : d ] variance = data_and_variance [:, d :] elif mode == \"npy\" : fn += \".npy\" array = np . load ( fn ) assert array . dtype == np . float32 assert array . shape [ 1 ] == 37 l = array . shape [ 0 ] d = 18 ts = array [:, 0 : 1 ] data = array [:, 1 :( d + 1 )] variance = array [:, ( d + 1 ):] else : raise ValueError ( \"Unknown file mode %s !\" % mode ) assert d == 18 self . length = l self . dim = d self . ts = ts self . data = data self . variance = variance","title":"load_from_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.save_to_file","text":"General interface to save the template to a file. Parameters: Name Type Description Default fn string The file name (without the \".csv\" or \".npy\" extension). required mode string The file format, either \"raw_csv\", or \"raw_npy\". required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal.py def save_to_file ( self , fn , mode ): \"\"\"General interface to save the template to a file. Args: fn (string): The file name (without the \".csv\" or \".npy\" extension). mode (string): The file format, either \"raw_csv\", or \"raw_npy\". Returns: None: No return value. \"\"\" l = self . length array_tup = ( self . ts . reshape (( l , 1 )), self . data , self . variance ) array = np . concatenate ( array_tup , axis = 1 ) if mode == \"csv\" : fn += \".csv\" np . savetxt ( fn , array , fmt = \" %.6f \" , delimiter = \", \" ) elif mode == \"npy\" : assert array . dtype == np . float32 # NOTE: NumPy library add the \".npy\" file extension for us! np . save ( fn , array ) else : raise ValueError ( \"Unknown file mode %s !\" % mode )","title":"save_to_file()"},{"location":"fmsignal-reference/#fmsignal.FMSignalTemplate.update","text":"Update the template with a new signal. Parameters: Name Type Description Default new_signal FMSignal The new signal S used to update the template. required factor float The update factor, i.e., T_{new} = (1-factor) T_{old} + S factor. required Returns: Type Description None No return value. NOTE : The \"new_signal\" must be already aligned to the template. Source code in code_fmkit/fmsignal.py def update ( self , new_signal , factor ): \"\"\"Update the template with a new signal. Args: new_signal (FMSignal): The new signal S used to update the template. factor (float): The update factor, i.e., T_{new} = (1-factor)*T_{old} + S*factor. Returns: None: No return value. **NOTE**: The \"new_signal\" must be already aligned to the template. \"\"\" # update the signal template self . data = self . data * ( 1 - factor ) + new_signal . data * factor","title":"update()"},{"location":"fmsignal-reference/#fmsignal.dtw","text":"Dynamic Time Warping (DTW) on two multidimensional time series. SEE : Dynamic Time Warping NOTE : This is the python implementation. It iteratively accesses each element of the time series array, which could be very slow. Parameters: Name Type Description Default series_1 ndarray The first array, n-by-d numpy ndarray. required series_2 ndarray The second array, m-by-d numpy ndarray. required window int The window constraint, by default no constraint. 0 penalty float The misalign penalty, by default zero. 0 Returns: Type Description tuple A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Exceptions: Type Description ValueError If the input series have incompatible dimensions. Source code in code_fmkit/fmsignal.py def dtw ( series_1 , series_2 , window = 0 , penalty = 0 ): \"\"\"Dynamic Time Warping (DTW) on two multidimensional time series. **SEE**: [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) **NOTE**: This is the python implementation. It iteratively accesses each element of the time series array, which could be very slow. Args: series_1 (ndarray): The first array, n-by-d numpy ndarray. series_2 (ndarray): The second array, m-by-d numpy ndarray. window (int): The window constraint, by default no constraint. penalty (float): The misalign penalty, by default zero. Returns: tuple: A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Raises: ValueError: If the input series have incompatible dimensions. \"\"\" if not isinstance ( series_1 , np . ndarray ) \\ or not isinstance ( series_2 , np . ndarray ) \\ or len ( series_1 . shape ) != 2 or len ( series_2 . shape ) != 2 \\ or series_1 . dtype != np . float32 or series_2 . dtype != np . float32 : raise ValueError ( 'Input series must be l-by-d NumPy ndarrays!' ) n = series_1 . shape [ 0 ] m = series_2 . shape [ 0 ] d1 = series_1 . shape [ 1 ] d2 = series_2 . shape [ 1 ] if d1 != d2 : raise ValueError ( 'Input series must have the same dimension!' ) if series_1 . dtype != np . float32 or series_2 . dtype != np . float32 : raise ValueError ( 'Input series must have \"dtype == np.float32\"!' ) # NOTE: By default, the window is set to a sufficiently large value (m * 2) # to essentially remove the window constraint. if window <= 0 : window = m * 2 # These are the distance matrix and the direction table. dist_matrix = np . zeros (( n + 1 , m + 1 ), np . float32 ) direction = np . zeros (( n + 1 , m + 1 ), np . int32 ) # These are the index mapping to align series_2 to series_1. a2to1_start = np . zeros ( n , np . int32 ) a2to1_end = np . zeros ( n , np . int32 ) # These are the index mapping to align series_1 to series_2. a1to2_start = np . zeros ( m , np . int32 ) a1to2_end = np . zeros ( m , np . int32 ) # Initialization. dist_matrix . fill ( 1e6 ) dist_matrix [ 0 , 0 ] = 0 direction [ 0 , 0 ] = 0 #dist_matrix[:, 0] = 0 #dist_matrix[0, :] = 0 # find the warping path for i in range ( 1 , n + 1 ): jj = int ( float ( m ) / n * i ) start = jj - window if jj - window > 1 else 1 end = jj + window if jj + window < m + 1 else m + 1 for j in range ( start , end ): # CAUTION: series_1[0] and series_2[0] mapps to dists[1][1], # and i, j here are indexing dists instead of the series, # i.e., dists[i][j] is comparing series_1[i - 1] and series_2[j - 1] cost = np . linalg . norm ( series_1 [ i - 1 ] - series_2 [ j - 1 ]) min_dist = dist_matrix [ i - 1 , j - 1 ] direction [ i , j ] = 1 # 1 stands for diagonal if dist_matrix [ i - 1 , j ] + penalty < min_dist : min_dist = dist_matrix [ i - 1 , j ] + penalty direction [ i , j ] = 2 # 2 stands for the i direction if dist_matrix [ i ][ j - 1 ] + penalty < min_dist : min_dist = dist_matrix [ i ][ j - 1 ] + penalty direction [ i , j ] = 4 # 4 stands for the j direction dist_matrix [ i ][ j ] = cost + min_dist # trace back the warping path to find element-wise mapping # print('warping path done') a2to1_start [ n - 1 ] = m - 1 a2to1_end [ n - 1 ] = m - 1 a1to2_start [ m - 1 ] = n - 1 a1to2_end [ m - 1 ] = n - 1 i = n j = m while True : if direction [ i , j ] == 2 : # the i direction i -= 1 a2to1_start [ i - 1 ] = j - 1 a2to1_end [ i - 1 ] = j - 1 a1to2_start [ j - 1 ] = i - 1 elif direction [ i , j ] == 4 : # the j direction j -= 1 a1to2_start [ j - 1 ] = i - 1 a1to2_end [ j - 1 ] = i - 1 a2to1_start [ i - 1 ] = j - 1 elif direction [ i , j ] == 1 : # the diagonal direction i -= 1 j -= 1 if i == 0 and j == 0 : break a2to1_start [ i - 1 ] = j - 1 a2to1_end [ i - 1 ] = j - 1 a1to2_start [ j - 1 ] = i - 1 a1to2_end [ j - 1 ] = i - 1 else : # direction[i][j] == 0, the corner break series_2to1 = np . zeros ( series_1 . shape , series_1 . dtype ) for i , jj , kk in zip ( range ( n ), a2to1_start , a2to1_end ): if jj == kk : series_2to1 [ i ] = series_2 [ jj ] else : series_2to1 [ i ] = np . mean ( series_2 [ jj : kk + 1 , :], axis = 0 ) return dist_matrix [ n , m ], dist_matrix [ 1 :, 1 :], direction , \\ a2to1_start , a2to1_end , a1to2_start , a1to2_end , series_2to1","title":"dtw()"},{"location":"fmsignal-reference/#fmsignal.dtw_c","text":"Python wrapper of the Dynamic Time Warping (DTW) implemented in C. SEE : Dynamic Time Warping SEE : The \"fmkit_cutils\" package in this project has the implementation. NOTE : This is a Python wrapper of the C implementation, which is relative fast compared to the pure Python implementation. NOTE : The input series must have \"dtype == np.float32\". Parameters: Name Type Description Default series_1 ndarray The first array, n-by-d numpy ndarray. required series_2 ndarray The second array, m-by-d numpy ndarray. required window int The window constraint, by default no constraint. 0 penalty float The misalign penalty, by default zero. 0 Returns: Type Description tuple A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Exceptions: Type Description ValueError If the input series have incompatible dimensions. Source code in code_fmkit/fmsignal.py def dtw_c ( series_1 , series_2 , window = 0 , penalty = 0 ): \"\"\"Python wrapper of the Dynamic Time Warping (DTW) implemented in C. **SEE**: [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) **SEE**: The \"fmkit_cutils\" package in this project has the implementation. **NOTE**: This is a Python wrapper of the C implementation, which is relative fast compared to the pure Python implementation. **NOTE**: The input series must have \"dtype == np.float32\". Args: series_1 (ndarray): The first array, n-by-d numpy ndarray. series_2 (ndarray): The second array, m-by-d numpy ndarray. window (int, optional): The window constraint, by default no constraint. penalty (float, optional): The misalign penalty, by default zero. Returns: tuple: A tuple containing the following. int: The final DTW distance. ndarray: The (n + 1)-by-(m + 1) distance matrix. ndarray: The (n + 1)-by-(m + 1) direction matrix (warp path). ndarray: The alignment starting indices from 2 to 1. ndarray: The alignment ending indices from 2 to 1. ndarray: The alignment starting indices from 1 to 2. ndarray: The alignment ending indices from 1 to 2. ndarray: The generated time series by aligning 2 to 1. Raises: ValueError: If the input series have incompatible dimensions. \"\"\" if not isinstance ( series_1 , np . ndarray ) \\ or not isinstance ( series_2 , np . ndarray ) \\ or len ( series_1 . shape ) != 2 or len ( series_2 . shape ) != 2 : raise ValueError ( 'Input series must be l-by-d NumPy ndarrays!' ) n = series_1 . shape [ 0 ] m = series_2 . shape [ 0 ] d1 = series_1 . shape [ 1 ] d2 = series_2 . shape [ 1 ] if d1 != d2 : raise ValueError ( 'Input series must have the same dimension!' ) if series_1 . dtype != np . float32 or series_2 . dtype != np . float32 : raise ValueError ( 'Input series must have \"dtype == np.float32\"!' ) if window <= 0 : window = m * 2 # print('begin dtw_c()') # NOTE: It may be problematic to manage the memory and Python object # life-cycle in C code, and hence, we allocate space here in the wrapper. dist_matrix = np . zeros (( n + 1 , m + 1 ), np . float32 ) direction = np . zeros (( n + 1 , m + 1 ), np . int32 ) # These are the index mapping to align series_2 to series_1. a2to1_start = np . zeros ( n , np . int32 ) a2to1_end = np . zeros ( n , np . int32 ) # These are the index mapping to align series_1 to series_2. a1to2_start = np . zeros ( m , np . int32 ) a1to2_end = np . zeros ( m , np . int32 ) series_2to1 = np . zeros ( series_1 . shape , np . float32 ) # Initialization. dist_matrix . fill ( 1e6 ) dist = fmkit_utilities . dtw_c ( series_1 , series_2 , series_1 . shape [ 1 ], n , m , window , penalty , dist_matrix , direction , a2to1_start , a2to1_end , a1to2_start , a1to2_end , series_2to1 , ) # print('end dtw_c()') return dist , dist_matrix [ 1 :, 1 :], direction , \\ a2to1_start , a2to1_end , a1to2_start , a1to2_end , series_2to1","title":"dtw_c()"},{"location":"fmsignal-reference/#fmsignal.normalize_warping_path_a2to1","text":"Normalize the warping path from l2-by-l1 to n-by-n. Parameters: Name Type Description Default a2to1_start ndarray The alignment starting indices from 2 to 1. required a2to1_end ndarray The alignment ending indices from 2 to 1. required n int The size of the warping path after normalization. 100 Returns: Type Description (ndarray) The \"a2to1_start\" after normalization. (ndarray): The \"a2to1_end\" after normalization. Exceptions: Type Description ValueError If the input arrays have wrong type or value. Source code in code_fmkit/fmsignal.py def normalize_warping_path_a2to1 ( a2to1_start , a2to1_end , n = 100 ): \"\"\"Normalize the warping path from l2-by-l1 to n-by-n. Args: a2to1_start (ndarray): The alignment starting indices from 2 to 1. a2to1_end (ndarray): The alignment ending indices from 2 to 1. n (int): The size of the warping path after normalization. Returns: (ndarray): The \"a2to1_start\" after normalization. (ndarray): The \"a2to1_end\" after normalization. Raises: ValueError: If the input arrays have wrong type or value. \"\"\" if not isinstance ( a2to1_start , np . ndarray ) \\ or not isinstance ( a2to1_end , np . ndarray ) \\ or len ( a2to1_start . shape ) != 1 or len ( a2to1_end . shape ) != 1 \\ or a2to1_start . dtype != np . int or a2to1_end . dtype != np . int : raise ValueError ( 'Input series must be two 1D NumPy arrays!' ) assert a2to1_start . shape [ 0 ] == a2to1_end . shape [ 0 ] assert np . all (( a2to1_end - a2to1_start ) >= 0 ) assert n > 0 l1 = a2to1_start . shape [ 0 ] l2 = a2to1_end [ - 1 ] xp = np . arange ( l1 ) x_n = np . linspace ( 0 , l1 - 1 , n ) a2to1_start_n = np . interp ( x_n , xp , a2to1_start ) a2to1_start_n = a2to1_start_n / l2 * ( n - 1 ) a2to1_end_n = np . interp ( x_n , xp , a2to1_end ) a2to1_end_n = a2to1_end_n / l2 * ( n - 1 ) return a2to1_start_n . astype ( np . int32 ), a2to1_end_n . astype ( np . int32 )","title":"normalize_warping_path_a2to1()"},{"location":"fmsignal-reference/#fmsignal.warping_path_to_xy_sequences","text":"Convert the warping path from alignment indices to xy coordinates. Parameters: Name Type Description Default a2to1_start ndarray The alignment starting indices from 2 to 1. required a2to1_end ndarray The alignment ending indices from 2 to 1. required Returns: Type Description (list) The x coordinates. (list): The y coordinates. Exceptions: Type Description ValueError If the input arrays have wrong type or value. Source code in code_fmkit/fmsignal.py def warping_path_to_xy_sequences ( a2to1_start , a2to1_end ): \"\"\"Convert the warping path from alignment indices to xy coordinates. Args: a2to1_start (ndarray): The alignment starting indices from 2 to 1. a2to1_end (ndarray): The alignment ending indices from 2 to 1. Returns: (list): The x coordinates. (list): The y coordinates. Raises: ValueError: If the input arrays have wrong type or value. \"\"\" if not isinstance ( a2to1_start , np . ndarray ) \\ or not isinstance ( a2to1_end , np . ndarray ) \\ or len ( a2to1_start . shape ) != 1 or len ( a2to1_end . shape ) != 1 \\ or a2to1_start . dtype != np . int or a2to1_end . dtype != np . int : raise ValueError ( 'Input series must be two 1D NumPy arrays!' ) assert a2to1_start . shape [ 0 ] == a2to1_end . shape [ 0 ] assert np . all (( a2to1_end - a2to1_start ) >= 0 ) xs = [] ys = [] for i , ( start , end ) in enumerate ( zip ( a2to1_start , a2to1_end )): for j in range ( start , end + 1 ): xs . append ( i ) ys . append ( j ) #print(i, j, start, end) return xs , ys","title":"warping_path_to_xy_sequences()"},{"location":"fmsignal_vis-reference/","text":"fmsignal module This module contains the visuzlaization code of the fmkit framework, which is designed to facilitate researches on in-air-handwriting related research. Author: Duo Lu < duolu.cs@gmail.com > Version: 0.1 License: MIT Updated on Feb. 7, 2020, version 0.1 Created on Aug 14, 2017, draft The MIT License Copyright 2017-2021 Duo Lu < duolu.cs@gmail.com > Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. alignment_vis ( signal , template , aligned_signal , plot_3d = False , col = 0 ) Visualize the warping path and DTW distance matrix of an aligned signal. Parameters: Name Type Description Default signal FMSignal The signal that is aligned to the template. required template FMSignal The template. required aligned_signal FMSignal The aligned signal. required plot_3d bool Indicating whether the plot is in 3D or in 2D. False col int Indicating the sensor axis to be plotted. 0 Returns: Type Description None No return value. NOTE : The \"aligned_signal\" must have the \"dist_matrix\" attribute and the two attributes for the warping path (i.e., \"a2to1_start\" and \"a2to1_end\"). This means when the \"aligned_signal\" is generated by calling the \"align_to()\", the \"keep_dist_matrix\" parameter must be set to \"True\". Source code in code_fmkit/fmsignal_vis.py def alignment_vis ( signal , template , aligned_signal , plot_3d = False , col = 0 ): '''Visualize the warping path and DTW distance matrix of an aligned signal. Args: signal (FMSignal): The signal that is aligned to the template. template (FMSignal): The template. aligned_signal (FMSignal): The aligned signal. plot_3d (bool): Indicating whether the plot is in 3D or in 2D. col (int): Indicating the sensor axis to be plotted. Returns: None: No return value. **NOTE**: The \"aligned_signal\" must have the \"dist_matrix\" attribute and the two attributes for the warping path (i.e., \"a2to1_start\" and \"a2to1_end\"). This means when the \"aligned_signal\" is generated by calling the \"align_to()\", the \"keep_dist_matrix\" parameter must be set to \"True\". ''' # NOTE: Make a copy of \"dist_matrix\" in case we want to modify it. dist_matrix = aligned_signal . dist_matrix . copy () a2to1_start = aligned_signal . a2to1_start a2to1_end = aligned_signal . a2to1_end # Normalize dists_matrix to [0, 1] manually dmin = np . amin ( dist_matrix ) dmax = np . amax ( dist_matrix ) delta = dmax - dmin dist_matrix = ( dist_matrix - dmin ) / delta # n is the length of the template. n = dist_matrix . shape [ 0 ] # m is the length of the signal. m = dist_matrix . shape [ 1 ] fig = plt . figure ( figsize = ( 8 , 8 )) if plot_3d : ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) xs , ys = np . meshgrid ( np . arange ( 0 , n ), np . arange ( 0 , m )) zs = dist_matrix . T surf = ax . plot_surface ( xs , ys , zs , cmap = cm . coolwarm , linewidth = 0 , antialiased = False ) ax . set_xlabel ( 'template' ) ax . set_ylabel ( 'signal' ) ax . set_zlabel ( 'distance' ) else : # Mark the warping path. for i in range ( len ( a2to1_start )): for j in range ( a2to1_start [ i ], a2to1_end [ i ] + 1 ): dist_matrix [ i ][ j ] = 1 ax = fig . add_axes ([ 0.3 , 0.3 , 0.6 , 0.6 ]) ax . set_axis_off () ax_s = fig . add_axes ([ 0.1 , 0.3 , 0.2 , 0.6 ]) ax_t = fig . add_axes ([ 0.3 , 0.1 , 0.6 , 0.2 ]) s_col = signal . data [:, col ] t_col = template . data [:, col ] dmax = max ( np . max ( s_col ), np . max ( t_col )) dmin = min ( np . min ( s_col ), np . min ( t_col )) dist = max ( abs ( dmax ), abs ( dmin )) * 1.2 ax_s . plot ( s_col , range ( m )) ax_t . plot ( range ( n ), t_col ) ax_s . set_xlim ( - dist , dist ) ax_s . set_ylim ( 0 , m ) ax_t . set_ylim ( - dist , dist ) ax_t . set_xlim ( 0 , n ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax_s . spines [ axis ] . set_linewidth ( 1 ) ax_s . spines [ axis ] . set_color ( COLORS [ col // 3 ]) ax_t . spines [ axis ] . set_linewidth ( 1 ) ax_t . spines [ axis ] . set_color ( COLORS [ col // 3 ]) major_ticks = np . arange ( 0 , m , 20 ) ax_s . set_yticks ( major_ticks ) major_ticks = np . arange ( 0 , n , 20 ) ax_t . set_xticks ( major_ticks ) ax_s . grid () ax_t . grid () ax . imshow ( dist_matrix . T , origin = 'lower' , aspect = 'auto' ) ax_s . set_ylabel ( 'signal' ) ax_t . set_xlabel ( 'template' ) #major_ticks = np.arange(0, 60, 20) #ax.set_xticks(major_ticks) #ax.set_xticklabels([0, 1, 2, 5]) #ax.set_aspect('equal') #ax.set_xticks([0, 5]) plt . show () orientation_animation ( signal , speed = 1 , seg_length =- 1 ) Animate the orientation of the tracked point. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required speed float Indicating the animation speed. \"speed=1\" is 1x. 1 seg_length int The animated segment length in number of samples. -1 Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def orientation_animation ( signal , speed = 1 , seg_length =- 1 ): '''Animate the orientation of the tracked point. Args: signal (FMSignal): The signal to be visualized. speed (float): Indicating the animation speed. \"speed=1\" is 1x. seg_length (int): The animated segment length in number of samples. Returns: None: No return value. ''' if isinstance ( signal , FMSignal ) : rotms , _qs = signal . get_orientation () elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): rotms = signal . rotms else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) matplotlib . interactive ( True ) fig = plt . figure ( figsize = ( 8 , 8 )) ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) l = signal . length scale = 100 lim = scale * 1.2 xv = np . asarray (( scale , 0 , 0 ), np . float32 ) . reshape (( 3 , 1 )) points_x = np . zeros (( l , 3 )) for i in range ( l ): R = rotms [ i ] xv_R = np . matmul ( R , xv ) points_x [ i ] = xv_R [:, 0 ] ox = points_x [:, 0 ] oy = points_x [:, 1 ] oz = points_x [:, 2 ] for i in range ( l ): # speed up by subsampling if speed > 1 and i % int ( round ( speed )) != 0 : continue ax . clear () if seg_length <= 0 : s = 0 else : s = i - seg_length if s < 0 : s = 0 ax . plot ( ox [ s : i ], oy [ s : i ], oz [ s : i ], color = 'k' , markersize = 0.1 ) R = rotms [ i ] t = np . asarray (( 0 , 0 , 0 )) . reshape (( 3 , 1 )) plot_xyz_axes ( ax , R , t , scale = scale ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) if i == 1 : plt . pause ( 1 ) else : plt . pause ( 0.001 ) if speed < 1 : plt . pause ( 0.02 / speed ) matplotlib . interactive ( False ) ax . plot ( ox , oy , oz , color = 'k' , markersize = 0.1 ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) fig . canvas . draw () plt . show () plot_handgeo ( ax , signal , i ) Plot the skeleton shape of the hand. Parameters: Name Type Description Default signal FMSignalLeap The raw signal containing the \"joints\". required i int required Returns: Type Description None No return value. NOTE : This is designed for internal usage only. Source code in code_fmkit/fmsignal_vis.py def plot_handgeo ( ax , signal , i ): '''Plot the skeleton shape of the hand. Args: signal (FMSignalLeap): The raw signal containing the \"joints\". i (int): Returns: None: No return value. **NOTE**: This is designed for internal usage only. ''' joints = signal . joints [ i ] x1 = [] y1 = [] z1 = [] # Set up hand skeleton points. for j in range ( 5 ): for k in range ( 5 ): x1 . append ( joints [ j ][ k ][ 0 ]) y1 . append ( joints [ j ][ k ][ 1 ]) z1 . append ( joints [ j ][ k ][ 2 ]) for k in range ( 4 , - 1 , - 1 ): x1 . append ( joints [ j ][ k ][ 0 ]) y1 . append ( joints [ j ][ k ][ 1 ]) z1 . append ( joints [ j ][ k ][ 2 ]) ax . plot ( x1 , y1 , z1 , color = 'b' , markersize = 0.2 ) plot_xyz_axes ( ax , R , t , scale = 1 ) Plot three line segments representing the x-y-z axes. Parameters: Name Type Description Default ax Axes in matplotlib The axes object to plot. required R 3-by-3 ndarray The rotation matrix (local to world). required t 3-by-1 ndarray The translation vector (local to world). required scale float The length of the line segment. 1 Returns: Type Description None No return value. NOTE : This is designed for internal usage only. Source code in code_fmkit/fmsignal_vis.py def plot_xyz_axes ( ax , R , t , scale = 1 ): '''Plot three line segments representing the x-y-z axes. Args: ax (Axes in matplotlib): The axes object to plot. R (3-by-3 ndarray): The rotation matrix (local to world). t (3-by-1 ndarray): The translation vector (local to world). scale (float): The length of the line segment. Returns: None: No return value. **NOTE**: This is designed for internal usage only. ''' x_axis_local = np . asarray ([[ 0 , 0 , 0 ], [ scale , 0 , 0 ]]) . T x_axis = np . matmul ( R , x_axis_local ) + t y_axis_local = np . asarray ([[ 0 , 0 , 0 ], [ 0 , scale , 0 ]]) . T y_axis = np . matmul ( R , y_axis_local ) + t z_axis_local = np . asarray ([[ 0 , 0 , 0 ], [ 0 , 0 , scale ]]) . T z_axis = np . matmul ( R , z_axis_local ) + t ax . plot ( x_axis [ 0 , :], x_axis [ 1 , :], x_axis [ 2 , :], color = 'r' ) ax . plot ( y_axis [ 0 , :], y_axis [ 1 , :], y_axis [ 2 , :], color = 'g' ) ax . plot ( z_axis [ 0 , :], z_axis [ 1 , :], z_axis [ 2 , :], color = 'b' ) signal_vis ( signal , start_col = 0 , nr_cols = 18 , normalized = False ) Visualize a preprocessed signal by plotting the specified columns. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required start_col int The start index of the sensor axes on the plot. 0 nr_cols int The number of sensor axes on the plot. 18 normalized bool Indicating whether the amplitude of the signal is normalized or not. False Returns: Type Description None No return value. NOTE : Both \"nr_cols\" and \"start_col\" must be a multiple of 3. Source code in code_fmkit/fmsignal_vis.py def signal_vis ( signal , start_col = 0 , nr_cols = 18 , normalized = False ): '''Visualize a preprocessed signal by plotting the specified columns. Args: signal (FMSignal): The signal to be visualized. start_col (int): The start index of the sensor axes on the plot. nr_cols (int): The number of sensor axes on the plot. normalized (bool): Indicating whether the amplitude of the signal is normalized or not. Returns: None: No return value. **NOTE**: Both \"nr_cols\" and \"start_col\" must be a multiple of 3. ''' d = signal . dim assert isinstance ( signal , FMSignal ) assert nr_cols % 3 == 0 and start_col % 3 == 0 assert start_col < d and start_col + nr_cols <= d fig = plt . figure () axes = [] l = signal . length for ii , i in enumerate ( range ( start_col , start_col + nr_cols )): data_column = signal . data [:, i ] ax = fig . add_subplot ( nr_cols , 1 , ii + 1 ) ax . plot ( data_column , color = 'k' ) if normalized : ax . set_ylim ( - 3.5 , 3.5 ) else : ymax = np . max ( data_column ) ymin = np . min ( data_column ) dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax . set_ylim ( ylim_min , ylim_max ) ax . set_xlim ( 0 , l ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax . spines [ axis ] . set_linewidth ( 1 ) ax . spines [ axis ] . set_color ( COLORS [ i // 3 ]) major_ticks = np . arange ( 0 , l , 20 ) ax . set_xticks ( major_ticks ) ax . grid () #ax.tick_params(colors='w') axes . append ( ax ) plt . show () signal_vis_compact ( signal , normalized = False ) Visualize a signal by plotting three columns together. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required normalized bool Indicating whether the amplitude of the signal is normalized or not. False Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def signal_vis_compact ( signal , normalized = False ): '''Visualize a signal by plotting three columns together. Args: signal (FMSignal): The signal to be visualized. normalized (bool): Indicating whether the amplitude of the signal is normalized or not. Returns: None: No return value. ''' assert isinstance ( signal , FMSignal ) fig = plt . figure () axes = [] l = signal . length d = signal . dim n = d // 3 for i in range ( n ): ax = fig . add_subplot ( n , 1 , i + 1 ) data_x = signal . data [:, i * 3 + 0 ] data_y = signal . data [:, i * 3 + 1 ] data_z = signal . data [:, i * 3 + 2 ] ax . plot ( data_x , c = 'r' ) ax . plot ( data_y , c = 'g' ) ax . plot ( data_z , c = 'b' ) data_x_max = np . max ( data_x ) data_x_min = np . min ( data_x ) data_y_max = np . max ( data_y ) data_y_min = np . min ( data_y ) data_z_max = np . max ( data_z ) data_z_min = np . min ( data_z ) if normalized : ax . set_ylim ( - 3.5 , 3.5 ) else : ymax = max ( data_x_max , data_y_max , data_z_max ) ymin = min ( data_x_min , data_y_min , data_z_min ) dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax . set_ylim ( ylim_min , ylim_max ) ax . set_xlim ( 0 , l ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax . spines [ axis ] . set_linewidth ( 1 ) ax . spines [ axis ] . set_color ( COLORS [ i ]) #ax.get_xaxis().set_visible(False) #ax.get_yaxis().set_visible(False) major_ticks = np . arange ( 0 , l , 20 ) ax . set_xticks ( major_ticks ) ax . grid () #ax.tick_params(color='w') axes . append ( ax ) plt . show () signal_vis_comparison ( signals , start_col = 0 , nr_cols = 18 , normalized = False ) Visualize multiple signals on the same plot. Parameters: Name Type Description Default signals FMSignal The signals to be visualized. required start_col int The start index of the sensor axes on the plot. 0 nr_cols int The number of sensor axes on the plot. 18 normalized bool Indicating whether the amplitudes of all signals are normalized or not. False Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def signal_vis_comparison ( signals , start_col = 0 , nr_cols = 18 , normalized = False ): '''Visualize multiple signals on the same plot. Args: signals (FMSignal): The signals to be visualized. start_col (int): The start index of the sensor axes on the plot. nr_cols (int): The number of sensor axes on the plot. normalized (bool): Indicating whether the amplitudes of all signals are normalized or not. Returns: None: No return value. ''' assert len ( signals ) > 0 for signal in signals : assert isinstance ( signal , FMSignal ) fig = plt . figure () axes = [] lmax = - 1e6 for signal in signals : if signal . length > lmax : lmax = signal . length for ii , i in enumerate ( range ( start_col , start_col + nr_cols )): ax = fig . add_subplot ( nr_cols , 1 , ii + 1 ) ymax = - 1e6 ymin = 1e6 for j , signal in enumerate ( signals ): data_column = signal . data [:, i ] ax . plot ( data_column ) data_column_max = np . max ( data_column ) if data_column_max > ymax : ymax = data_column_max data_column_min = np . min ( data_column ) if data_column_min < ymin : ymin = data_column_min if normalized : ax . set_ylim ( - 3.5 , 3.5 ) else : dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax . set_ylim ( ylim_min , ylim_max ) ax . set_xlim ( 0 , lmax ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax . spines [ axis ] . set_linewidth ( 1 ) ax . spines [ axis ] . set_color ( COLORS [ i // 3 ]) major_ticks = np . arange ( 0 , lmax , 20 ) ax . set_xticks ( major_ticks ) ax . grid () axes . append ( ax ) plt . show () signal_vis_comparison_side_by_side ( signals_0 , signals_1 , start_col = 0 , nr_cols = 18 , normalized = False ) Visualize multiple signals on the same plot. Parameters: Name Type Description Default signals_0 FMSignal The first set of signals to be visualized. required signals_1 FMSignal The second set of signals to be visualized. required start_col int The start index of the sensor axes on the plot. 0 nr_cols int The number of sensor axes on the plot. 18 normalized bool Indicating whether the amplitudes of all signals are normalized or not. False Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def signal_vis_comparison_side_by_side ( signals_0 , signals_1 , start_col = 0 , nr_cols = 18 , normalized = False ): '''Visualize multiple signals on the same plot. Args: signals_0 (FMSignal): The first set of signals to be visualized. signals_1 (FMSignal): The second set of signals to be visualized. start_col (int): The start index of the sensor axes on the plot. nr_cols (int): The number of sensor axes on the plot. normalized (bool): Indicating whether the amplitudes of all signals are normalized or not. Returns: None: No return value. ''' assert len ( signals_0 ) > 0 and len ( signals_1 ) for signal in signals_0 : assert isinstance ( signal , FMSignal ) for signal in signals_1 : assert isinstance ( signal , FMSignal ) fig = plt . figure () axes_left = [] axes_right = [] lmax = - 1e6 for signal in signals_0 : if signal . length > lmax : lmax = signal . length for signal in signals_1 : if signal . length > lmax : lmax = signal . length for ii , i in enumerate ( range ( start_col , start_col + nr_cols )): ax_left = fig . add_subplot ( nr_cols , 2 , 2 * ii + 1 ) ax_right = fig . add_subplot ( nr_cols , 2 , 2 * ii + 2 ) ymax = - 1e6 ymin = 1e6 for signal_0 in signals_0 : d0 = signal_0 . data [:, i ] ax_left . plot ( d0 ) d_max = np . max ( d0 ) if d_max > ymax : ymax = d_max d_min = np . min ( d0 ) if d_min < ymin : ymin = d_min for signal_1 in signals_1 : d1 = signal_1 . data [:, i ] ax_right . plot ( d1 ) d_max = np . max ( d1 ) if d_max > ymax : ymax = d_max d_min = np . min ( d1 ) if d_min < ymin : ymin = d_min if normalized : ax_left . set_ylim ( - 3.5 , 3.5 ) ax_right . set_ylim ( - 3.5 , 3.5 ) else : dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax_left . set_ylim ( ylim_min , ylim_max ) ax_right . set_ylim ( ylim_min , ylim_max ) ax_left . set_xlim ( 0 , lmax ) ax_right . set_xlim ( 0 , lmax ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax_left . spines [ axis ] . set_linewidth ( 1 ) ax_left . spines [ axis ] . set_color ( COLORS [ i // 3 ]) ax_right . spines [ axis ] . set_linewidth ( 1 ) ax_right . spines [ axis ] . set_color ( COLORS [ i // 3 ]) major_ticks = np . arange ( 0 , lmax , 20 ) ax_left . set_xticks ( major_ticks ) ax_right . set_xticks ( major_ticks ) ax_left . grid () ax_right . grid () axes_left . append ( ax_left ) axes_right . append ( ax_right ) plt . show () trajectorie_vis_comparison ( signals ) Visualize multiple trajectories in the same plot. Parameters: Name Type Description Default signals list The list of signals to visualize. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def trajectorie_vis_comparison ( signals ): '''Visualize multiple trajectories in the same plot. Args: signals (list): The list of signals to visualize. Returns: None: No return value. ''' fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) dist_max = - 1e6 for signal in signals : if isinstance ( signal , FMSignal ) : trajectory = signal . data [:, 0 : 3 ] elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): trajectory = signal . trajectory assert trajectory is not None else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) tx = trajectory [:, 0 ] ty = trajectory [:, 1 ] tz = trajectory [:, 2 ] tx_max = np . max ( tx ) tx_min = np . min ( tx ) ty_max = np . max ( ty ) ty_min = np . min ( ty ) tz_max = np . max ( tz ) tz_min = np . min ( tz ) dx = max ( abs ( tx_max ), abs ( tx_min )) dy = max ( abs ( ty_max ), abs ( ty_min )) dz = max ( abs ( tz_max ), abs ( tz_min )) dist = max ( dx , dy , dz ) if dist > dist_max : dist_max = dist l = signal . length ax . plot ( tx , ty , tz , markersize = 0.1 ) lim = dist_max * 1.2 ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) #plt.axis('equal') plt . show () trajectory_animation ( signal , speed = 1 , seg_length =- 1 , show_hand = False ) Animate the signal trajectory in 3D. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required speed float Indicating the animation speed. \"speed=1\" is 1x. 1 seg_length int The animated segment length in number of samples. -1 show_hand bool Indicating whether the hand geometry is shown. False Returns: Type Description None No return value. NOTE : The \"speed\" can be either a fraction number between 0 and 1, which means slow down, or integers greater than 1, which means speed up. If it is greater than 1 and it is not an integer, it is rounded to the closest integer. Source code in code_fmkit/fmsignal_vis.py def trajectory_animation ( signal , speed = 1 , seg_length =- 1 , show_hand = False ): '''Animate the signal trajectory in 3D. Args: signal (FMSignal): The signal to be visualized. speed (float): Indicating the animation speed. \"speed=1\" is 1x. seg_length (int): The animated segment length in number of samples. show_hand (bool): Indicating whether the hand geometry is shown. Returns: None: No return value. **NOTE**: The \"speed\" can be either a fraction number between 0 and 1, which means slow down, or integers greater than 1, which means speed up. If it is greater than 1 and it is not an integer, it is rounded to the closest integer. ''' if isinstance ( signal , FMSignal ) : trajectory = signal . data [:, 0 : 3 ] elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): trajectory = signal . trajectory assert trajectory is not None else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) matplotlib . interactive ( True ) fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) tx = trajectory [:, 0 ] ty = trajectory [:, 1 ] tz = trajectory [:, 2 ] tx_max = np . max ( tx ) tx_min = np . min ( tx ) ty_max = np . max ( ty ) ty_min = np . min ( ty ) tz_max = np . max ( tz ) tz_min = np . min ( tz ) dx = max ( abs ( tx_max ), abs ( tx_min )) dy = max ( abs ( ty_max ), abs ( ty_min )) dz = max ( abs ( tz_max ), abs ( tz_min )) dist = max ( dx , dy , dz ) lim = dist * 1.2 l = signal . length for i in range ( 1 , l ): # speed up by subsampling if speed > 1 and i % int ( round ( speed )) != 0 : continue ax . clear () if seg_length <= 0 : s = 0 else : s = i - seg_length if s < 0 : s = 0 # ax.plot(data[0:i, 0], data[0:i, 1], data[0:i, 2], # color='k', markersize=0.2) ax . plot ( tx [ s : i ], ty [ s : i ], tz [ s : i ], color = 'k' , markersize = 0.1 ) if isinstance ( signal , FMSignalLeap ) and show_hand : plot_handgeo ( ax , signal , i ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) if i == 1 : plt . pause ( 1 ) else : plt . pause ( 0.001 ) if speed < 1 : plt . pause ( 0.02 / speed ) matplotlib . interactive ( False ) ax . plot ( tx , ty , tz , color = 'k' , markersize = 0.1 ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) fig . canvas . draw () plt . show () trajectory_vis ( signal , show_local_axes = False , interval = 10 ) Visualize the signal as the trajectory of a point in 3D. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required show_local_axes bool Indicating whether the orientation is shown. False interval int Indicating how many samples to plot the orientation x-y-z axes once. 10 Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def trajectory_vis ( signal , show_local_axes = False , interval = 10 ): '''Visualize the signal as the trajectory of a point in 3D. Args: signal (FMSignal): The signal to be visualized. show_local_axes (bool): Indicating whether the orientation is shown. interval (int): Indicating how many samples to plot the orientation x-y-z axes once. Returns: None: No return value. ''' if isinstance ( signal , FMSignal ) : trajectory = signal . data [:, 0 : 3 ] rotms , _qs = signal . get_orientation () elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): trajectory = signal . trajectory rotms = signal . rotms assert trajectory is not None and rotms is not None else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) tx = trajectory [:, 0 ] ty = trajectory [:, 1 ] tz = trajectory [:, 2 ] tx_max = np . max ( tx ) tx_min = np . min ( tx ) ty_max = np . max ( ty ) ty_min = np . min ( ty ) tz_max = np . max ( tz ) tz_min = np . min ( tz ) dx = max ( abs ( tx_max ), abs ( tx_min )) dy = max ( abs ( ty_max ), abs ( ty_min )) dz = max ( abs ( tz_max ), abs ( tz_min )) dist = max ( dx , dy , dz ) lim = dist * 1.2 l = signal . length ax . plot ( tx , ty , tz , color = 'k' , markersize = 0.1 ) if show_local_axes : for i in range ( 0 , l , interval ): R = rotms [ i ] t = trajectory [ i ] . reshape (( 3 , 1 )) plot_xyz_axes ( ax , R , t , lim / 10 ) ax . tick_params ( color = 'w' ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) # ax.zaxis.set_major_locator(plt.NullLocator()) # ax.yaxis.set_major_locator(plt.NullLocator()) # ax.xaxis.set_major_locator(plt.NullLocator()) # ax.zaxis.set_major_formatter(plt.NullFormatter()) # ax.yaxis.set_major_formatter(plt.NullFormatter()) # ax.xaxis.set_major_formatter(plt.NullFormatter()) plt . show ()","title":"fmsignal_vis"},{"location":"fmsignal_vis-reference/#fmsignal-module","text":"","title":"fmsignal module"},{"location":"fmsignal_vis-reference/#fmsignal_vis","text":"This module contains the visuzlaization code of the fmkit framework, which is designed to facilitate researches on in-air-handwriting related research. Author: Duo Lu < duolu.cs@gmail.com > Version: 0.1 License: MIT Updated on Feb. 7, 2020, version 0.1 Created on Aug 14, 2017, draft The MIT License Copyright 2017-2021 Duo Lu < duolu.cs@gmail.com > Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"fmsignal_vis"},{"location":"fmsignal_vis-reference/#fmsignal_vis.alignment_vis","text":"Visualize the warping path and DTW distance matrix of an aligned signal. Parameters: Name Type Description Default signal FMSignal The signal that is aligned to the template. required template FMSignal The template. required aligned_signal FMSignal The aligned signal. required plot_3d bool Indicating whether the plot is in 3D or in 2D. False col int Indicating the sensor axis to be plotted. 0 Returns: Type Description None No return value. NOTE : The \"aligned_signal\" must have the \"dist_matrix\" attribute and the two attributes for the warping path (i.e., \"a2to1_start\" and \"a2to1_end\"). This means when the \"aligned_signal\" is generated by calling the \"align_to()\", the \"keep_dist_matrix\" parameter must be set to \"True\". Source code in code_fmkit/fmsignal_vis.py def alignment_vis ( signal , template , aligned_signal , plot_3d = False , col = 0 ): '''Visualize the warping path and DTW distance matrix of an aligned signal. Args: signal (FMSignal): The signal that is aligned to the template. template (FMSignal): The template. aligned_signal (FMSignal): The aligned signal. plot_3d (bool): Indicating whether the plot is in 3D or in 2D. col (int): Indicating the sensor axis to be plotted. Returns: None: No return value. **NOTE**: The \"aligned_signal\" must have the \"dist_matrix\" attribute and the two attributes for the warping path (i.e., \"a2to1_start\" and \"a2to1_end\"). This means when the \"aligned_signal\" is generated by calling the \"align_to()\", the \"keep_dist_matrix\" parameter must be set to \"True\". ''' # NOTE: Make a copy of \"dist_matrix\" in case we want to modify it. dist_matrix = aligned_signal . dist_matrix . copy () a2to1_start = aligned_signal . a2to1_start a2to1_end = aligned_signal . a2to1_end # Normalize dists_matrix to [0, 1] manually dmin = np . amin ( dist_matrix ) dmax = np . amax ( dist_matrix ) delta = dmax - dmin dist_matrix = ( dist_matrix - dmin ) / delta # n is the length of the template. n = dist_matrix . shape [ 0 ] # m is the length of the signal. m = dist_matrix . shape [ 1 ] fig = plt . figure ( figsize = ( 8 , 8 )) if plot_3d : ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) xs , ys = np . meshgrid ( np . arange ( 0 , n ), np . arange ( 0 , m )) zs = dist_matrix . T surf = ax . plot_surface ( xs , ys , zs , cmap = cm . coolwarm , linewidth = 0 , antialiased = False ) ax . set_xlabel ( 'template' ) ax . set_ylabel ( 'signal' ) ax . set_zlabel ( 'distance' ) else : # Mark the warping path. for i in range ( len ( a2to1_start )): for j in range ( a2to1_start [ i ], a2to1_end [ i ] + 1 ): dist_matrix [ i ][ j ] = 1 ax = fig . add_axes ([ 0.3 , 0.3 , 0.6 , 0.6 ]) ax . set_axis_off () ax_s = fig . add_axes ([ 0.1 , 0.3 , 0.2 , 0.6 ]) ax_t = fig . add_axes ([ 0.3 , 0.1 , 0.6 , 0.2 ]) s_col = signal . data [:, col ] t_col = template . data [:, col ] dmax = max ( np . max ( s_col ), np . max ( t_col )) dmin = min ( np . min ( s_col ), np . min ( t_col )) dist = max ( abs ( dmax ), abs ( dmin )) * 1.2 ax_s . plot ( s_col , range ( m )) ax_t . plot ( range ( n ), t_col ) ax_s . set_xlim ( - dist , dist ) ax_s . set_ylim ( 0 , m ) ax_t . set_ylim ( - dist , dist ) ax_t . set_xlim ( 0 , n ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax_s . spines [ axis ] . set_linewidth ( 1 ) ax_s . spines [ axis ] . set_color ( COLORS [ col // 3 ]) ax_t . spines [ axis ] . set_linewidth ( 1 ) ax_t . spines [ axis ] . set_color ( COLORS [ col // 3 ]) major_ticks = np . arange ( 0 , m , 20 ) ax_s . set_yticks ( major_ticks ) major_ticks = np . arange ( 0 , n , 20 ) ax_t . set_xticks ( major_ticks ) ax_s . grid () ax_t . grid () ax . imshow ( dist_matrix . T , origin = 'lower' , aspect = 'auto' ) ax_s . set_ylabel ( 'signal' ) ax_t . set_xlabel ( 'template' ) #major_ticks = np.arange(0, 60, 20) #ax.set_xticks(major_ticks) #ax.set_xticklabels([0, 1, 2, 5]) #ax.set_aspect('equal') #ax.set_xticks([0, 5]) plt . show ()","title":"alignment_vis()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.orientation_animation","text":"Animate the orientation of the tracked point. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required speed float Indicating the animation speed. \"speed=1\" is 1x. 1 seg_length int The animated segment length in number of samples. -1 Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def orientation_animation ( signal , speed = 1 , seg_length =- 1 ): '''Animate the orientation of the tracked point. Args: signal (FMSignal): The signal to be visualized. speed (float): Indicating the animation speed. \"speed=1\" is 1x. seg_length (int): The animated segment length in number of samples. Returns: None: No return value. ''' if isinstance ( signal , FMSignal ) : rotms , _qs = signal . get_orientation () elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): rotms = signal . rotms else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) matplotlib . interactive ( True ) fig = plt . figure ( figsize = ( 8 , 8 )) ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) l = signal . length scale = 100 lim = scale * 1.2 xv = np . asarray (( scale , 0 , 0 ), np . float32 ) . reshape (( 3 , 1 )) points_x = np . zeros (( l , 3 )) for i in range ( l ): R = rotms [ i ] xv_R = np . matmul ( R , xv ) points_x [ i ] = xv_R [:, 0 ] ox = points_x [:, 0 ] oy = points_x [:, 1 ] oz = points_x [:, 2 ] for i in range ( l ): # speed up by subsampling if speed > 1 and i % int ( round ( speed )) != 0 : continue ax . clear () if seg_length <= 0 : s = 0 else : s = i - seg_length if s < 0 : s = 0 ax . plot ( ox [ s : i ], oy [ s : i ], oz [ s : i ], color = 'k' , markersize = 0.1 ) R = rotms [ i ] t = np . asarray (( 0 , 0 , 0 )) . reshape (( 3 , 1 )) plot_xyz_axes ( ax , R , t , scale = scale ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) if i == 1 : plt . pause ( 1 ) else : plt . pause ( 0.001 ) if speed < 1 : plt . pause ( 0.02 / speed ) matplotlib . interactive ( False ) ax . plot ( ox , oy , oz , color = 'k' , markersize = 0.1 ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) fig . canvas . draw () plt . show ()","title":"orientation_animation()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.plot_handgeo","text":"Plot the skeleton shape of the hand. Parameters: Name Type Description Default signal FMSignalLeap The raw signal containing the \"joints\". required i int required Returns: Type Description None No return value. NOTE : This is designed for internal usage only. Source code in code_fmkit/fmsignal_vis.py def plot_handgeo ( ax , signal , i ): '''Plot the skeleton shape of the hand. Args: signal (FMSignalLeap): The raw signal containing the \"joints\". i (int): Returns: None: No return value. **NOTE**: This is designed for internal usage only. ''' joints = signal . joints [ i ] x1 = [] y1 = [] z1 = [] # Set up hand skeleton points. for j in range ( 5 ): for k in range ( 5 ): x1 . append ( joints [ j ][ k ][ 0 ]) y1 . append ( joints [ j ][ k ][ 1 ]) z1 . append ( joints [ j ][ k ][ 2 ]) for k in range ( 4 , - 1 , - 1 ): x1 . append ( joints [ j ][ k ][ 0 ]) y1 . append ( joints [ j ][ k ][ 1 ]) z1 . append ( joints [ j ][ k ][ 2 ]) ax . plot ( x1 , y1 , z1 , color = 'b' , markersize = 0.2 )","title":"plot_handgeo()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.plot_xyz_axes","text":"Plot three line segments representing the x-y-z axes. Parameters: Name Type Description Default ax Axes in matplotlib The axes object to plot. required R 3-by-3 ndarray The rotation matrix (local to world). required t 3-by-1 ndarray The translation vector (local to world). required scale float The length of the line segment. 1 Returns: Type Description None No return value. NOTE : This is designed for internal usage only. Source code in code_fmkit/fmsignal_vis.py def plot_xyz_axes ( ax , R , t , scale = 1 ): '''Plot three line segments representing the x-y-z axes. Args: ax (Axes in matplotlib): The axes object to plot. R (3-by-3 ndarray): The rotation matrix (local to world). t (3-by-1 ndarray): The translation vector (local to world). scale (float): The length of the line segment. Returns: None: No return value. **NOTE**: This is designed for internal usage only. ''' x_axis_local = np . asarray ([[ 0 , 0 , 0 ], [ scale , 0 , 0 ]]) . T x_axis = np . matmul ( R , x_axis_local ) + t y_axis_local = np . asarray ([[ 0 , 0 , 0 ], [ 0 , scale , 0 ]]) . T y_axis = np . matmul ( R , y_axis_local ) + t z_axis_local = np . asarray ([[ 0 , 0 , 0 ], [ 0 , 0 , scale ]]) . T z_axis = np . matmul ( R , z_axis_local ) + t ax . plot ( x_axis [ 0 , :], x_axis [ 1 , :], x_axis [ 2 , :], color = 'r' ) ax . plot ( y_axis [ 0 , :], y_axis [ 1 , :], y_axis [ 2 , :], color = 'g' ) ax . plot ( z_axis [ 0 , :], z_axis [ 1 , :], z_axis [ 2 , :], color = 'b' )","title":"plot_xyz_axes()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.signal_vis","text":"Visualize a preprocessed signal by plotting the specified columns. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required start_col int The start index of the sensor axes on the plot. 0 nr_cols int The number of sensor axes on the plot. 18 normalized bool Indicating whether the amplitude of the signal is normalized or not. False Returns: Type Description None No return value. NOTE : Both \"nr_cols\" and \"start_col\" must be a multiple of 3. Source code in code_fmkit/fmsignal_vis.py def signal_vis ( signal , start_col = 0 , nr_cols = 18 , normalized = False ): '''Visualize a preprocessed signal by plotting the specified columns. Args: signal (FMSignal): The signal to be visualized. start_col (int): The start index of the sensor axes on the plot. nr_cols (int): The number of sensor axes on the plot. normalized (bool): Indicating whether the amplitude of the signal is normalized or not. Returns: None: No return value. **NOTE**: Both \"nr_cols\" and \"start_col\" must be a multiple of 3. ''' d = signal . dim assert isinstance ( signal , FMSignal ) assert nr_cols % 3 == 0 and start_col % 3 == 0 assert start_col < d and start_col + nr_cols <= d fig = plt . figure () axes = [] l = signal . length for ii , i in enumerate ( range ( start_col , start_col + nr_cols )): data_column = signal . data [:, i ] ax = fig . add_subplot ( nr_cols , 1 , ii + 1 ) ax . plot ( data_column , color = 'k' ) if normalized : ax . set_ylim ( - 3.5 , 3.5 ) else : ymax = np . max ( data_column ) ymin = np . min ( data_column ) dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax . set_ylim ( ylim_min , ylim_max ) ax . set_xlim ( 0 , l ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax . spines [ axis ] . set_linewidth ( 1 ) ax . spines [ axis ] . set_color ( COLORS [ i // 3 ]) major_ticks = np . arange ( 0 , l , 20 ) ax . set_xticks ( major_ticks ) ax . grid () #ax.tick_params(colors='w') axes . append ( ax ) plt . show ()","title":"signal_vis()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.signal_vis_compact","text":"Visualize a signal by plotting three columns together. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required normalized bool Indicating whether the amplitude of the signal is normalized or not. False Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def signal_vis_compact ( signal , normalized = False ): '''Visualize a signal by plotting three columns together. Args: signal (FMSignal): The signal to be visualized. normalized (bool): Indicating whether the amplitude of the signal is normalized or not. Returns: None: No return value. ''' assert isinstance ( signal , FMSignal ) fig = plt . figure () axes = [] l = signal . length d = signal . dim n = d // 3 for i in range ( n ): ax = fig . add_subplot ( n , 1 , i + 1 ) data_x = signal . data [:, i * 3 + 0 ] data_y = signal . data [:, i * 3 + 1 ] data_z = signal . data [:, i * 3 + 2 ] ax . plot ( data_x , c = 'r' ) ax . plot ( data_y , c = 'g' ) ax . plot ( data_z , c = 'b' ) data_x_max = np . max ( data_x ) data_x_min = np . min ( data_x ) data_y_max = np . max ( data_y ) data_y_min = np . min ( data_y ) data_z_max = np . max ( data_z ) data_z_min = np . min ( data_z ) if normalized : ax . set_ylim ( - 3.5 , 3.5 ) else : ymax = max ( data_x_max , data_y_max , data_z_max ) ymin = min ( data_x_min , data_y_min , data_z_min ) dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax . set_ylim ( ylim_min , ylim_max ) ax . set_xlim ( 0 , l ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax . spines [ axis ] . set_linewidth ( 1 ) ax . spines [ axis ] . set_color ( COLORS [ i ]) #ax.get_xaxis().set_visible(False) #ax.get_yaxis().set_visible(False) major_ticks = np . arange ( 0 , l , 20 ) ax . set_xticks ( major_ticks ) ax . grid () #ax.tick_params(color='w') axes . append ( ax ) plt . show ()","title":"signal_vis_compact()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.signal_vis_comparison","text":"Visualize multiple signals on the same plot. Parameters: Name Type Description Default signals FMSignal The signals to be visualized. required start_col int The start index of the sensor axes on the plot. 0 nr_cols int The number of sensor axes on the plot. 18 normalized bool Indicating whether the amplitudes of all signals are normalized or not. False Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def signal_vis_comparison ( signals , start_col = 0 , nr_cols = 18 , normalized = False ): '''Visualize multiple signals on the same plot. Args: signals (FMSignal): The signals to be visualized. start_col (int): The start index of the sensor axes on the plot. nr_cols (int): The number of sensor axes on the plot. normalized (bool): Indicating whether the amplitudes of all signals are normalized or not. Returns: None: No return value. ''' assert len ( signals ) > 0 for signal in signals : assert isinstance ( signal , FMSignal ) fig = plt . figure () axes = [] lmax = - 1e6 for signal in signals : if signal . length > lmax : lmax = signal . length for ii , i in enumerate ( range ( start_col , start_col + nr_cols )): ax = fig . add_subplot ( nr_cols , 1 , ii + 1 ) ymax = - 1e6 ymin = 1e6 for j , signal in enumerate ( signals ): data_column = signal . data [:, i ] ax . plot ( data_column ) data_column_max = np . max ( data_column ) if data_column_max > ymax : ymax = data_column_max data_column_min = np . min ( data_column ) if data_column_min < ymin : ymin = data_column_min if normalized : ax . set_ylim ( - 3.5 , 3.5 ) else : dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax . set_ylim ( ylim_min , ylim_max ) ax . set_xlim ( 0 , lmax ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax . spines [ axis ] . set_linewidth ( 1 ) ax . spines [ axis ] . set_color ( COLORS [ i // 3 ]) major_ticks = np . arange ( 0 , lmax , 20 ) ax . set_xticks ( major_ticks ) ax . grid () axes . append ( ax ) plt . show ()","title":"signal_vis_comparison()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.signal_vis_comparison_side_by_side","text":"Visualize multiple signals on the same plot. Parameters: Name Type Description Default signals_0 FMSignal The first set of signals to be visualized. required signals_1 FMSignal The second set of signals to be visualized. required start_col int The start index of the sensor axes on the plot. 0 nr_cols int The number of sensor axes on the plot. 18 normalized bool Indicating whether the amplitudes of all signals are normalized or not. False Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def signal_vis_comparison_side_by_side ( signals_0 , signals_1 , start_col = 0 , nr_cols = 18 , normalized = False ): '''Visualize multiple signals on the same plot. Args: signals_0 (FMSignal): The first set of signals to be visualized. signals_1 (FMSignal): The second set of signals to be visualized. start_col (int): The start index of the sensor axes on the plot. nr_cols (int): The number of sensor axes on the plot. normalized (bool): Indicating whether the amplitudes of all signals are normalized or not. Returns: None: No return value. ''' assert len ( signals_0 ) > 0 and len ( signals_1 ) for signal in signals_0 : assert isinstance ( signal , FMSignal ) for signal in signals_1 : assert isinstance ( signal , FMSignal ) fig = plt . figure () axes_left = [] axes_right = [] lmax = - 1e6 for signal in signals_0 : if signal . length > lmax : lmax = signal . length for signal in signals_1 : if signal . length > lmax : lmax = signal . length for ii , i in enumerate ( range ( start_col , start_col + nr_cols )): ax_left = fig . add_subplot ( nr_cols , 2 , 2 * ii + 1 ) ax_right = fig . add_subplot ( nr_cols , 2 , 2 * ii + 2 ) ymax = - 1e6 ymin = 1e6 for signal_0 in signals_0 : d0 = signal_0 . data [:, i ] ax_left . plot ( d0 ) d_max = np . max ( d0 ) if d_max > ymax : ymax = d_max d_min = np . min ( d0 ) if d_min < ymin : ymin = d_min for signal_1 in signals_1 : d1 = signal_1 . data [:, i ] ax_right . plot ( d1 ) d_max = np . max ( d1 ) if d_max > ymax : ymax = d_max d_min = np . min ( d1 ) if d_min < ymin : ymin = d_min if normalized : ax_left . set_ylim ( - 3.5 , 3.5 ) ax_right . set_ylim ( - 3.5 , 3.5 ) else : dist = max ( abs ( ymin ), abs ( ymax )) ylim_max = dist * 1.2 ylim_min = - dist * 1.2 ax_left . set_ylim ( ylim_min , ylim_max ) ax_right . set_ylim ( ylim_min , ylim_max ) ax_left . set_xlim ( 0 , lmax ) ax_right . set_xlim ( 0 , lmax ) for axis in [ 'top' , 'bottom' , 'left' , 'right' ]: ax_left . spines [ axis ] . set_linewidth ( 1 ) ax_left . spines [ axis ] . set_color ( COLORS [ i // 3 ]) ax_right . spines [ axis ] . set_linewidth ( 1 ) ax_right . spines [ axis ] . set_color ( COLORS [ i // 3 ]) major_ticks = np . arange ( 0 , lmax , 20 ) ax_left . set_xticks ( major_ticks ) ax_right . set_xticks ( major_ticks ) ax_left . grid () ax_right . grid () axes_left . append ( ax_left ) axes_right . append ( ax_right ) plt . show ()","title":"signal_vis_comparison_side_by_side()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.trajectorie_vis_comparison","text":"Visualize multiple trajectories in the same plot. Parameters: Name Type Description Default signals list The list of signals to visualize. required Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def trajectorie_vis_comparison ( signals ): '''Visualize multiple trajectories in the same plot. Args: signals (list): The list of signals to visualize. Returns: None: No return value. ''' fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) dist_max = - 1e6 for signal in signals : if isinstance ( signal , FMSignal ) : trajectory = signal . data [:, 0 : 3 ] elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): trajectory = signal . trajectory assert trajectory is not None else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) tx = trajectory [:, 0 ] ty = trajectory [:, 1 ] tz = trajectory [:, 2 ] tx_max = np . max ( tx ) tx_min = np . min ( tx ) ty_max = np . max ( ty ) ty_min = np . min ( ty ) tz_max = np . max ( tz ) tz_min = np . min ( tz ) dx = max ( abs ( tx_max ), abs ( tx_min )) dy = max ( abs ( ty_max ), abs ( ty_min )) dz = max ( abs ( tz_max ), abs ( tz_min )) dist = max ( dx , dy , dz ) if dist > dist_max : dist_max = dist l = signal . length ax . plot ( tx , ty , tz , markersize = 0.1 ) lim = dist_max * 1.2 ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) #plt.axis('equal') plt . show ()","title":"trajectorie_vis_comparison()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.trajectory_animation","text":"Animate the signal trajectory in 3D. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required speed float Indicating the animation speed. \"speed=1\" is 1x. 1 seg_length int The animated segment length in number of samples. -1 show_hand bool Indicating whether the hand geometry is shown. False Returns: Type Description None No return value. NOTE : The \"speed\" can be either a fraction number between 0 and 1, which means slow down, or integers greater than 1, which means speed up. If it is greater than 1 and it is not an integer, it is rounded to the closest integer. Source code in code_fmkit/fmsignal_vis.py def trajectory_animation ( signal , speed = 1 , seg_length =- 1 , show_hand = False ): '''Animate the signal trajectory in 3D. Args: signal (FMSignal): The signal to be visualized. speed (float): Indicating the animation speed. \"speed=1\" is 1x. seg_length (int): The animated segment length in number of samples. show_hand (bool): Indicating whether the hand geometry is shown. Returns: None: No return value. **NOTE**: The \"speed\" can be either a fraction number between 0 and 1, which means slow down, or integers greater than 1, which means speed up. If it is greater than 1 and it is not an integer, it is rounded to the closest integer. ''' if isinstance ( signal , FMSignal ) : trajectory = signal . data [:, 0 : 3 ] elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): trajectory = signal . trajectory assert trajectory is not None else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) matplotlib . interactive ( True ) fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) tx = trajectory [:, 0 ] ty = trajectory [:, 1 ] tz = trajectory [:, 2 ] tx_max = np . max ( tx ) tx_min = np . min ( tx ) ty_max = np . max ( ty ) ty_min = np . min ( ty ) tz_max = np . max ( tz ) tz_min = np . min ( tz ) dx = max ( abs ( tx_max ), abs ( tx_min )) dy = max ( abs ( ty_max ), abs ( ty_min )) dz = max ( abs ( tz_max ), abs ( tz_min )) dist = max ( dx , dy , dz ) lim = dist * 1.2 l = signal . length for i in range ( 1 , l ): # speed up by subsampling if speed > 1 and i % int ( round ( speed )) != 0 : continue ax . clear () if seg_length <= 0 : s = 0 else : s = i - seg_length if s < 0 : s = 0 # ax.plot(data[0:i, 0], data[0:i, 1], data[0:i, 2], # color='k', markersize=0.2) ax . plot ( tx [ s : i ], ty [ s : i ], tz [ s : i ], color = 'k' , markersize = 0.1 ) if isinstance ( signal , FMSignalLeap ) and show_hand : plot_handgeo ( ax , signal , i ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) if i == 1 : plt . pause ( 1 ) else : plt . pause ( 0.001 ) if speed < 1 : plt . pause ( 0.02 / speed ) matplotlib . interactive ( False ) ax . plot ( tx , ty , tz , color = 'k' , markersize = 0.1 ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) fig . canvas . draw () plt . show ()","title":"trajectory_animation()"},{"location":"fmsignal_vis-reference/#fmsignal_vis.trajectory_vis","text":"Visualize the signal as the trajectory of a point in 3D. Parameters: Name Type Description Default signal FMSignal The signal to be visualized. required show_local_axes bool Indicating whether the orientation is shown. False interval int Indicating how many samples to plot the orientation x-y-z axes once. 10 Returns: Type Description None No return value. Source code in code_fmkit/fmsignal_vis.py def trajectory_vis ( signal , show_local_axes = False , interval = 10 ): '''Visualize the signal as the trajectory of a point in 3D. Args: signal (FMSignal): The signal to be visualized. show_local_axes (bool): Indicating whether the orientation is shown. interval (int): Indicating how many samples to plot the orientation x-y-z axes once. Returns: None: No return value. ''' if isinstance ( signal , FMSignal ) : trajectory = signal . data [:, 0 : 3 ] rotms , _qs = signal . get_orientation () elif isinstance ( signal , FMSignalLeap ) \\ or isinstance ( signal , FMSignalGlove ): trajectory = signal . trajectory rotms = signal . rotms assert trajectory is not None and rotms is not None else : raise ValueError ( 'Wong signal: %s .' % signal . __class__ ) fig = plt . figure () ax = fig . add_subplot ( 1 , 1 , 1 , projection = '3d' ) ax . view_init ( elev = 30 , azim = 160 ) tx = trajectory [:, 0 ] ty = trajectory [:, 1 ] tz = trajectory [:, 2 ] tx_max = np . max ( tx ) tx_min = np . min ( tx ) ty_max = np . max ( ty ) ty_min = np . min ( ty ) tz_max = np . max ( tz ) tz_min = np . min ( tz ) dx = max ( abs ( tx_max ), abs ( tx_min )) dy = max ( abs ( ty_max ), abs ( ty_min )) dz = max ( abs ( tz_max ), abs ( tz_min )) dist = max ( dx , dy , dz ) lim = dist * 1.2 l = signal . length ax . plot ( tx , ty , tz , color = 'k' , markersize = 0.1 ) if show_local_axes : for i in range ( 0 , l , interval ): R = rotms [ i ] t = trajectory [ i ] . reshape (( 3 , 1 )) plot_xyz_axes ( ax , R , t , lim / 10 ) ax . tick_params ( color = 'w' ) ax . set_xlim ( - lim , lim ) ax . set_ylim ( - lim , lim ) ax . set_zlim ( - lim , lim ) ax . set_xlabel ( 'X' ) ax . set_ylabel ( 'Y' ) ax . set_zlabel ( 'Z' ) # ax.zaxis.set_major_locator(plt.NullLocator()) # ax.yaxis.set_major_locator(plt.NullLocator()) # ax.xaxis.set_major_locator(plt.NullLocator()) # ax.zaxis.set_major_formatter(plt.NullFormatter()) # ax.yaxis.set_major_formatter(plt.NullFormatter()) # ax.xaxis.set_major_formatter(plt.NullFormatter()) plt . show ()","title":"trajectory_vis()"},{"location":"format/","text":"Data Format This section provides details of the data format of the files in the FMKit data repository. Preprocessed Signals Templates Raw Signals (Leap Motion) Raw Signals (Data Glove)","title":"Data Format"},{"location":"format/#data-format","text":"This section provides details of the data format of the files in the FMKit data repository.","title":"Data Format"},{"location":"format/#preprocessed-signals","text":"","title":"Preprocessed Signals"},{"location":"format/#templates","text":"","title":"Templates"},{"location":"format/#raw-signals-leap-motion","text":"","title":"Raw Signals (Leap Motion)"},{"location":"format/#raw-signals-data-glove","text":"","title":"Raw Signals (Data Glove)"},{"location":"manual_signal/","text":"User Manual for Signal Manipulation with FMKit This user manual demonstrates the basic usage of the FMKit code library on signal manipulation. Requirement The FMKit code library requires the following software packages Python 3 (tested with Python 3.6.9) NumPy (tested with NumPy 1.19.5) Matplotlib (tested with 3.1.2) Installation The code and data are released on GitHub . Please download the code and the data and unzip them to maintain the folowing folder structure. workspace_fmkit \u251c\u2500\u2500 code_fmkit \u2502 \u251c\u2500\u2500 fmsignal.py \u2502 \u251c\u2500\u2500 fmsingal_vis.py \u2502 \u251c\u2500\u2500 fmsignal_demo.py \u2502 \u251c\u2500\u2500 ...(other code)... \u2502 \u251c\u2500\u2500 my_code.py \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 data_demo \u251c\u2500\u2500 glove_pp \u2502 \u251c\u2500\u2500 alice_FMKit_0.csv \u2502 \u251c\u2500\u2500 alice_FMKit_0.npy \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 glove_raw \u2502 \u251c\u2500\u2500 alice_FMKit_0.txt \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 leap_pp \u2502 \u251c\u2500\u2500 alice_FMKit_0.csv \u2502 \u251c\u2500\u2500 alice_FMKit_0.npy \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 leap_raw \u251c\u2500\u2500 alice_FMKit_0.txt \u2514\u2500\u2500 ... All example signals used in this manual are in the \"data_demo\" folder. These files are packaged in a single zip file on the GitHub repository and they must be unzipped in this folder structure. The following three python modules are demonstrated in this tutorial. fmsignal.py - signal representation, preprocessing, and manipulation. fmsignal_vis.py - signal visualization fmsignal_demo.py - demonstration for this tutorial. To use this code library, please download the Python modules under the \"code_fmkit\" folder and incorporate into your project. A simple way to try the code in this manual is creating a file \"my_code.py\" under the folder \"code_fmkit\", import everything as follows, and run it. from fmsignal import * from fmsignal_vis import * from fmsignal_demo import * # Put the demo code in this manual here. Note that the signal files for the same user writing the same content have the same file names, regardless of the data capture devices or whether they are raw signals or preprocessed signals. They are only differentiated by the folders, and hence, maintaining the correct folder structure is important for the demo. Signal I/O This section demonstrates preprocessed signal input/output, raw signal input/ouput, and raw signal preprocessing. Preprocessed Signal I/O A preprocessed signal can be constructed from a file as follows. fn = '../date_demo/leap_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn , mode = 'csv' ) This load the file \"alice_FMKit_0.csv\" under the folder \"date_demo/leap_pp\". A signal can also be constructed using a different file format as follows. fn = '../date_demo/leap_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn , mode = 'npy' ) This load the file \"alice_FMKit_0.npy\" under the folder \"date_demo/leap_pp\". These two signals are identical in memory. These files can have two different \"mode\", i.e., \"csv\" for the Comma Separated Value format, and \"npy\" for the NumPy binary format. The \"csv\" format is human readable and programming language agnostic, while the \"npy\" format is only designed to work with Python and NumPy. Loading the files in the \"npy\" format is in general faster than those in the \"csv\" format. Note that the file name does not need to specify the \".csv\" or \".npy\" extension. They are attached automatically by specify the \"mode\". A signal has the three attributes \"user\", \"cid\", and \"seq\" to indicate the user who create this signal, the content ID, and the sequence number. They can be set when a signal is constructed from a file as follows. fn = '../date_demo/leap_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn , mode = 'csv' , user = 'alice' , cid = 'FMKit' , seq = 0 ) If these attributes are not specified at loading, by default, \"user\" is an empty string, \"cid\" is also an empty string, and \"seq\" is zero. A signal can also be saved to a file as follows. fn = '../date_demo/leap_pp/temp/alice_FMKit_0' signal . save_to_file ( fn , mode = 'csv' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_pp/temp\". A signal can also be saved using a different file format as follows. fn = '../date_demo/leap_pp/temp/alice_FMKit_0' signal . save_to_file ( fn , mode = 'npy' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_pp/temp\". The signals are writtent to the folder \"date_demo/leap_pp/temp\" to avoid overwriting the original signal files. Note that the file name does not need to specify the \".csv\" or \".npy\" extension. They are attached automatically by specify the \"mode\". As explained in \" The FMKit Architecture \" document, preprocessed signals are device agnostic and they have a unified format. Although the previous demo only shows those signals generated using the Leap Motion controller device, they can be easily modified to show those signals generated using the data glove device, as follows. fn_load = '../date_demo/glove_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn_load , mode = 'csv' ) fn_save = '../date_demo/glove_pp/temp/alice_FMKit_0' signal . save_to_file ( fn_save , mode = 'npy' ) This loads the file \"alice_FMKit_0.csv\" under the folder \"date_demo/glove_pp\" and saves it to the file \"alice_FMKit_0.npy\" under the folder \"date_demo/glove_pp/temp\" Raw Signal I/O A raw signal generated using the Leap Motion controller can also be constructed in a similar way as preprocessed signals. fn = '../date_demo/leap_raw/alice_FMKit_0' raw_signal_leap = FMSignalLeap . construct_from_file ( fn , mode = 'raw_csv' ) This load the file \"alice_FMKit_0.csv\" under the folder \"date_demo/leap_raw\". Similarly, a raw signal generated using the Leap Motion controller can also be constructed using a different file format as follows. fn = '../date_demo/leap_raw/alice_FMKit_0' raw_signal_leap = FMSignalLeap . construct_from_file ( fn , mode = 'raw_npy' ) This load the file \"alice_FMKit_0.npy\" under the folder \"date_demo/leap_raw\". Note that the two file \"modes\" are \"raw_csv\" and \"raw_npy\" but the actual file extensions are just \".csv\" and \".npy\". This is intentional to avoid mistakes of using raw signals as preprocessed signals. The file extensions are attached automatically, similar to the preprocessed signals. Besides these two formats, there is another \"mode\" named \"raw_internal\", which has the file extension \".txt\". Files in this format are generated directly by our client software. There are several versions of the format with small variations, which complicates the code. Hence, they are generally only for internal usage. All released datasets only contains \".csv\" or \".npy\" files. Still, a raw signal generated using the Leap Motion controller can be constructed using the \"raw_internal\" mode as follows. fn = '../date_demo/leap_raw/alice_FMKit_0' raw_signal_leap = FMSignalLeap . construct_from_file ( fn , mode = 'raw_interal' ) This load the file \"alice_FMKit_0.txt\" under the folder \"date_demo/leap_raw\". These signals are identical in memory. They are only different in the formats when saved in files. A raw signal generated using the Leap Motion controller can be saved to a file as follows. fn = '../date_demo/leap_raw/temp/alice_FMKit_0' raw_signal_leap . save_to_file ( fn , mode = 'raw_csv' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_raw/temp\". A raw signal generated using the Leap Motion controller can also be saved using a different file format as follows. fn = '../date_demo/leap_raw/temp/alice_FMKit_0' raw_signal_leap . save_to_file ( fn , mode = 'raw_npy' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_raw/temp\". Note that a raw signal cannot be saved in the \"raw_internal\" format. Besides the Leap Motion controller, raw signals can also generated using our data glove device. This kind of signals can be load in a similar way as follows fn = '../date_demo/glove_raw/alice_FMKit_0' raw_signal_glove = FMSignalGlove . construct_from_file ( fn , mode = 'raw_interal' ) This load the file \"alice_FMKit_0.txt\" under the folder \"date_demo/glove_raw\". The \"mode\" can be \"raw_csv\", \"raw_npy\", or \"raw_internal\", which is the same as the signals generated by the Leap Motion controller. Similarly, they can be saved to files as follows. fn = '../date_demo/glove_raw/temp/alice_FMKit_0' raw_signal_glove . save_to_file ( fn , mode = 'raw_csv' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/glove_raw/temp\". The \"mode\" can also be \"raw_npy\". Raw Signal Preprocessing Although the raw signals from two different devices are fundamentally different, both types of signals can be preprocessed to generate the signals in the same format, as explained in \" The FMKit Architecture \" document. A raw signal obtained using the Leap Motion controller device can be preprocessed as follows. signal_leap_pp = raw_signal_leap . preprocess ( point = 'tip' ) Here the \"point\" parameter indicates which point on the hand is used, either the tip of the index finger (i.e., \"tip\") or the center of the hand (i.e., \"center\"). After preprocessing, a new signal is returned, and the original raw signal is also modified. For a raw signal obtained using the data glove, the preprocessing is similar as follows. A raw signal obtained using the Leap Motion controller device can be preprocessed as follows. signal_glove_pp = raw_signal_glove . preprocess ( point = 'tip' ) Here the \"point\" parameter has the same meaning and it can be either \"tip\" or \"center\". Currently, the only usage of a raw signal (i.e., an instance of FMSignalLeap or FMSignalGlove ) is to run the preprocessing procedure to obtain a preprocessed signal (i.e, an instance of FMSignal ). There are other parameters can be set to control the behavior of the preprocessing procedure. See the code reference ( FMSignalLeap.preprocess() or FMSignalGlove.preprocess() ) for further details. Helper Functions For Demo Since signal I/O is frequently used in the demo, a few helper functions are provided to make the demo code short and succinct. These helper functions are defined in the \" fmsignal_demo.py \". They also assume the file name has the format of \"user_cid_seq.csv\" or \"user_cid_seq.npy\", and the folder structures has the format specified at the beginning of this tutorial. The following global variables are defined for convenience, and they are used to specify the default values for the parameters of these helper functions. FOLDER = '../data_demo' USER = \"alice\" #USER = \"bob\" CID = 'FMKit' #CID = '123456' PP_MODE_LOAD = 'npy' PP_MODE_SAVE = 'npy' RAW_MODE_LOAD = 'raw_internal' RAW_MODE_SAVE = 'raw_npy' LEAP_PP_SUBFOLDER = 'leap_pp' GLOVE_PP_SUBFOLDER = 'glove_pp' LEAP_TEMPLATE_SUBFOLDER = 'leap_template' GLOVE_TEMPLATE_SUBFOLDER = 'glove_template' LEAP_RAW_SUBFOLDER = 'leap_raw' GLOVE_RAW_SUBFOLDER = 'glove_raw' DEVICE = 'leap' #DEVICE = 'glove' A single preprocessed signal for demo can be loaded as follows. signal = load_one_demo_signal_pp () This loads the file \"alice_FMKit_0.npy\" from the folder \"date_demo/leap_pp\" or \"date_demo/glove_pp\" depending on the \"device\" parameter, which can be either \"leap\" or \"glove\". A specific signal can be loaded by setting the parameter to something different from the default values as follows. signal = load_one_demo_signal_pp ( device = 'glove' , user = 'bob' , cid = '123456' , seq = 5 , mode = 'csv' ) This loads the file \"bob_123456_5.csv\" from the folder \"data_demo/glove_pp\". By default, the \"device\" is \"leap\", the \"user\" parameter is \"alice\", the \"cid\" parameter is \"FMKit\", the \"seq\" parameter is 0, the \"mode\" parameter is \"npy\". This function constructs the file name according to these parameters. A collection of signals for demo can be loaded as follows. signals = load_demo_signals_pp () This loads ten files, from \"alice_FMKit_0.npy\" to \"alice_FMKit_9.npy\", all in the folder \"data_demo/leap_pp\", and it returns a list of ten signals. A specific collection of signals can be loaded by setting the parameters to something different from the default values as follows. signals = load_demo_signals_pp ( device = 'glove' , user = 'bob' , cid = '123456' , sequences = [ 5 , 6 ], mode = 'csv' ) This loads two files, i.e., \"bob_123456_5.csv\" and \"bob_123456_6.csv\", all in the folder \"data_demo/glove_pp\", and returns a list of two signals. A signal can be saved at a certain place as follows. save_one_demo_signal_pp ( signal ) This save the signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name as \"user_cid_seq.csv\" using the signal attributes. The parameter \"device\" can be specified to change the target folder. Note that this function can not distinguish the signals from different devices. Users are required to pay attention to save the signal at the correct folder. For example, if the signal is obtained from the data glove device, use save_one_demo_signal_pp(signal, device='glove') instead. A collection of signals can be saved at a certain place as follows. save_demo_signals_pp ( signals ) This saves each signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name for each signal. The parameter \"device\" can be specified to change the target folder. For raw signal I/O, there are similar helper functions as follows. signal_raw = load_one_demo_signal_raw () This loads the file \"alice_FMKit_0.txt\" from the folder \"date_demo/leap_raw\". The parameter \"device\" can be specified to change the folder accordingly. By default it uses the \"raw_internal\" mode. signals_raw = load_demo_signals_raw () This loads ten files, from \"alice_FMKit_0.txt\" to \"alice_FMKit_9.txt\", all in the folder \"date_demo/leap_raw\", and returns a list of ten signals. save_one_demo_signal_raw ( signal ) This save the signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name as \"user_cid_seq.csv\" using the signal attributes. The parameter \"device\" can be specified to change the folder accordingly. A collection of signals can be saved at a certain place as follows. save_demo_signals_raw ( signals ) This saves each signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name for each signal. The parameter \"device\" can be specified to change the folder accordingly. Note that different signals from different devices are only distinguished by the corresponding folders. Similarly, preprocessed signals and raw signals are only distinguished by the corresponding folders. Users need to pay attention to specify the correct folder when loading and saving signals. Signal Visualization This section demonstrates visualization of preprocessed signals. All functions related to visualization are provided in the \" fmsignal_vis.py \" module. Note that only preprocessed signals can be visualized using these methods (raw signals do not follow the format of 18 sensor axes, and hence, they cannot be visualized in this way). Also, preprocessed signals are sensor agnostic, i.e., the visualization functions does care whether they are obtained from raw signals obtain by the Leap Motion controller device or the data glove device. Visualization of One Signal A signal can be visualized as follows. signal = load_one_demo_signal_pp ( device ) signal_vis ( signal ) This plots the signal data for all 18 sensor axes, as shown in the following figure. The edges of each plot are colored to indicate the sensor axes groups as follows. black - position red - velocity green - linear acceleration blue - orientation cyan - angular speed magenta - angular acceleration Within each color group, the three axes are in the order x-y-z. If there is no need to plot all sensor axes, a subset can be visualized as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) signal_vis ( signal , start_col = 9 , nr_cols = 3 ) This only plots the three axes of orientation, as shown in the following figure. The \"start_col\" means the starting index of the sensor axis (i.e., columns). Note that both \"start_col\" and \"nr_cols\" must be multiples of three, i.e., the plot always bundles three axes of one specific type of physical states in the x-y-z directions together. The plot is also colored accordingly. The signal data for all sensor axes can also be visualized in a compact way as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) signal_vis_compact ( signal ) This plots the signal data in bundles of three axes, as shown in the following figure. The edges of each plot are colored accordingly. Within a plot, the RGB colors of the lines map to the sensor axes x-y-z. Signal Comparison Two signals can be visualized in the same plot for comparison as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_vis_comparison ([ signal_0 , signal_1 ], start_col = 9 , nr_cols = 3 ) This compares the data of two signals in the orientation axes. The result is shown in the following figure. Here, the blue lines are the \"signal_0\" and the orange lines are the \"signal_1\". Since they are generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), the two signals are similar in the visualized sensor axes. The plot is also colored according to the sensor axes groups. Similarly, multiple signals can be compared together as follows. signals = load_demo_signals_pp ( device = 'leap' ) signal_vis_comparison ( signals , start_col = 9 , nr_cols = 3 ) This compares ten signals in the orientation axes. The result is shown in the following figure. Here, each signal has its own color. They are also generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"). This plot shows the inherent \"fuzziness\" in the in-air-handwriting, i.e., even if the same person write the same content multiple times, there are variations in the writing speed and intensity of each stroke. Hence, alignment is needed (see the section \" Signal Alignment and Template \") Trajectory Visualization This section demonstrates visualization of trajectories for preprocessed signals. This function works for both devices. It also works for both raw signals and preprocessed signals. However, the trajectory of a signal obtained by the data glove device is generally illegible. Visualization of One Trajectory The trajectory of one signal can be visualized as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) trajectory_vis ( signal ) This shows the trajectory of a point on the hand (either \"tip\" or \"center\", depending on the preprocessing). The result is shown in the following figure. The view angles are kept moving intentionally to show the 3D structure in this figure. This signal is obtained by the user \"alice\" writing the string \"FMKit\" using the Leap Motion controller device. Note that this user intentionally wrote it in a legible way to facilitate this visualization. Also, the Leap Motion controller device directly records the 3D position of the joints on the hand with an infrared stereo camera. The orientation of the finger can also be shown together with the trajectory as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) trajectory_vis ( signal , show_local_axes = True , interval = 10 ) The result is shown in the following figure. The line segments indicates the axes of the local finger orientation where the RGB colors correspond to x-y-z. The \"interval=10\" parameter means for every 10 samples of the time series, the local axes are plot once. Trajectory Comparison Two trajectories from two signals can be visualized together for comparison as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) trajectorie_vis_comparison ([ signal_0 , signal_1 ]) The result is shown in the following figure. Since these two signals are generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), the trajectories are close to each other. Similarly, more trajectories can be visualized together as follows. signals = load_demo_signals_pp ( device = 'leap' ) trajectorie_vis_comparison ( signals ) The result is shown in the following figure. Each trajectory has its own color. Since they are all generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), the trajectories are all similar in shape. Note that the preprocessing procedure normalize the pose of the in-air-handwriting, and hence, the relative pose between the in-air-handwriting and the sensor does not matter. Trajectory Animation As the in-air-handwriting signal is a time series of physical states of the hand, the process of generating the trajectory can be reproduced using the signal data as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) trajectory_animation ( signal , seg_length = 30 ) This generates the following animation. Essentially, this function plot the trajectory of a signal segment in a sliding-forward window. The parameter \"seg_length\" controls the length of the signal segment. If it is less or equal to zero, the whole signal is plotted (by default it is zero). This is designed to facilitate the visual confirmation of the signal content for those users who write all letters in the same place. Trajectory and Hand Geometry Animation If a signal is obtained using the Leap Motion controller device, the raw signal contains the position of each joint on the hand, and the hand geometry can be animated together with the trajectory as follows. raw_signal = load_one_demo_signal_raw ( device = 'leap' ) raw_signal . preprocess ( point = 'tip' ) trajectory_animation ( raw_signal , seg_length = 30 ) Note that the raw signal still needs preprocessing for pose normalization and filtering (which is essential to generate the \"trajectory\" attribute and the \"joints\" attribute). The hand geometry plot works only for raw signals from the Leap Motion controller device. It does not work for preprocessed signals or raw signals from the data glove (because they do not have the \"joints\" attribute). This generates the following animation. This plots the position of the joints for each data sample at a time and make an animation. Orientation Animation Since the data glove device can only obtain angular speed and linear acceleration directly, the trajectory of a signal obtained by the data glove device is derived indirectly (usually with some regularization to prevent the unbounded accumulation of errors in the dead reckoning procedure). This trajectory does not represent the actual trajectory of the hand, and this usually means that the visualization of such a \"trajectory\" is usually not legible. To check the signals from the data glove in a human understandable way, the orientation can be animated as follows. raw_signal = load_one_demo_signal_raw ( device = 'glove' , cid = '123456' ) raw_signal . preprocess ( point = 'tip' ) orientation_animation ( raw_signal , seg_length = 20 ) The result is shown as follows. This plots the x-y-z axes of each sample in an animation to show the orientation of the point on the hand. The animation also plots the trajectory of the end point of the x-axis. The signal is obtained by the user \"alice\" writing the string \"123456\". Clearly a person can visually confirm the writing content is \"123456\" with this animation. However, not every user write strings in this way. Some user will maintain the pointing direction of the finger while moving the arm as a whole in the air to write like on an invisible wall. Although it is designed mainly for signals obtained from the data glove device, this function works for both devices. It also works for both raw signals and preprocessed signals. Signal Alignment and Template This section demostrates signal alignment with the Dynamic Time Warp (DTW) algorithm. Signal Alignment Visualization A preprocessed signal can be aligned to another preprocessed signal using DTW as follow. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_0 . amplitude_normalize () signal_1 . amplitude_normalize () signal_1_aligned = signal_1 . align_to ( signal_0 ) aligned = [ signal_0 , signal_1_aligned ] unaligned = [ signal_0 , signal_1 ] signal_vis_comparison_side_by_side ( aligned , unaligned , start_col = 0 , nr_cols = 9 ) The difference before the alignment and after the alignment is shown in the following figure. These two signals are generated by the same user (i.e., \"alice\") writing the same content (i.e., \"FMKit\"). As mentioned previously in the \" Signal Comparison \" subsection, even for signals generated by the same user writing the same content, there are differences, mainly in the writing speed and the intensity of strokes. As the figure shows, these differences can be reduced by aligning one signal to the other signal along the time using DTW. The function \"signal_vis_comparison_side_by_side()\" is designed to plot two sets of signals side by side on two columns for comparison. Warping Path Visualization The detailed warping path of the alignment of on signal to another signal (or a template) can be visualized as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_0 . amplitude_normalize () signal_1 . amplitude_normalize () signal_1_aligned = signal_1 . align_to ( signal_0 , keep_dist_matrix = True ) alignment_vis ( signal_1 , signal_0 , signal_1_aligned , col = 9 ) The result is shown in the following figure. The subplot named \"template\" means the template signal (i.e., \"signal_0\" in this demo), and the subplot named \"signal\" is the signal that is aligned to the template signal (i.e., \"signal_1\" in this demo). This figure essentially shows the DTW distance matrix (i.e., the \"dist_matrix\" attribute of the \"signal_1_aligned\") together with the two signals. The specific sensor axis representing the signal and the template can be selected by setting the \"col\" parameter to the sensor axis index. The warping path can also be visualized in 3D as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_0 . amplitude_normalize () signal_1 . amplitude_normalize () signal_1_aligned = signal_1 . align_to ( signal_0 , keep_dist_matrix = True ) alignment_vis ( signal_1 , signal_0 , signal_1_aligned , plot_3d = True ) The result is shown in the following figure. This 3D visualization plot the DTW distance matrix in 3D. These two signals are generated by the same user (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), and this user can maintain the same writing behavior very well across multiple repetitions. Hence, these two signals can be alsigned very well and the warping path is close to the diagonal line. In fact, any signal can be aligned to another signal using DTW regardless whether they are generated by the same user or writing the same content. The warping path can vary significantly based on the shapes of the two signals. Template Visualization For multiple repetitions of the in-air-handwriting of the same content by the same user, they can be all aligned to one signal and to construct a template by taking the average of them as follows. signals = load_demo_signals_pp ( device = device , user = user , cid = cid ) template = FMSignalTemplate . construct_from_signals ( signals , template_index = 0 ) signals_alinged = template . signals_aligned signal_vis_comparison_side_by_side ( signals_alinged , signals , start_col = 0 , nr_cols = 9 ) signal_vis_comparison_side_by_side ( signals_alinged , [ template ], start_col = 0 , nr_cols = 9 ) This will first show the comparison of ten aligned signals and the original ones as follows. The aligned signals are on the left and the original ones are on the right. After closing the first plot, the aligned signals and the template are shown in the following figure. The function \"FMSignalTemplate.construct_from_signals()\" does alignment and template construction. The \"template_index\" parameter indicate which signal in the set is used as the \"base signal\" so that other signals are aligned to it. A template, i.e., an instance of the \" FMSignalTemplate \", is essentially the same as a preprocessed signal, only with an additional attribute to keep the variations of the original signals. A template can be saved to a file as follows, which is the same as saving a signal. The mode can be either \"csv\" or \"npy\". fn = '../date_demo/leap_template/alice_FMKit_0' template ( fn , mode = 'csv' ) A template can also be loaded from a file as follows, which is also the same as loading a signal. fn = '../date_demo/leap_template/alice_FMKit_0' template = FMSignalTemplate . construct_from_file ( fn , mode = 'csv' ) A template also has the \"user\" attribute, the \"cid\" attribute, and the \"seq\" attribute. If a template is constructed from a set of signals, its \"user\" and \"cid\" attributes are copied from the \"base signal\" indicated by the \"template_index\" parameter in \"FMSignalTemplate.construct_from_signals()\". The \"seq\" attribute is always set to 0. The demo also provide two helper functions as follows, one for loading, and the other for saving. template = load_one_demo_template () save_one_demo_template ( template ) Improving DTW Efficiency The default DTW implementation is in Python, which is relatively inefficient because it will iterate through the two signal data and the n-by-m DTW distance matrix (which are all NumPy ndarrays). To improve the efficiency, a version implemented in C is provided under the \" code_utilities \" folder. It can be installed as follows. # cd code_utilities # python3 ./setup.py build # sudo python3 setup.py install --record ./files.txt If the build step cannot find numpy header files, run the following first. # export CFLAGS=\"-I $HOME/.local/lib/python3.6/site-packages/numpy/core/include $CFLAGS\" Here the path after \"-I\" is the place where NumPy is installed. This will install a package named \"fmkit_utilities\" which introduces a function \"fmkit_utilities.dtw_c()\". It will be shown as a \"built-in\" function because it is implemented in C code. The \" fmsignal.py \" module has a Python wrapper function \" dtw_c() \" that calls the C implementation. This wrapper function takes the exact same format of parameters as the default Python implementation. The \" fmsignal.py \" module will use the C implementation automatically if the \"fmkit_utilities\" package is installed. This is made using the following code at the beginning of the module. try : import fmkit_utilities DTW_METHOD = \"c\" except ImportError : DTW_METHOD = \"python\" The only method that invokes \" dtw() \" or \" dtw_c() \" is \" FMSignal.align_to() \", i.e., aligning on signal to another signal or template. It takes a parameter named \"method\", which is set to \"DTW_METHOD\" by default. Users can choose which implementations to use as follows. signal_aligned = signal . align_to ( template , method = \"python\" ) # This uses the Python implementation. Or signal_aligned = signal . align_to ( template , method = \"c\" ) # This uses the C implementation. Note that the C implementation is kind of \"fragile\", and hence, it is recommended to always use the wrapper \" FMSignal.dtw_c() \" instead of directly using the \"fmkit_utilities.dtw_c()\".","title":"User Manual - Signal"},{"location":"manual_signal/#user-manual-for-signal-manipulation-with-fmkit","text":"This user manual demonstrates the basic usage of the FMKit code library on signal manipulation.","title":"User Manual for Signal Manipulation with FMKit"},{"location":"manual_signal/#requirement","text":"The FMKit code library requires the following software packages Python 3 (tested with Python 3.6.9) NumPy (tested with NumPy 1.19.5) Matplotlib (tested with 3.1.2)","title":"Requirement"},{"location":"manual_signal/#installation","text":"The code and data are released on GitHub . Please download the code and the data and unzip them to maintain the folowing folder structure. workspace_fmkit \u251c\u2500\u2500 code_fmkit \u2502 \u251c\u2500\u2500 fmsignal.py \u2502 \u251c\u2500\u2500 fmsingal_vis.py \u2502 \u251c\u2500\u2500 fmsignal_demo.py \u2502 \u251c\u2500\u2500 ...(other code)... \u2502 \u251c\u2500\u2500 my_code.py \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 data_demo \u251c\u2500\u2500 glove_pp \u2502 \u251c\u2500\u2500 alice_FMKit_0.csv \u2502 \u251c\u2500\u2500 alice_FMKit_0.npy \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 glove_raw \u2502 \u251c\u2500\u2500 alice_FMKit_0.txt \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 leap_pp \u2502 \u251c\u2500\u2500 alice_FMKit_0.csv \u2502 \u251c\u2500\u2500 alice_FMKit_0.npy \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 leap_raw \u251c\u2500\u2500 alice_FMKit_0.txt \u2514\u2500\u2500 ... All example signals used in this manual are in the \"data_demo\" folder. These files are packaged in a single zip file on the GitHub repository and they must be unzipped in this folder structure. The following three python modules are demonstrated in this tutorial. fmsignal.py - signal representation, preprocessing, and manipulation. fmsignal_vis.py - signal visualization fmsignal_demo.py - demonstration for this tutorial. To use this code library, please download the Python modules under the \"code_fmkit\" folder and incorporate into your project. A simple way to try the code in this manual is creating a file \"my_code.py\" under the folder \"code_fmkit\", import everything as follows, and run it. from fmsignal import * from fmsignal_vis import * from fmsignal_demo import * # Put the demo code in this manual here. Note that the signal files for the same user writing the same content have the same file names, regardless of the data capture devices or whether they are raw signals or preprocessed signals. They are only differentiated by the folders, and hence, maintaining the correct folder structure is important for the demo.","title":"Installation"},{"location":"manual_signal/#signal-io","text":"This section demonstrates preprocessed signal input/output, raw signal input/ouput, and raw signal preprocessing.","title":"Signal I/O"},{"location":"manual_signal/#preprocessed-signal-io","text":"A preprocessed signal can be constructed from a file as follows. fn = '../date_demo/leap_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn , mode = 'csv' ) This load the file \"alice_FMKit_0.csv\" under the folder \"date_demo/leap_pp\". A signal can also be constructed using a different file format as follows. fn = '../date_demo/leap_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn , mode = 'npy' ) This load the file \"alice_FMKit_0.npy\" under the folder \"date_demo/leap_pp\". These two signals are identical in memory. These files can have two different \"mode\", i.e., \"csv\" for the Comma Separated Value format, and \"npy\" for the NumPy binary format. The \"csv\" format is human readable and programming language agnostic, while the \"npy\" format is only designed to work with Python and NumPy. Loading the files in the \"npy\" format is in general faster than those in the \"csv\" format. Note that the file name does not need to specify the \".csv\" or \".npy\" extension. They are attached automatically by specify the \"mode\". A signal has the three attributes \"user\", \"cid\", and \"seq\" to indicate the user who create this signal, the content ID, and the sequence number. They can be set when a signal is constructed from a file as follows. fn = '../date_demo/leap_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn , mode = 'csv' , user = 'alice' , cid = 'FMKit' , seq = 0 ) If these attributes are not specified at loading, by default, \"user\" is an empty string, \"cid\" is also an empty string, and \"seq\" is zero. A signal can also be saved to a file as follows. fn = '../date_demo/leap_pp/temp/alice_FMKit_0' signal . save_to_file ( fn , mode = 'csv' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_pp/temp\". A signal can also be saved using a different file format as follows. fn = '../date_demo/leap_pp/temp/alice_FMKit_0' signal . save_to_file ( fn , mode = 'npy' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_pp/temp\". The signals are writtent to the folder \"date_demo/leap_pp/temp\" to avoid overwriting the original signal files. Note that the file name does not need to specify the \".csv\" or \".npy\" extension. They are attached automatically by specify the \"mode\". As explained in \" The FMKit Architecture \" document, preprocessed signals are device agnostic and they have a unified format. Although the previous demo only shows those signals generated using the Leap Motion controller device, they can be easily modified to show those signals generated using the data glove device, as follows. fn_load = '../date_demo/glove_pp/alice_FMKit_0' signal = FMSignal . construct_from_file ( fn_load , mode = 'csv' ) fn_save = '../date_demo/glove_pp/temp/alice_FMKit_0' signal . save_to_file ( fn_save , mode = 'npy' ) This loads the file \"alice_FMKit_0.csv\" under the folder \"date_demo/glove_pp\" and saves it to the file \"alice_FMKit_0.npy\" under the folder \"date_demo/glove_pp/temp\"","title":"Preprocessed Signal I/O"},{"location":"manual_signal/#raw-signal-io","text":"A raw signal generated using the Leap Motion controller can also be constructed in a similar way as preprocessed signals. fn = '../date_demo/leap_raw/alice_FMKit_0' raw_signal_leap = FMSignalLeap . construct_from_file ( fn , mode = 'raw_csv' ) This load the file \"alice_FMKit_0.csv\" under the folder \"date_demo/leap_raw\". Similarly, a raw signal generated using the Leap Motion controller can also be constructed using a different file format as follows. fn = '../date_demo/leap_raw/alice_FMKit_0' raw_signal_leap = FMSignalLeap . construct_from_file ( fn , mode = 'raw_npy' ) This load the file \"alice_FMKit_0.npy\" under the folder \"date_demo/leap_raw\". Note that the two file \"modes\" are \"raw_csv\" and \"raw_npy\" but the actual file extensions are just \".csv\" and \".npy\". This is intentional to avoid mistakes of using raw signals as preprocessed signals. The file extensions are attached automatically, similar to the preprocessed signals. Besides these two formats, there is another \"mode\" named \"raw_internal\", which has the file extension \".txt\". Files in this format are generated directly by our client software. There are several versions of the format with small variations, which complicates the code. Hence, they are generally only for internal usage. All released datasets only contains \".csv\" or \".npy\" files. Still, a raw signal generated using the Leap Motion controller can be constructed using the \"raw_internal\" mode as follows. fn = '../date_demo/leap_raw/alice_FMKit_0' raw_signal_leap = FMSignalLeap . construct_from_file ( fn , mode = 'raw_interal' ) This load the file \"alice_FMKit_0.txt\" under the folder \"date_demo/leap_raw\". These signals are identical in memory. They are only different in the formats when saved in files. A raw signal generated using the Leap Motion controller can be saved to a file as follows. fn = '../date_demo/leap_raw/temp/alice_FMKit_0' raw_signal_leap . save_to_file ( fn , mode = 'raw_csv' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_raw/temp\". A raw signal generated using the Leap Motion controller can also be saved using a different file format as follows. fn = '../date_demo/leap_raw/temp/alice_FMKit_0' raw_signal_leap . save_to_file ( fn , mode = 'raw_npy' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/leap_raw/temp\". Note that a raw signal cannot be saved in the \"raw_internal\" format. Besides the Leap Motion controller, raw signals can also generated using our data glove device. This kind of signals can be load in a similar way as follows fn = '../date_demo/glove_raw/alice_FMKit_0' raw_signal_glove = FMSignalGlove . construct_from_file ( fn , mode = 'raw_interal' ) This load the file \"alice_FMKit_0.txt\" under the folder \"date_demo/glove_raw\". The \"mode\" can be \"raw_csv\", \"raw_npy\", or \"raw_internal\", which is the same as the signals generated by the Leap Motion controller. Similarly, they can be saved to files as follows. fn = '../date_demo/glove_raw/temp/alice_FMKit_0' raw_signal_glove . save_to_file ( fn , mode = 'raw_csv' ) This creates the file \"alice_FMKit_0.csv\" containing the signal data under the folder \"date_demo/glove_raw/temp\". The \"mode\" can also be \"raw_npy\".","title":"Raw Signal I/O"},{"location":"manual_signal/#raw-signal-preprocessing","text":"Although the raw signals from two different devices are fundamentally different, both types of signals can be preprocessed to generate the signals in the same format, as explained in \" The FMKit Architecture \" document. A raw signal obtained using the Leap Motion controller device can be preprocessed as follows. signal_leap_pp = raw_signal_leap . preprocess ( point = 'tip' ) Here the \"point\" parameter indicates which point on the hand is used, either the tip of the index finger (i.e., \"tip\") or the center of the hand (i.e., \"center\"). After preprocessing, a new signal is returned, and the original raw signal is also modified. For a raw signal obtained using the data glove, the preprocessing is similar as follows. A raw signal obtained using the Leap Motion controller device can be preprocessed as follows. signal_glove_pp = raw_signal_glove . preprocess ( point = 'tip' ) Here the \"point\" parameter has the same meaning and it can be either \"tip\" or \"center\". Currently, the only usage of a raw signal (i.e., an instance of FMSignalLeap or FMSignalGlove ) is to run the preprocessing procedure to obtain a preprocessed signal (i.e, an instance of FMSignal ). There are other parameters can be set to control the behavior of the preprocessing procedure. See the code reference ( FMSignalLeap.preprocess() or FMSignalGlove.preprocess() ) for further details.","title":"Raw Signal Preprocessing"},{"location":"manual_signal/#helper-functions-for-demo","text":"Since signal I/O is frequently used in the demo, a few helper functions are provided to make the demo code short and succinct. These helper functions are defined in the \" fmsignal_demo.py \". They also assume the file name has the format of \"user_cid_seq.csv\" or \"user_cid_seq.npy\", and the folder structures has the format specified at the beginning of this tutorial. The following global variables are defined for convenience, and they are used to specify the default values for the parameters of these helper functions. FOLDER = '../data_demo' USER = \"alice\" #USER = \"bob\" CID = 'FMKit' #CID = '123456' PP_MODE_LOAD = 'npy' PP_MODE_SAVE = 'npy' RAW_MODE_LOAD = 'raw_internal' RAW_MODE_SAVE = 'raw_npy' LEAP_PP_SUBFOLDER = 'leap_pp' GLOVE_PP_SUBFOLDER = 'glove_pp' LEAP_TEMPLATE_SUBFOLDER = 'leap_template' GLOVE_TEMPLATE_SUBFOLDER = 'glove_template' LEAP_RAW_SUBFOLDER = 'leap_raw' GLOVE_RAW_SUBFOLDER = 'glove_raw' DEVICE = 'leap' #DEVICE = 'glove' A single preprocessed signal for demo can be loaded as follows. signal = load_one_demo_signal_pp () This loads the file \"alice_FMKit_0.npy\" from the folder \"date_demo/leap_pp\" or \"date_demo/glove_pp\" depending on the \"device\" parameter, which can be either \"leap\" or \"glove\". A specific signal can be loaded by setting the parameter to something different from the default values as follows. signal = load_one_demo_signal_pp ( device = 'glove' , user = 'bob' , cid = '123456' , seq = 5 , mode = 'csv' ) This loads the file \"bob_123456_5.csv\" from the folder \"data_demo/glove_pp\". By default, the \"device\" is \"leap\", the \"user\" parameter is \"alice\", the \"cid\" parameter is \"FMKit\", the \"seq\" parameter is 0, the \"mode\" parameter is \"npy\". This function constructs the file name according to these parameters. A collection of signals for demo can be loaded as follows. signals = load_demo_signals_pp () This loads ten files, from \"alice_FMKit_0.npy\" to \"alice_FMKit_9.npy\", all in the folder \"data_demo/leap_pp\", and it returns a list of ten signals. A specific collection of signals can be loaded by setting the parameters to something different from the default values as follows. signals = load_demo_signals_pp ( device = 'glove' , user = 'bob' , cid = '123456' , sequences = [ 5 , 6 ], mode = 'csv' ) This loads two files, i.e., \"bob_123456_5.csv\" and \"bob_123456_6.csv\", all in the folder \"data_demo/glove_pp\", and returns a list of two signals. A signal can be saved at a certain place as follows. save_one_demo_signal_pp ( signal ) This save the signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name as \"user_cid_seq.csv\" using the signal attributes. The parameter \"device\" can be specified to change the target folder. Note that this function can not distinguish the signals from different devices. Users are required to pay attention to save the signal at the correct folder. For example, if the signal is obtained from the data glove device, use save_one_demo_signal_pp(signal, device='glove') instead. A collection of signals can be saved at a certain place as follows. save_demo_signals_pp ( signals ) This saves each signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name for each signal. The parameter \"device\" can be specified to change the target folder. For raw signal I/O, there are similar helper functions as follows. signal_raw = load_one_demo_signal_raw () This loads the file \"alice_FMKit_0.txt\" from the folder \"date_demo/leap_raw\". The parameter \"device\" can be specified to change the folder accordingly. By default it uses the \"raw_internal\" mode. signals_raw = load_demo_signals_raw () This loads ten files, from \"alice_FMKit_0.txt\" to \"alice_FMKit_9.txt\", all in the folder \"date_demo/leap_raw\", and returns a list of ten signals. save_one_demo_signal_raw ( signal ) This save the signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name as \"user_cid_seq.csv\" using the signal attributes. The parameter \"device\" can be specified to change the folder accordingly. A collection of signals can be saved at a certain place as follows. save_demo_signals_raw ( signals ) This saves each signal in the folder \"data_demo/leap_pp/temp\" and it automatically generates the file name for each signal. The parameter \"device\" can be specified to change the folder accordingly. Note that different signals from different devices are only distinguished by the corresponding folders. Similarly, preprocessed signals and raw signals are only distinguished by the corresponding folders. Users need to pay attention to specify the correct folder when loading and saving signals.","title":"Helper Functions For Demo"},{"location":"manual_signal/#signal-visualization","text":"This section demonstrates visualization of preprocessed signals. All functions related to visualization are provided in the \" fmsignal_vis.py \" module. Note that only preprocessed signals can be visualized using these methods (raw signals do not follow the format of 18 sensor axes, and hence, they cannot be visualized in this way). Also, preprocessed signals are sensor agnostic, i.e., the visualization functions does care whether they are obtained from raw signals obtain by the Leap Motion controller device or the data glove device.","title":"Signal Visualization"},{"location":"manual_signal/#visualization-of-one-signal","text":"A signal can be visualized as follows. signal = load_one_demo_signal_pp ( device ) signal_vis ( signal ) This plots the signal data for all 18 sensor axes, as shown in the following figure. The edges of each plot are colored to indicate the sensor axes groups as follows. black - position red - velocity green - linear acceleration blue - orientation cyan - angular speed magenta - angular acceleration Within each color group, the three axes are in the order x-y-z. If there is no need to plot all sensor axes, a subset can be visualized as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) signal_vis ( signal , start_col = 9 , nr_cols = 3 ) This only plots the three axes of orientation, as shown in the following figure. The \"start_col\" means the starting index of the sensor axis (i.e., columns). Note that both \"start_col\" and \"nr_cols\" must be multiples of three, i.e., the plot always bundles three axes of one specific type of physical states in the x-y-z directions together. The plot is also colored accordingly. The signal data for all sensor axes can also be visualized in a compact way as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) signal_vis_compact ( signal ) This plots the signal data in bundles of three axes, as shown in the following figure. The edges of each plot are colored accordingly. Within a plot, the RGB colors of the lines map to the sensor axes x-y-z.","title":"Visualization of One Signal"},{"location":"manual_signal/#signal-comparison","text":"Two signals can be visualized in the same plot for comparison as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_vis_comparison ([ signal_0 , signal_1 ], start_col = 9 , nr_cols = 3 ) This compares the data of two signals in the orientation axes. The result is shown in the following figure. Here, the blue lines are the \"signal_0\" and the orange lines are the \"signal_1\". Since they are generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), the two signals are similar in the visualized sensor axes. The plot is also colored according to the sensor axes groups. Similarly, multiple signals can be compared together as follows. signals = load_demo_signals_pp ( device = 'leap' ) signal_vis_comparison ( signals , start_col = 9 , nr_cols = 3 ) This compares ten signals in the orientation axes. The result is shown in the following figure. Here, each signal has its own color. They are also generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"). This plot shows the inherent \"fuzziness\" in the in-air-handwriting, i.e., even if the same person write the same content multiple times, there are variations in the writing speed and intensity of each stroke. Hence, alignment is needed (see the section \" Signal Alignment and Template \")","title":"Signal Comparison"},{"location":"manual_signal/#trajectory-visualization","text":"This section demonstrates visualization of trajectories for preprocessed signals. This function works for both devices. It also works for both raw signals and preprocessed signals. However, the trajectory of a signal obtained by the data glove device is generally illegible.","title":"Trajectory Visualization"},{"location":"manual_signal/#visualization-of-one-trajectory","text":"The trajectory of one signal can be visualized as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) trajectory_vis ( signal ) This shows the trajectory of a point on the hand (either \"tip\" or \"center\", depending on the preprocessing). The result is shown in the following figure. The view angles are kept moving intentionally to show the 3D structure in this figure. This signal is obtained by the user \"alice\" writing the string \"FMKit\" using the Leap Motion controller device. Note that this user intentionally wrote it in a legible way to facilitate this visualization. Also, the Leap Motion controller device directly records the 3D position of the joints on the hand with an infrared stereo camera. The orientation of the finger can also be shown together with the trajectory as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) trajectory_vis ( signal , show_local_axes = True , interval = 10 ) The result is shown in the following figure. The line segments indicates the axes of the local finger orientation where the RGB colors correspond to x-y-z. The \"interval=10\" parameter means for every 10 samples of the time series, the local axes are plot once.","title":"Visualization of One Trajectory"},{"location":"manual_signal/#trajectory-comparison","text":"Two trajectories from two signals can be visualized together for comparison as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) trajectorie_vis_comparison ([ signal_0 , signal_1 ]) The result is shown in the following figure. Since these two signals are generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), the trajectories are close to each other. Similarly, more trajectories can be visualized together as follows. signals = load_demo_signals_pp ( device = 'leap' ) trajectorie_vis_comparison ( signals ) The result is shown in the following figure. Each trajectory has its own color. Since they are all generated by the same person (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), the trajectories are all similar in shape. Note that the preprocessing procedure normalize the pose of the in-air-handwriting, and hence, the relative pose between the in-air-handwriting and the sensor does not matter.","title":"Trajectory Comparison"},{"location":"manual_signal/#trajectory-animation","text":"As the in-air-handwriting signal is a time series of physical states of the hand, the process of generating the trajectory can be reproduced using the signal data as follows. signal = load_one_demo_signal_pp ( device = 'leap' ) trajectory_animation ( signal , seg_length = 30 ) This generates the following animation. Essentially, this function plot the trajectory of a signal segment in a sliding-forward window. The parameter \"seg_length\" controls the length of the signal segment. If it is less or equal to zero, the whole signal is plotted (by default it is zero). This is designed to facilitate the visual confirmation of the signal content for those users who write all letters in the same place.","title":"Trajectory Animation"},{"location":"manual_signal/#trajectory-and-hand-geometry-animation","text":"If a signal is obtained using the Leap Motion controller device, the raw signal contains the position of each joint on the hand, and the hand geometry can be animated together with the trajectory as follows. raw_signal = load_one_demo_signal_raw ( device = 'leap' ) raw_signal . preprocess ( point = 'tip' ) trajectory_animation ( raw_signal , seg_length = 30 ) Note that the raw signal still needs preprocessing for pose normalization and filtering (which is essential to generate the \"trajectory\" attribute and the \"joints\" attribute). The hand geometry plot works only for raw signals from the Leap Motion controller device. It does not work for preprocessed signals or raw signals from the data glove (because they do not have the \"joints\" attribute). This generates the following animation. This plots the position of the joints for each data sample at a time and make an animation.","title":"Trajectory and Hand Geometry Animation"},{"location":"manual_signal/#orientation-animation","text":"Since the data glove device can only obtain angular speed and linear acceleration directly, the trajectory of a signal obtained by the data glove device is derived indirectly (usually with some regularization to prevent the unbounded accumulation of errors in the dead reckoning procedure). This trajectory does not represent the actual trajectory of the hand, and this usually means that the visualization of such a \"trajectory\" is usually not legible. To check the signals from the data glove in a human understandable way, the orientation can be animated as follows. raw_signal = load_one_demo_signal_raw ( device = 'glove' , cid = '123456' ) raw_signal . preprocess ( point = 'tip' ) orientation_animation ( raw_signal , seg_length = 20 ) The result is shown as follows. This plots the x-y-z axes of each sample in an animation to show the orientation of the point on the hand. The animation also plots the trajectory of the end point of the x-axis. The signal is obtained by the user \"alice\" writing the string \"123456\". Clearly a person can visually confirm the writing content is \"123456\" with this animation. However, not every user write strings in this way. Some user will maintain the pointing direction of the finger while moving the arm as a whole in the air to write like on an invisible wall. Although it is designed mainly for signals obtained from the data glove device, this function works for both devices. It also works for both raw signals and preprocessed signals.","title":"Orientation Animation"},{"location":"manual_signal/#signal-alignment-and-template","text":"This section demostrates signal alignment with the Dynamic Time Warp (DTW) algorithm.","title":"Signal Alignment and Template"},{"location":"manual_signal/#signal-alignment-visualization","text":"A preprocessed signal can be aligned to another preprocessed signal using DTW as follow. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_0 . amplitude_normalize () signal_1 . amplitude_normalize () signal_1_aligned = signal_1 . align_to ( signal_0 ) aligned = [ signal_0 , signal_1_aligned ] unaligned = [ signal_0 , signal_1 ] signal_vis_comparison_side_by_side ( aligned , unaligned , start_col = 0 , nr_cols = 9 ) The difference before the alignment and after the alignment is shown in the following figure. These two signals are generated by the same user (i.e., \"alice\") writing the same content (i.e., \"FMKit\"). As mentioned previously in the \" Signal Comparison \" subsection, even for signals generated by the same user writing the same content, there are differences, mainly in the writing speed and the intensity of strokes. As the figure shows, these differences can be reduced by aligning one signal to the other signal along the time using DTW. The function \"signal_vis_comparison_side_by_side()\" is designed to plot two sets of signals side by side on two columns for comparison.","title":"Signal Alignment Visualization"},{"location":"manual_signal/#warping-path-visualization","text":"The detailed warping path of the alignment of on signal to another signal (or a template) can be visualized as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_0 . amplitude_normalize () signal_1 . amplitude_normalize () signal_1_aligned = signal_1 . align_to ( signal_0 , keep_dist_matrix = True ) alignment_vis ( signal_1 , signal_0 , signal_1_aligned , col = 9 ) The result is shown in the following figure. The subplot named \"template\" means the template signal (i.e., \"signal_0\" in this demo), and the subplot named \"signal\" is the signal that is aligned to the template signal (i.e., \"signal_1\" in this demo). This figure essentially shows the DTW distance matrix (i.e., the \"dist_matrix\" attribute of the \"signal_1_aligned\") together with the two signals. The specific sensor axis representing the signal and the template can be selected by setting the \"col\" parameter to the sensor axis index. The warping path can also be visualized in 3D as follows. signal_0 = load_one_demo_signal_pp ( device = 'leap' , seq = 0 ) signal_1 = load_one_demo_signal_pp ( device = 'leap' , seq = 1 ) signal_0 . amplitude_normalize () signal_1 . amplitude_normalize () signal_1_aligned = signal_1 . align_to ( signal_0 , keep_dist_matrix = True ) alignment_vis ( signal_1 , signal_0 , signal_1_aligned , plot_3d = True ) The result is shown in the following figure. This 3D visualization plot the DTW distance matrix in 3D. These two signals are generated by the same user (i.e., \"alice\") writing the same content (i.e., \"FMKit\"), and this user can maintain the same writing behavior very well across multiple repetitions. Hence, these two signals can be alsigned very well and the warping path is close to the diagonal line. In fact, any signal can be aligned to another signal using DTW regardless whether they are generated by the same user or writing the same content. The warping path can vary significantly based on the shapes of the two signals.","title":"Warping Path Visualization"},{"location":"manual_signal/#template-visualization","text":"For multiple repetitions of the in-air-handwriting of the same content by the same user, they can be all aligned to one signal and to construct a template by taking the average of them as follows. signals = load_demo_signals_pp ( device = device , user = user , cid = cid ) template = FMSignalTemplate . construct_from_signals ( signals , template_index = 0 ) signals_alinged = template . signals_aligned signal_vis_comparison_side_by_side ( signals_alinged , signals , start_col = 0 , nr_cols = 9 ) signal_vis_comparison_side_by_side ( signals_alinged , [ template ], start_col = 0 , nr_cols = 9 ) This will first show the comparison of ten aligned signals and the original ones as follows. The aligned signals are on the left and the original ones are on the right. After closing the first plot, the aligned signals and the template are shown in the following figure. The function \"FMSignalTemplate.construct_from_signals()\" does alignment and template construction. The \"template_index\" parameter indicate which signal in the set is used as the \"base signal\" so that other signals are aligned to it. A template, i.e., an instance of the \" FMSignalTemplate \", is essentially the same as a preprocessed signal, only with an additional attribute to keep the variations of the original signals. A template can be saved to a file as follows, which is the same as saving a signal. The mode can be either \"csv\" or \"npy\". fn = '../date_demo/leap_template/alice_FMKit_0' template ( fn , mode = 'csv' ) A template can also be loaded from a file as follows, which is also the same as loading a signal. fn = '../date_demo/leap_template/alice_FMKit_0' template = FMSignalTemplate . construct_from_file ( fn , mode = 'csv' ) A template also has the \"user\" attribute, the \"cid\" attribute, and the \"seq\" attribute. If a template is constructed from a set of signals, its \"user\" and \"cid\" attributes are copied from the \"base signal\" indicated by the \"template_index\" parameter in \"FMSignalTemplate.construct_from_signals()\". The \"seq\" attribute is always set to 0. The demo also provide two helper functions as follows, one for loading, and the other for saving. template = load_one_demo_template () save_one_demo_template ( template )","title":"Template Visualization"},{"location":"manual_signal/#improving-dtw-efficiency","text":"The default DTW implementation is in Python, which is relatively inefficient because it will iterate through the two signal data and the n-by-m DTW distance matrix (which are all NumPy ndarrays). To improve the efficiency, a version implemented in C is provided under the \" code_utilities \" folder. It can be installed as follows. # cd code_utilities # python3 ./setup.py build # sudo python3 setup.py install --record ./files.txt If the build step cannot find numpy header files, run the following first. # export CFLAGS=\"-I $HOME/.local/lib/python3.6/site-packages/numpy/core/include $CFLAGS\" Here the path after \"-I\" is the place where NumPy is installed. This will install a package named \"fmkit_utilities\" which introduces a function \"fmkit_utilities.dtw_c()\". It will be shown as a \"built-in\" function because it is implemented in C code. The \" fmsignal.py \" module has a Python wrapper function \" dtw_c() \" that calls the C implementation. This wrapper function takes the exact same format of parameters as the default Python implementation. The \" fmsignal.py \" module will use the C implementation automatically if the \"fmkit_utilities\" package is installed. This is made using the following code at the beginning of the module. try : import fmkit_utilities DTW_METHOD = \"c\" except ImportError : DTW_METHOD = \"python\" The only method that invokes \" dtw() \" or \" dtw_c() \" is \" FMSignal.align_to() \", i.e., aligning on signal to another signal or template. It takes a parameter named \"method\", which is set to \"DTW_METHOD\" by default. Users can choose which implementations to use as follows. signal_aligned = signal . align_to ( template , method = \"python\" ) # This uses the Python implementation. Or signal_aligned = signal . align_to ( template , method = \"c\" ) # This uses the C implementation. Note that the C implementation is kind of \"fragile\", and hence, it is recommended to always use the wrapper \" FMSignal.dtw_c() \" instead of directly using the \"fmkit_utilities.dtw_c()\".","title":"Improving DTW Efficiency"},{"location":"process/","text":"Signal Processing Details Preprocessing Signal Alignment Signal Augmentation","title":"Signal Processing Details"},{"location":"process/#signal-processing-details","text":"","title":"Signal Processing Details"},{"location":"process/#preprocessing","text":"","title":"Preprocessing"},{"location":"process/#signal-alignment","text":"","title":"Signal Alignment"},{"location":"process/#signal-augmentation","text":"","title":"Signal Augmentation"},{"location":"pyrotation-reference/","text":"pyrotation module This file is part of the pyrotation python module, which is designed to help teaching and learning the math of 3D rotation. This file contains the core class and functions of 3D rotation. Author: Duo Lu duolu.cs@gmail.com Version: 0.1 License: MIT Updated on Jan. 28, 2020, version 0.1 Created on Mar 22, 2019, draft The MIT License Copyright 2017-2021 Duo Lu < duolu.cs@gmail.com > Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Quaternion The class representing a quaternion in Hamiltonian convention. !!! note \"The Quaternion object is designed to be immutable after construction.\" __init__ ( self , w , x , y , z ) special Constructor, wchich expects the four components of a quaternion. Source code in code_fmkit/pyrotation.py def __init__ ( self , w , x , y , z ): ''' Constructor, wchich expects the four components of a quaternion. ''' self . w = float ( w ) self . x = float ( x ) self . y = float ( y ) self . z = float ( z ) add_quaternion ( self , q ) Quaternion addition. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def add_quaternion ( self , q ): ''' Quaternion addition. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' w_add = self . w + q . w x_add = self . x + q . x y_add = self . y + q . y z_add = self . z + q . z return Quaternion ( w_add , x_add , y_add , z_add ) angle_axis_to_quaternion ( u ) staticmethod Convert an angle-axis representation of a 3D rotation to a unit quaternion. This is essentially the exponential map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_angle_axis(u) See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (101). Source code in code_fmkit/pyrotation.py @staticmethod def angle_axis_to_quaternion ( u ): ''' Convert an angle-axis representation of a 3D rotation to a unit quaternion. This is essentially the exponential map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_angle_axis(u) See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (101). ''' angle = np . linalg . norm ( u ) if angle < EPSILON : w = 1.0 x = 0.0 y = 0.0 z = 0.0 else : u = u / angle w = cos ( angle / 2 ) s = sin ( angle / 2 ) x = u [ 0 ] * s y = u [ 1 ] * s z = u [ 2 ] * s return w , x , y , z conjugate ( self ) Return the conjugate of this quaternion. Notation: q* is q.conjugate() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def conjugate ( self ): ''' Return the conjugate of this quaternion. Notation: q* is q.conjugate() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' return Quaternion ( self . w , - self . x , - self . y , - self . z ) construct_from_angle_axis ( u ) classmethod Construct a quaternion from angle-axis representation of a rotation. This is essentially the exponential map. Source code in code_fmkit/pyrotation.py @classmethod def construct_from_angle_axis ( cls , u ): ''' Construct a quaternion from angle-axis representation of a rotation. This is essentially the exponential map. ''' w , x , y , z = cls . angle_axis_to_quaternion ( u ) q = cls ( w , x , y , z ) q = q . normalize () return q construct_from_rotation_matrix ( R ) classmethod Construct a quaternion from a rotation matrix. Source code in code_fmkit/pyrotation.py @classmethod def construct_from_rotation_matrix ( cls , R ): ''' Construct a quaternion from a rotation matrix. ''' w , x , y , z = cls . rotation_matrix_to_quaternion ( R ) q = cls ( w , x , y , z ) #q = q.normalize() return q differentiate_local ( q1 , q2 , timestep ) classmethod Given two quaternions representing two poses q1 and q2, and assuming q2 is derived by a rotation from the first psoe q1 during a timestep, this method returns the angular speed (i.e., omega) of the local reference frame respect to pose q1. This is exactly the inverse of integrate_local(). Source code in code_fmkit/pyrotation.py @classmethod def differentiate_local ( cls , q1 , q2 , timestep ): ''' Given two quaternions representing two poses q1 and q2, and assuming q2 is derived by a rotation from the first psoe q1 during a timestep, this method returns the angular speed (i.e., omega) of the local reference frame respect to pose q1. This is exactly the inverse of integrate_local(). ''' delta_q = q1 . conjugate () . multiply_quaternion ( q2 ) u = delta_q . to_angle_axis () omega = u / timestep return omega identity () classmethod Return the identity unit quaternion (1, 0, 0, 0). Source code in code_fmkit/pyrotation.py @classmethod def identity ( cls ): ''' Return the identity unit quaternion (1, 0, 0, 0). ''' return cls ( 1 , 0 , 0 , 0 ) integrate_local ( q , omega , timestep ) classmethod Integrate instantanious angular velocity (i.e., omega) to the quaternion q during the timestep. The result is also a quaternion. Note that the angular velocity is measured relative to the pose represented by this quaternion, i.e., consider the current pose is this quaternion and omega is measured by a gyroscope. Anguler velocity is in rad/sec, and timestep is in sec. Note that we use zeroth-order backward integration. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 4.6. Source code in code_fmkit/pyrotation.py @classmethod def integrate_local ( cls , q , omega , timestep ): ''' Integrate instantanious angular velocity (i.e., omega) to the quaternion q during the timestep. The result is also a quaternion. Note that the angular velocity is measured relative to the pose represented by this quaternion, i.e., consider the current pose is this quaternion and omega is measured by a gyroscope. Anguler velocity is in rad/sec, and timestep is in sec. Note that we use zeroth-order backward integration. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 4.6. ''' u = omega * timestep delta_q = cls . construct_from_angle_axis ( u ) p = q . multiply_quaternion ( delta_q ) return p interpolate ( q0 , q1 , t ) classmethod Spherical linear interpolation (SLERP) given two orientations represented by the quaternion q0 and q1, and interpolation parameter t in [0, 1], such that the orientation will continuously change from q0 to q1 by rotating along a fixed axis when t changes. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 2.7. Source code in code_fmkit/pyrotation.py @classmethod def interpolate ( cls , q0 , q1 , t ): ''' Spherical linear interpolation (SLERP) given two orientations represented by the quaternion q0 and q1, and interpolation parameter t in [0, 1], such that the orientation will continuously change from q0 to q1 by rotating along a fixed axis when t changes. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 2.7. ''' if t == 0 : return q0 elif t == 1 : return q1 elif t > 0 and t < 1 : delta_q = q0 . conjugate () . multiply_quaternion ( q1 ) u = delta_q . to_angle_axis () qut = cls . construct_from_angle_axis ( u * t ) qt = q0 . multiply_quaternion ( qut ) return qt else : err_str = 'Interpolation parameter t must be in [0, 1], ' \\ 'while t = %f !' % t raise ValueError ( err_str ) inverse ( self ) Return the inverse of this quaternion. Notation: q-1 is q.inverse() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def inverse ( self ): ''' Return the inverse of this quaternion. Notation: q-1 is q.inverse() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' w = self . w x = self . x y = self . y z = self . z a = 1 / ( w * w + x * x + y * y + z * z ) return Quaternion ( self . w * a , - self . x * a , - self . y * a , - self . z * a ) multiply_quaternion ( self , q ) Quaternion multiplication. Notation: r = p x q is r = p.multiply_quaternion(q), where \"x\" is quaternion multiplication. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def multiply_quaternion ( self , q ): ''' Quaternion multiplication. Notation: r = p x q is r = p.multiply_quaternion(q), where \"x\" is quaternion multiplication. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' if not isinstance ( q , Quaternion ): raise 'Can not multiply non-quaternion! q= %s ' % repr ( q ) pw = self . w px = self . x py = self . y pz = self . z qw = q . w qx = q . x qy = q . y qz = q . z w_mul = pw * qw - px * qx - py * qy - pz * qz x_mul = pw * qx + px * qw + py * qz - pz * qy y_mul = pw * qy - px * qz + py * qw + pz * qx z_mul = pw * qz + px * qy - py * qx + pz * qw return Quaternion ( w_mul , x_mul , y_mul , z_mul ) multiply_scaler ( self , s ) Multiply each component with a scalar. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under scaling. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def multiply_scaler ( self , s ): ''' Multiply each component with a scalar. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under scaling. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' return Quaternion ( self . w * s , self . x * s , self . y * s , self . z * s ) norm ( self ) Return the norm of this quaternion. Notation: |q| is q.norm() Source code in code_fmkit/pyrotation.py def norm ( self ): ''' Return the norm of this quaternion. Notation: |q| is q.norm() ''' w = self . w x = self . x y = self . y z = self . z return sqrt ( w * w + x * x + y * y + z * z ) normalize ( self ) Return a normalized unit quaternion based on this quaternion. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def normalize ( self ): ''' Return a normalized unit quaternion based on this quaternion. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' n = self . norm () w = self . w / n x = self . x / n y = self . y / n z = self . z / n return Quaternion ( w , x , y , z ) quaternion_to_angle_axis ( w , x , y , z ) staticmethod Convert a unit quaternion representation of a 3D rotation to angle-axis representation. This is essentially the logrithmic map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. u = q.to_angle_axis(u) Source code in code_fmkit/pyrotation.py @staticmethod def quaternion_to_angle_axis ( w , x , y , z ): ''' Convert a unit quaternion representation of a 3D rotation to angle-axis representation. This is essentially the logrithmic map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. u = q.to_angle_axis(u) ''' v_norm = sqrt ( x * x + y * y + z * z ) if v_norm < EPSILON : ux = 0 uy = 0 uz = 0 else : angle = 2 * atan2 ( v_norm , w ) ux = x * ( angle / v_norm ) uy = y * ( angle / v_norm ) uz = z * ( angle / v_norm ) u = np . asarray (( ux , uy , uz )) return u quaternion_to_rotation_matrix ( w , x , y , z ) staticmethod Convert a unit quaternion to a rotation matrix. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. R = q.to_rotation_matrix() Source code in code_fmkit/pyrotation.py @staticmethod def quaternion_to_rotation_matrix ( w , x , y , z ): ''' Convert a unit quaternion to a rotation matrix. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. R = q.to_rotation_matrix() ''' w2 = w * w x2 = x * x y2 = y * y z2 = z * z # Check the norm of the quaternion! It must be a unit quaternion! assert fabs ( w2 + x2 + y2 + z2 - 1 ) < 1e-6 wx = 2 * w * x wy = 2 * w * y wz = 2 * w * z xy = 2 * x * y xz = 2 * x * z yz = 2 * y * z R = np . asarray (( ( w2 + x2 - y2 - z2 , xy - wz , xz + wy ), ( xy + wz , w2 - x2 + y2 - z2 , yz - wx ), ( xz - wy , yz + wx , w2 - x2 - y2 + z2 ) )) return R rotate_a_point ( self , p ) Rotate a single 3D point based on this quaternion. The input point is a numpy array of three element. Internally, it is converted to a vector v = (0, x, y, z) and use the following equation. v' = q x v x q* where x is quaternion multiplication. The implementation uses the following matrix-based method, q x v x p = (q x v) x p = p_R * q_L * v = q x (v x p) = q_L * p_R * v Source code in code_fmkit/pyrotation.py def rotate_a_point ( self , p ): ''' Rotate a single 3D point based on this quaternion. The input point is a numpy array of three element. Internally, it is converted to a vector v = (0, x, y, z) and use the following equation. v' = q x v x q* where x is quaternion multiplication. The implementation uses the following matrix-based method, q x v x p = (q x v) x p = p_R * q_L * v = q x (v x p) = q_L * p_R * v ''' q_L = self . to_left_matrix () qc_R = self . conjugate () . to_right_matrix () v = np . asarray (( 0 , p [ 0 ], p [ 1 ], p [ 2 ])) . reshape (( 4 , 1 )) r = np . matmul ( qc_R , np . matmul ( q_L , v )) return np . asarray (( r [ 1 ], r [ 2 ], r [ 3 ])) . reshape ( 3 ) rotate_points ( self , ps ) Rotate an array of points. The input points are a numpy 3-by-n matrix, where each point is a column. Source code in code_fmkit/pyrotation.py def rotate_points ( self , ps ): ''' Rotate an array of points. The input points are a numpy 3-by-n matrix, where each point is a column. ''' q_L = self . to_left_matrix () qc_R = self . conjugate () . to_right_matrix () vs = np . zeros (( 4 , ps . shape [ 1 ]), ps . dtype ) vs [ 1 : 4 , :] = ps rs = np . matmul ( qc_R , np . matmul ( q_L , vs )) return rs [ 1 : 4 , :] rotation_matrix_to_quaternion ( R ) staticmethod Convert a rotation matrix to a unit quaternion. This uses the Shepperd\u2019s method for numerical stabilty. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_rotation_matrix(R) Source code in code_fmkit/pyrotation.py @staticmethod def rotation_matrix_to_quaternion ( R ): ''' Convert a rotation matrix to a unit quaternion. This uses the Shepperd\u2019s method for numerical stabilty. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_rotation_matrix(R) ''' # The rotation matrix must be orthonormal assert np . allclose ( np . dot ( R , R . transpose ()), np . eye ( 3 ), atol = EPSILON ) # Check the determinant of R! It must be 1. assert math . isclose ( np . linalg . det ( R ), 1 , abs_tol = EPSILON ) w2 = ( 1 + R [ 0 , 0 ] + R [ 1 , 1 ] + R [ 2 , 2 ]) x2 = ( 1 + R [ 0 , 0 ] - R [ 1 , 1 ] - R [ 2 , 2 ]) y2 = ( 1 - R [ 0 , 0 ] + R [ 1 , 1 ] - R [ 2 , 2 ]) z2 = ( 1 - R [ 0 , 0 ] - R [ 1 , 1 ] + R [ 2 , 2 ]) yz = ( R [ 1 , 2 ] + R [ 2 , 1 ]) xz = ( R [ 2 , 0 ] + R [ 0 , 2 ]) xy = ( R [ 0 , 1 ] + R [ 1 , 0 ]) wx = ( R [ 2 , 1 ] - R [ 1 , 2 ]) wy = ( R [ 0 , 2 ] - R [ 2 , 0 ]) wz = ( R [ 1 , 0 ] - R [ 0 , 1 ]) if R [ 2 , 2 ] < 0 : if R [ 0 , 0 ] > R [ 1 , 1 ]: x = sqrt ( x2 ) w = wx / x y = xy / x z = xz / x else : y = sqrt ( y2 ) w = wy / y x = xy / y z = yz / y else : if R [ 0 , 0 ] < - R [ 1 , 1 ]: z = sqrt ( z2 ) w = wz / z x = xz / z y = yz / z else : w = sqrt ( w2 ) x = wx / w y = wy / w z = wz / w w = w * 0.5 x = x * 0.5 y = y * 0.5 z = z * 0.5 return w , x , y , z subtract_quaternion ( self , q ) Quaternion subtraction. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def subtract_quaternion ( self , q ): ''' Quaternion subtraction. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' w_sub = self . w - q . w x_sub = self . x - q . x y_sub = self . y - q . y z_sub = self . z - q . z return Quaternion ( w_sub , x_sub , y_sub , z_sub ) to_angle_axis ( self ) Convert this quaternion to angle-axis representation of rotation. This is the reverse of construct_from_angle_axis() This is essentially the logarithmic map. See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (106). CAUTION: This must be a unit quaternion! Source code in code_fmkit/pyrotation.py def to_angle_axis ( self ): ''' Convert this quaternion to angle-axis representation of rotation. This is the reverse of construct_from_angle_axis() This is essentially the logarithmic map. See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (106). CAUTION: This must be a unit quaternion! ''' assert ( fabs ( self . norm () - 1 ) < EPSILON ) w = self . w x = self . x y = self . y z = self . z return self . quaternion_to_angle_axis ( w , x , y , z ) to_left_matrix ( self ) Return the left matrix of this quaternion. Notation: p_L = p.to_left_matrix() p x q = p_L * q, where \"*\" is matrix multiplication, and q can be considered as a 4 by 1 matrix. Source code in code_fmkit/pyrotation.py def to_left_matrix ( self ): ''' Return the left matrix of this quaternion. Notation: p_L = p.to_left_matrix() p x q = p_L * q, where \"*\" is matrix multiplication, and q can be considered as a 4 by 1 matrix. ''' w = self . w x = self . x y = self . y z = self . z M = np . asarray (( ( w , - x , - y , - z ), ( x , w , - z , y ), ( y , z , w , - x ), ( z , - y , x , w ) )) return M to_right_matrix ( self ) Return the right matrix of this quaternion. Notation: q_R is q.to_right_matrix() p x q = q_R * p, where \"*\" is matrix multiplication, and q is considered as a 4 by 1 matrix. Source code in code_fmkit/pyrotation.py def to_right_matrix ( self ): ''' Return the right matrix of this quaternion. Notation: q_R is q.to_right_matrix() p x q = q_R * p, where \"*\" is matrix multiplication, and q is considered as a 4 by 1 matrix. ''' w = self . w x = self . x y = self . y z = self . z M = np . asarray (( ( w , - x , - y , - z ), ( x , w , z , - y ), ( y , - z , w , x ), ( z , y , - x , w ) )) return M to_rotation_matrix ( self ) Convert this unit quaternion to a rotation matrix. CAUTION: This must be a unit quaternion! Source code in code_fmkit/pyrotation.py def to_rotation_matrix ( self ): ''' Convert this unit quaternion to a rotation matrix. CAUTION: This must be a unit quaternion! ''' assert ( fabs ( self . norm () - 1 ) < EPSILON ) w = self . w x = self . x y = self . y z = self . z return self . quaternion_to_rotation_matrix ( w , x , y , z ) alt_azimuth_to_axis ( alt_degree , azimuth_degree ) Calculate an axis represented by a unit vector using alt and azimuth angles. NOTE: alt and azimuth are in degree, not radian. The output axis is always a unit vector. Source code in code_fmkit/pyrotation.py def alt_azimuth_to_axis ( alt_degree , azimuth_degree ): ''' Calculate an axis represented by a unit vector using alt and azimuth angles. NOTE: alt and azimuth are in degree, not radian. The output axis is always a unit vector. ''' alt_radian = alt_degree * np . pi / 180 azimuth_radian = azimuth_degree * np . pi / 180 ux = cos ( alt_radian ) * cos ( azimuth_radian ) uy = cos ( alt_radian ) * sin ( azimuth_radian ) uz = sin ( alt_radian ) u = np . asarray (( ux , uy , uz )) u = u / np . linalg . norm ( u ) return u angle_axis_to_rotation_matrix ( u ) Convert angle-axis representation of rotation to a rotation matrix, using the Rodrigues formula. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). Source code in code_fmkit/pyrotation.py def angle_axis_to_rotation_matrix ( u ): ''' Convert angle-axis representation of rotation to a rotation matrix, using the Rodrigues formula. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). ''' angle = np . linalg . norm ( u ) I = np . identity ( 3 ) if angle < EPSILON : return I else : # normalize the axis vector u = u / np . linalg . norm ( u ) ux = vector_to_skew_symmetric_matrix ( u ) uut = np . matmul ( u . reshape (( 3 , 1 )), u . reshape ( 1 , 3 )) R = I * cos ( angle ) + ux * sin ( angle ) + uut * ( 1 - cos ( angle )) return R axis_to_alt_azimuth ( u ) Calculate the alt and azimuth angles from an axis vector \"u\". NOTE: alt and azimuth are in degree, not radian. CAUTION: In the degenerated case, where the norm of the vector u is zero, i.e., the vector u is pointting to the z-axis or the opposite of the z-axis, the output alt is set to plus/minus 90 degrees and the azimuth to zero degrees. Source code in code_fmkit/pyrotation.py def axis_to_alt_azimuth ( u ): ''' Calculate the alt and azimuth angles from an axis vector \"u\". NOTE: alt and azimuth are in degree, not radian. CAUTION: In the degenerated case, where the norm of the vector u is zero, i.e., the vector u is pointting to the z-axis or the opposite of the z-axis, the output alt is set to plus/minus 90 degrees and the azimuth to zero degrees. ''' u_norm = np . linalg . norm ( u ) if fabs ( fabs ( u_norm ) - 1 ) < EPSILON : degenerated = True alt = 90 azimuth = 0 gimbal_lock = False else : degenerated = False u = u / u_norm if fabs ( u [ 2 ] - 1 ) < EPSILON : # CAUTION: if u is pointing to the z-axis, the result is degenerated, # i.e., azimuth is undefined. alt = 90 azimuth = 0 gimbal_lock = True elif fabs ( u [ 2 ] + 1 ) < EPSILON : # Similarly, if u is pointing to the opposite of the z-axis, azimuth is # also undefined. alt = - 90 azimuth = 0 gimbal_lock = True else : alt = asin ( u [ 2 ]) c = cos ( alt ) dx = u [ 0 ] / c dy = u [ 1 ] / c azimuth = atan2 ( dy , dx ) alt = alt * 180 / pi azimuth = azimuth * 180 / pi gimbal_lock = False return alt , azimuth , gimbal_lock , degenerated euler_zyx_to_rotation_matrix ( z , y , x ) Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation, i.e., using the following, R = R_z * R_y * R_x where, R_z = [ cos(z) -sin(z) 0 ] [ sin(z) cos(z) 0 ] [ 0 0 1 ] R_y = [ cos(y) 0 sin(y) ] [ 0 1 0 ] [ -sin(y) 0 cos(y) ] R_x = [ 1 0 0 ] [ 0 cos(x) -sin(x) ] [ 0 sin(x) cos(x) ] Also, the angles are named as following, z - yaw (psi) y - pitch (theta) x - roll (phi) These angles are also called Tait-Bryan angles, and we use the z-y'-x\" intrinsic convention. See this for the conventions: https://en.wikipedia.org/wiki/Euler_angles#Tait\u2013Bryan_angles Also see this for the conversion between different representations: https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimension Caution: The three input angles are in radian! Source code in code_fmkit/pyrotation.py def euler_zyx_to_rotation_matrix ( z , y , x ): ''' Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation, i.e., using the following, R = R_z * R_y * R_x where, R_z = [ cos(z) -sin(z) 0 ] [ sin(z) cos(z) 0 ] [ 0 0 1 ] R_y = [ cos(y) 0 sin(y) ] [ 0 1 0 ] [ -sin(y) 0 cos(y) ] R_x = [ 1 0 0 ] [ 0 cos(x) -sin(x) ] [ 0 sin(x) cos(x) ] Also, the angles are named as following, z - yaw (psi) y - pitch (theta) x - roll (phi) These angles are also called Tait-Bryan angles, and we use the z-y'-x\" intrinsic convention. See this for the conventions: https://en.wikipedia.org/wiki/Euler_angles#Tait\u2013Bryan_angles Also see this for the conversion between different representations: https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimension Caution: The three input angles are in radian! ''' sz = np . sin ( z ) cz = np . cos ( z ) sy = np . sin ( y ) cy = np . cos ( y ) sx = np . sin ( x ) cx = np . cos ( x ) a11 = cz * cy a12 = cz * sy * sx - cx * sz a13 = sz * sx + cz * cx * sy a21 = cy * sz a22 = cz * cx + sz * sy * sx a23 = cx * sz * sy - cz * sx a31 = - sy a32 = cy * sx a33 = cy * cx R = np . asarray ([[ a11 , a12 , a13 ], [ a21 , a22 , a23 ], [ a31 , a32 , a33 ]]) return R normalize_rotation_matrix ( R ) Normalize a rotation matrix with SVD, i.e., using the following step. u, s, vh = np.linalg.svd(R) return np.matmul(u, vh) Source code in code_fmkit/pyrotation.py def normalize_rotation_matrix ( R ): ''' Normalize a rotation matrix with SVD, i.e., using the following step. u, s, vh = np.linalg.svd(R) return np.matmul(u, vh) ''' u , s , vh = np . linalg . svd ( R ) del s return np . matmul ( u , vh ) orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) Construct three orthonormal basis vectors from arbitrary two vectors. The output orthonormal basis (u1, u2, u3) has the following properties. (1) The vector u1 is in the direction of v1. If v1 is all zero, v1_default is used instead. (2) The vector u2 is in the same plane spanned by v1 and v2, and u2 is perpendicular to v1, i.e., their dot product is zero. If v2 is all zero or if v2 has the same direction as v1, v2_default is used instead. (3) The vector u3 is perpendicular to the plane spanned by v1 and v2. Source code in code_fmkit/pyrotation.py def orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ): ''' Construct three orthonormal basis vectors from arbitrary two vectors. The output orthonormal basis (u1, u2, u3) has the following properties. (1) The vector u1 is in the direction of v1. If v1 is all zero, v1_default is used instead. (2) The vector u2 is in the same plane spanned by v1 and v2, and u2 is perpendicular to v1, i.e., their dot product is zero. If v2 is all zero or if v2 has the same direction as v1, v2_default is used instead. (3) The vector u3 is perpendicular to the plane spanned by v1 and v2. ''' n1 = np . linalg . norm ( v1 ) n2 = np . linalg . norm ( v2 ) v3 = np . cross ( v1 , v2 ) n3 = np . linalg . norm ( v3 ) if fabs ( n1 ) < EPSILON : v1 = v1_default if fabs ( n2 ) < EPSILON or fabs ( n3 ) < EPSILON : v2 = v2_default u1 = v1 / np . linalg . norm ( v1 ) v3 = np . cross ( u1 , v2 ) u3 = v3 / np . linalg . norm ( v3 ) v2 = np . cross ( u3 , u1 ) u2 = v2 / np . linalg . norm ( v2 ) return u1 , u2 , u3 rotate_a_point_by_angle_axis ( p , u ) Rotate a point \"p\" along the axis \"u\" by an angle which is the norm of \"u\". Both \"p\" and \"u\" are numpy arrays of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). Source code in code_fmkit/pyrotation.py def rotate_a_point_by_angle_axis ( p , u ): ''' Rotate a point \"p\" along the axis \"u\" by an angle which is the norm of \"u\". Both \"p\" and \"u\" are numpy arrays of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). ''' angle = np . linalg . norm ( u ) if fabs ( angle ) < EPSILON : return p else : # normalize the axis vector u = u / np . linalg . norm ( u ) pp = np . dot ( p , u ) * u pv = p - pp u_x_cross = np . cross ( u , p ) rp = pp + pv * np . cos ( angle ) + u_x_cross * np . sin ( angle ) return rp rotate_a_point_by_rotation_matrix ( R , p ) Rotate a point \"p\" by a rotation matrix \"R\". \"p\" must be a numpy array of three elements. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy array of three elements, same as the input \"p\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rp = np.matmul(R, p.reshape(3, 1)) return rp.flatten() Source code in code_fmkit/pyrotation.py def rotate_a_point_by_rotation_matrix ( R , p ): ''' Rotate a point \"p\" by a rotation matrix \"R\". \"p\" must be a numpy array of three elements. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy array of three elements, same as the input \"p\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rp = np.matmul(R, p.reshape(3, 1)) return rp.flatten() ''' rp = np . matmul ( R , p . reshape ( 3 , 1 )) return rp . flatten () rotate_points_by_angle_axis ( ps , u ) Rotate points \"ps\" along the axis \"u\" by an angle which is the norm of \"u\". \"ps\" must a numpy 3-by-n array, and u must a numpy array of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). CAUTION: The input \"ps\" is now an array of vectors, where each vector is a column. Source code in code_fmkit/pyrotation.py def rotate_points_by_angle_axis ( ps , u ): ''' Rotate points \"ps\" along the axis \"u\" by an angle which is the norm of \"u\". \"ps\" must a numpy 3-by-n array, and u must a numpy array of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). CAUTION: The input \"ps\" is now an array of vectors, where each vector is a column. ''' angle = np . linalg . norm ( u ) if fabs ( angle ) < EPSILON : return ps else : # normalize the axis vector u = u / np . linalg . norm ( u ) u = u . reshape (( 3 , 1 )) # CAUTION: since ps is an array of vectors, pp should be the dot # product of each vector with u to obtain an array of scalars, then # multiply each scalar with u to form an array of vectors. pp = np . matmul ( u , np . matmul ( u . T , ps )) pv = ps - pp # CAUTION: numpy uses the last axis to define vectors in the cross # product with arrays of vectors u_x_cross = np . cross ( u . T , ps . T ) . T rps = pp + pv * np . cos ( angle ) + u_x_cross * np . sin ( angle ) return rps rotate_points_by_rotation_matrix ( R , ps ) Rotate points array \"ps\" by a rotation matrix \"R\". \"ps\" must be a numpy 3-by-n matrix where. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy 3-by-n matrix, same as the input \"ps\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rps = np.matmul(R, ps) return rps Source code in code_fmkit/pyrotation.py def rotate_points_by_rotation_matrix ( R , ps ): ''' Rotate points array \"ps\" by a rotation matrix \"R\". \"ps\" must be a numpy 3-by-n matrix where. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy 3-by-n matrix, same as the input \"ps\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rps = np.matmul(R, ps) return rps ''' rps = np . matmul ( R , ps ) return rps rotation_matrix_from_orthonormal_basis ( ux , uy , uz ) Construct a 3-by-3 rotation matrix from a set of orthonormal basis vectors. Source code in code_fmkit/pyrotation.py def rotation_matrix_from_orthonormal_basis ( ux , uy , uz ): ''' Construct a 3-by-3 rotation matrix from a set of orthonormal basis vectors. ''' R = np . zeros (( 3 , 3 )) R [:, 0 ] = ux R [:, 1 ] = uy R [:, 2 ] = uz return R rotation_matrix_from_xy ( x , y ) Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the x-axis and the other is the y-axis. The z-axis is chosen accordingly. The x-axis is always preserved, and if the y-axis is not perpendicular to the x-axis, its projection on the YOZ plane defined by the x-axis will be the y-axis. NOTE: If the vector x has zero length, it is a degenerated case and it is set to (1, 0, 0) NOTE: If the vector y has zero length or if the vector y is in the same direction of the vector x, it is a degenerated case and the vector y is set to (0, 1, 0). CAUTION: No warning or exception is generated in the degenerated case! Source code in code_fmkit/pyrotation.py def rotation_matrix_from_xy ( x , y ): ''' Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the x-axis and the other is the y-axis. The z-axis is chosen accordingly. The x-axis is always preserved, and if the y-axis is not perpendicular to the x-axis, its projection on the YOZ plane defined by the x-axis will be the y-axis. NOTE: If the vector x has zero length, it is a degenerated case and it is set to (1, 0, 0) NOTE: If the vector y has zero length or if the vector y is in the same direction of the vector x, it is a degenerated case and the vector y is set to (0, 1, 0). CAUTION: No warning or exception is generated in the degenerated case! ''' v1 = x v2 = y v1_default = np . asarray (( 1 , 0 , 0 )) v2_default = np . asarray (( 0 , 1 , 0 )) u1 , u2 , u3 = orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) R = rotation_matrix_from_orthonormal_basis ( u1 , u2 , u3 ) return R rotation_matrix_from_yz ( y , z ) Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! Source code in code_fmkit/pyrotation.py def rotation_matrix_from_yz ( y , z ): ''' Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! ''' v1 = y v2 = z v1_default = np . asarray (( 0 , 1 , 0 )) v2_default = np . asarray (( 0 , 0 , 1 )) u1 , u2 , u3 = orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) R = rotation_matrix_from_orthonormal_basis ( u3 , u1 , u2 ) return R rotation_matrix_from_zx ( z , x ) Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! Source code in code_fmkit/pyrotation.py def rotation_matrix_from_zx ( z , x ): ''' Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! ''' v1 = z v2 = x v1_default = np . asarray (( 0 , 0 , 1 )) v2_default = np . asarray (( 1 , 0 , 0 )) u1 , u2 , u3 = orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) R = rotation_matrix_from_orthonormal_basis ( u2 , u3 , u1 ) return R rotation_matrix_to_angle_axis ( R ) Convert a rotation matrix to an angle-axis representation. NOTE: The returned rotation angle is between 0 and pi. CAUTION: For numerical stability, small angle rotations are considered as no rotation. CAUTION: In the degenerated case, where the rotation angle is zero, the axis is set to (0, 0, 1), i.e., the z-axis. Source code in code_fmkit/pyrotation.py def rotation_matrix_to_angle_axis ( R ): ''' Convert a rotation matrix to an angle-axis representation. NOTE: The returned rotation angle is between 0 and pi. CAUTION: For numerical stability, small angle rotations are considered as no rotation. CAUTION: In the degenerated case, where the rotation angle is zero, the axis is set to (0, 0, 1), i.e., the z-axis. ''' # TODO: this might be buggy!!! # Check the determinant of R! It must be 1. assert fabs ( np . linalg . det ( R ) - 1 ) < EPSILON assert np . allclose ( np . matmul ( R , R . T ), np . identity ( 3 ), atol = EPSILON ) if np . allclose ( R , np . identity ( 3 )): u = np . asarray (( 0 , 0 , 0 )) else : angle = acos (( np . trace ( R ) - 1 ) / 2 ) s = 2 * sin ( angle ) x = ( R [ 2 , 1 ] - R [ 1 , 2 ]) / s y = ( R [ 0 , 2 ] - R [ 2 , 0 ]) / s z = ( R [ 1 , 0 ] - R [ 0 , 1 ]) / s u = np . asarray (( x , y , z )) u = u / np . linalg . norm ( u ) u = u * angle return u rotation_matrix_to_euler_angles_zyx ( R ) Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation. CAUTION: Euler angles have a singularity when pitch = pi / 2 or - pi / 2, i.e., gimbal lock. In this case, yaw and roll angles can not be determined uniquely, and this function always return a zero yaw angle. Source code in code_fmkit/pyrotation.py def rotation_matrix_to_euler_angles_zyx ( R ): ''' Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation. CAUTION: Euler angles have a singularity when pitch = pi / 2 or - pi / 2, i.e., gimbal lock. In this case, yaw and roll angles can not be determined uniquely, and this function always return a zero yaw angle. ''' if fabs ( fabs ( R [ 2 , 0 ]) - 1 ) < EPSILON : # cos(y) != 0, gimbal lock # CAUTION: y is always pi/2, and z is always 0 y = copysign ( pi / 2 , - R [ 2 , 0 ]) x = 0 z = atan2 ( R [ 0 , 1 ], R [ 0 , 2 ]) gimbal_lock = True #print('gimbal lock!!!') else : # cos(y) == 0, normal situation # CAUTION: y is always in [-pi/2, pi/2] y = - asin ( R [ 2 , 0 ]) cy = cos ( y ) x = atan2 ( R [ 2 , 1 ] / cy , R [ 2 , 2 ] / cy ) z = atan2 ( R [ 1 , 0 ] / cy , R [ 0 , 0 ] / cy ) gimbal_lock = False return z , y , x , gimbal_lock skew_symmetric_matrix_to_vector ( M ) Return the vector that corresponds to the skew matrix M. Assume: m = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] Then: v = (x, y, z) CAUTION: this function does not check whether the matrix is really a skew symmetric matrix! It assumes the input is correct! The input must be a numpy 3-by-3 matrix! Source code in code_fmkit/pyrotation.py def skew_symmetric_matrix_to_vector ( M ): ''' Return the vector that corresponds to the skew matrix M. Assume: m = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] Then: v = (x, y, z) CAUTION: this function does not check whether the matrix is really a skew symmetric matrix! It assumes the input is correct! The input must be a numpy 3-by-3 matrix! ''' x = M [ 2 , 1 ] y = M [ 0 , 2 ] z = M [ 1 , 0 ] return np . asarray (( x , y , z )) vector_to_skew_symmetric_matrix ( v ) Return the skew matrix M constructed by vector v, i.e., Assume: v = (x, y, z) Then: M = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] Source code in code_fmkit/pyrotation.py def vector_to_skew_symmetric_matrix ( v ): ''' Return the skew matrix M constructed by vector v, i.e., Assume: v = (x, y, z) Then: M = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] ''' x = v [ 0 ] y = v [ 1 ] z = v [ 2 ] M = np . asarray (( ( 0 , - z , y ), ( z , 0 , - x ), ( - y , x , 0 ) )) return M","title":"pyrotation"},{"location":"pyrotation-reference/#pyrotation-module","text":"","title":"pyrotation module"},{"location":"pyrotation-reference/#pyrotation","text":"This file is part of the pyrotation python module, which is designed to help teaching and learning the math of 3D rotation. This file contains the core class and functions of 3D rotation. Author: Duo Lu duolu.cs@gmail.com Version: 0.1 License: MIT Updated on Jan. 28, 2020, version 0.1 Created on Mar 22, 2019, draft The MIT License Copyright 2017-2021 Duo Lu < duolu.cs@gmail.com > Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"pyrotation"},{"location":"pyrotation-reference/#pyrotation.Quaternion","text":"The class representing a quaternion in Hamiltonian convention. !!! note \"The Quaternion object is designed to be immutable after construction.\"","title":"Quaternion"},{"location":"pyrotation-reference/#pyrotation.Quaternion.__init__","text":"Constructor, wchich expects the four components of a quaternion. Source code in code_fmkit/pyrotation.py def __init__ ( self , w , x , y , z ): ''' Constructor, wchich expects the four components of a quaternion. ''' self . w = float ( w ) self . x = float ( x ) self . y = float ( y ) self . z = float ( z )","title":"__init__()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.add_quaternion","text":"Quaternion addition. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def add_quaternion ( self , q ): ''' Quaternion addition. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' w_add = self . w + q . w x_add = self . x + q . x y_add = self . y + q . y z_add = self . z + q . z return Quaternion ( w_add , x_add , y_add , z_add )","title":"add_quaternion()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.angle_axis_to_quaternion","text":"Convert an angle-axis representation of a 3D rotation to a unit quaternion. This is essentially the exponential map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_angle_axis(u) See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (101). Source code in code_fmkit/pyrotation.py @staticmethod def angle_axis_to_quaternion ( u ): ''' Convert an angle-axis representation of a 3D rotation to a unit quaternion. This is essentially the exponential map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_angle_axis(u) See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (101). ''' angle = np . linalg . norm ( u ) if angle < EPSILON : w = 1.0 x = 0.0 y = 0.0 z = 0.0 else : u = u / angle w = cos ( angle / 2 ) s = sin ( angle / 2 ) x = u [ 0 ] * s y = u [ 1 ] * s z = u [ 2 ] * s return w , x , y , z","title":"angle_axis_to_quaternion()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.conjugate","text":"Return the conjugate of this quaternion. Notation: q* is q.conjugate() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def conjugate ( self ): ''' Return the conjugate of this quaternion. Notation: q* is q.conjugate() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' return Quaternion ( self . w , - self . x , - self . y , - self . z )","title":"conjugate()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.construct_from_angle_axis","text":"Construct a quaternion from angle-axis representation of a rotation. This is essentially the exponential map. Source code in code_fmkit/pyrotation.py @classmethod def construct_from_angle_axis ( cls , u ): ''' Construct a quaternion from angle-axis representation of a rotation. This is essentially the exponential map. ''' w , x , y , z = cls . angle_axis_to_quaternion ( u ) q = cls ( w , x , y , z ) q = q . normalize () return q","title":"construct_from_angle_axis()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.construct_from_rotation_matrix","text":"Construct a quaternion from a rotation matrix. Source code in code_fmkit/pyrotation.py @classmethod def construct_from_rotation_matrix ( cls , R ): ''' Construct a quaternion from a rotation matrix. ''' w , x , y , z = cls . rotation_matrix_to_quaternion ( R ) q = cls ( w , x , y , z ) #q = q.normalize() return q","title":"construct_from_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.differentiate_local","text":"Given two quaternions representing two poses q1 and q2, and assuming q2 is derived by a rotation from the first psoe q1 during a timestep, this method returns the angular speed (i.e., omega) of the local reference frame respect to pose q1. This is exactly the inverse of integrate_local(). Source code in code_fmkit/pyrotation.py @classmethod def differentiate_local ( cls , q1 , q2 , timestep ): ''' Given two quaternions representing two poses q1 and q2, and assuming q2 is derived by a rotation from the first psoe q1 during a timestep, this method returns the angular speed (i.e., omega) of the local reference frame respect to pose q1. This is exactly the inverse of integrate_local(). ''' delta_q = q1 . conjugate () . multiply_quaternion ( q2 ) u = delta_q . to_angle_axis () omega = u / timestep return omega","title":"differentiate_local()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.identity","text":"Return the identity unit quaternion (1, 0, 0, 0). Source code in code_fmkit/pyrotation.py @classmethod def identity ( cls ): ''' Return the identity unit quaternion (1, 0, 0, 0). ''' return cls ( 1 , 0 , 0 , 0 )","title":"identity()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.integrate_local","text":"Integrate instantanious angular velocity (i.e., omega) to the quaternion q during the timestep. The result is also a quaternion. Note that the angular velocity is measured relative to the pose represented by this quaternion, i.e., consider the current pose is this quaternion and omega is measured by a gyroscope. Anguler velocity is in rad/sec, and timestep is in sec. Note that we use zeroth-order backward integration. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 4.6. Source code in code_fmkit/pyrotation.py @classmethod def integrate_local ( cls , q , omega , timestep ): ''' Integrate instantanious angular velocity (i.e., omega) to the quaternion q during the timestep. The result is also a quaternion. Note that the angular velocity is measured relative to the pose represented by this quaternion, i.e., consider the current pose is this quaternion and omega is measured by a gyroscope. Anguler velocity is in rad/sec, and timestep is in sec. Note that we use zeroth-order backward integration. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 4.6. ''' u = omega * timestep delta_q = cls . construct_from_angle_axis ( u ) p = q . multiply_quaternion ( delta_q ) return p","title":"integrate_local()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.interpolate","text":"Spherical linear interpolation (SLERP) given two orientations represented by the quaternion q0 and q1, and interpolation parameter t in [0, 1], such that the orientation will continuously change from q0 to q1 by rotating along a fixed axis when t changes. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 2.7. Source code in code_fmkit/pyrotation.py @classmethod def interpolate ( cls , q0 , q1 , t ): ''' Spherical linear interpolation (SLERP) given two orientations represented by the quaternion q0 and q1, and interpolation parameter t in [0, 1], such that the orientation will continuously change from q0 to q1 by rotating along a fixed axis when t changes. See Joan Sol\u00e0, \"Quanternion Kinematics\", section 2.7. ''' if t == 0 : return q0 elif t == 1 : return q1 elif t > 0 and t < 1 : delta_q = q0 . conjugate () . multiply_quaternion ( q1 ) u = delta_q . to_angle_axis () qut = cls . construct_from_angle_axis ( u * t ) qt = q0 . multiply_quaternion ( qut ) return qt else : err_str = 'Interpolation parameter t must be in [0, 1], ' \\ 'while t = %f !' % t raise ValueError ( err_str )","title":"interpolate()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.inverse","text":"Return the inverse of this quaternion. Notation: q-1 is q.inverse() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def inverse ( self ): ''' Return the inverse of this quaternion. Notation: q-1 is q.inverse() NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' w = self . w x = self . x y = self . y z = self . z a = 1 / ( w * w + x * x + y * y + z * z ) return Quaternion ( self . w * a , - self . x * a , - self . y * a , - self . z * a )","title":"inverse()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.multiply_quaternion","text":"Quaternion multiplication. Notation: r = p x q is r = p.multiply_quaternion(q), where \"x\" is quaternion multiplication. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def multiply_quaternion ( self , q ): ''' Quaternion multiplication. Notation: r = p x q is r = p.multiply_quaternion(q), where \"x\" is quaternion multiplication. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' if not isinstance ( q , Quaternion ): raise 'Can not multiply non-quaternion! q= %s ' % repr ( q ) pw = self . w px = self . x py = self . y pz = self . z qw = q . w qx = q . x qy = q . y qz = q . z w_mul = pw * qw - px * qx - py * qy - pz * qz x_mul = pw * qx + px * qw + py * qz - pz * qy y_mul = pw * qy - px * qz + py * qw + pz * qx z_mul = pw * qz + px * qy - py * qx + pz * qw return Quaternion ( w_mul , x_mul , y_mul , z_mul )","title":"multiply_quaternion()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.multiply_scaler","text":"Multiply each component with a scalar. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under scaling. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def multiply_scaler ( self , s ): ''' Multiply each component with a scalar. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under scaling. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' return Quaternion ( self . w * s , self . x * s , self . y * s , self . z * s )","title":"multiply_scaler()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.norm","text":"Return the norm of this quaternion. Notation: |q| is q.norm() Source code in code_fmkit/pyrotation.py def norm ( self ): ''' Return the norm of this quaternion. Notation: |q| is q.norm() ''' w = self . w x = self . x y = self . y z = self . z return sqrt ( w * w + x * x + y * y + z * z )","title":"norm()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.normalize","text":"Return a normalized unit quaternion based on this quaternion. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def normalize ( self ): ''' Return a normalized unit quaternion based on this quaternion. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' n = self . norm () w = self . w / n x = self . x / n y = self . y / n z = self . z / n return Quaternion ( w , x , y , z )","title":"normalize()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.quaternion_to_angle_axis","text":"Convert a unit quaternion representation of a 3D rotation to angle-axis representation. This is essentially the logrithmic map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. u = q.to_angle_axis(u) Source code in code_fmkit/pyrotation.py @staticmethod def quaternion_to_angle_axis ( w , x , y , z ): ''' Convert a unit quaternion representation of a 3D rotation to angle-axis representation. This is essentially the logrithmic map. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. u = q.to_angle_axis(u) ''' v_norm = sqrt ( x * x + y * y + z * z ) if v_norm < EPSILON : ux = 0 uy = 0 uz = 0 else : angle = 2 * atan2 ( v_norm , w ) ux = x * ( angle / v_norm ) uy = y * ( angle / v_norm ) uz = z * ( angle / v_norm ) u = np . asarray (( ux , uy , uz )) return u","title":"quaternion_to_angle_axis()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.quaternion_to_rotation_matrix","text":"Convert a unit quaternion to a rotation matrix. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. R = q.to_rotation_matrix() Source code in code_fmkit/pyrotation.py @staticmethod def quaternion_to_rotation_matrix ( w , x , y , z ): ''' Convert a unit quaternion to a rotation matrix. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. R = q.to_rotation_matrix() ''' w2 = w * w x2 = x * x y2 = y * y z2 = z * z # Check the norm of the quaternion! It must be a unit quaternion! assert fabs ( w2 + x2 + y2 + z2 - 1 ) < 1e-6 wx = 2 * w * x wy = 2 * w * y wz = 2 * w * z xy = 2 * x * y xz = 2 * x * z yz = 2 * y * z R = np . asarray (( ( w2 + x2 - y2 - z2 , xy - wz , xz + wy ), ( xy + wz , w2 - x2 + y2 - z2 , yz - wx ), ( xz - wy , yz + wx , w2 - x2 - y2 + z2 ) )) return R","title":"quaternion_to_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.rotate_a_point","text":"Rotate a single 3D point based on this quaternion. The input point is a numpy array of three element. Internally, it is converted to a vector v = (0, x, y, z) and use the following equation. v' = q x v x q* where x is quaternion multiplication. The implementation uses the following matrix-based method, q x v x p = (q x v) x p = p_R * q_L * v = q x (v x p) = q_L * p_R * v Source code in code_fmkit/pyrotation.py def rotate_a_point ( self , p ): ''' Rotate a single 3D point based on this quaternion. The input point is a numpy array of three element. Internally, it is converted to a vector v = (0, x, y, z) and use the following equation. v' = q x v x q* where x is quaternion multiplication. The implementation uses the following matrix-based method, q x v x p = (q x v) x p = p_R * q_L * v = q x (v x p) = q_L * p_R * v ''' q_L = self . to_left_matrix () qc_R = self . conjugate () . to_right_matrix () v = np . asarray (( 0 , p [ 0 ], p [ 1 ], p [ 2 ])) . reshape (( 4 , 1 )) r = np . matmul ( qc_R , np . matmul ( q_L , v )) return np . asarray (( r [ 1 ], r [ 2 ], r [ 3 ])) . reshape ( 3 )","title":"rotate_a_point()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.rotate_points","text":"Rotate an array of points. The input points are a numpy 3-by-n matrix, where each point is a column. Source code in code_fmkit/pyrotation.py def rotate_points ( self , ps ): ''' Rotate an array of points. The input points are a numpy 3-by-n matrix, where each point is a column. ''' q_L = self . to_left_matrix () qc_R = self . conjugate () . to_right_matrix () vs = np . zeros (( 4 , ps . shape [ 1 ]), ps . dtype ) vs [ 1 : 4 , :] = ps rs = np . matmul ( qc_R , np . matmul ( q_L , vs )) return rs [ 1 : 4 , :]","title":"rotate_points()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.rotation_matrix_to_quaternion","text":"Convert a rotation matrix to a unit quaternion. This uses the Shepperd\u2019s method for numerical stabilty. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_rotation_matrix(R) Source code in code_fmkit/pyrotation.py @staticmethod def rotation_matrix_to_quaternion ( R ): ''' Convert a rotation matrix to a unit quaternion. This uses the Shepperd\u2019s method for numerical stabilty. This function is only for internal usage. Please use the following instead when it is needed to do this conversion. q = Quaternion.construct_from_rotation_matrix(R) ''' # The rotation matrix must be orthonormal assert np . allclose ( np . dot ( R , R . transpose ()), np . eye ( 3 ), atol = EPSILON ) # Check the determinant of R! It must be 1. assert math . isclose ( np . linalg . det ( R ), 1 , abs_tol = EPSILON ) w2 = ( 1 + R [ 0 , 0 ] + R [ 1 , 1 ] + R [ 2 , 2 ]) x2 = ( 1 + R [ 0 , 0 ] - R [ 1 , 1 ] - R [ 2 , 2 ]) y2 = ( 1 - R [ 0 , 0 ] + R [ 1 , 1 ] - R [ 2 , 2 ]) z2 = ( 1 - R [ 0 , 0 ] - R [ 1 , 1 ] + R [ 2 , 2 ]) yz = ( R [ 1 , 2 ] + R [ 2 , 1 ]) xz = ( R [ 2 , 0 ] + R [ 0 , 2 ]) xy = ( R [ 0 , 1 ] + R [ 1 , 0 ]) wx = ( R [ 2 , 1 ] - R [ 1 , 2 ]) wy = ( R [ 0 , 2 ] - R [ 2 , 0 ]) wz = ( R [ 1 , 0 ] - R [ 0 , 1 ]) if R [ 2 , 2 ] < 0 : if R [ 0 , 0 ] > R [ 1 , 1 ]: x = sqrt ( x2 ) w = wx / x y = xy / x z = xz / x else : y = sqrt ( y2 ) w = wy / y x = xy / y z = yz / y else : if R [ 0 , 0 ] < - R [ 1 , 1 ]: z = sqrt ( z2 ) w = wz / z x = xz / z y = yz / z else : w = sqrt ( w2 ) x = wx / w y = wy / w z = wz / w w = w * 0.5 x = x * 0.5 y = y * 0.5 z = z * 0.5 return w , x , y , z","title":"rotation_matrix_to_quaternion()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.subtract_quaternion","text":"Quaternion subtraction. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. Source code in code_fmkit/pyrotation.py def subtract_quaternion ( self , q ): ''' Quaternion subtraction. NOTE: Do not use this when dealing with unit quaternion, since unit quaterion is not closed under addition. NOTE: A new quaternion object is returned as the result. This quaternion is not changed. ''' w_sub = self . w - q . w x_sub = self . x - q . x y_sub = self . y - q . y z_sub = self . z - q . z return Quaternion ( w_sub , x_sub , y_sub , z_sub )","title":"subtract_quaternion()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.to_angle_axis","text":"Convert this quaternion to angle-axis representation of rotation. This is the reverse of construct_from_angle_axis() This is essentially the logarithmic map. See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (106). CAUTION: This must be a unit quaternion! Source code in code_fmkit/pyrotation.py def to_angle_axis ( self ): ''' Convert this quaternion to angle-axis representation of rotation. This is the reverse of construct_from_angle_axis() This is essentially the logarithmic map. See Joan Sol\u00e0, \"Quaternion Kinematics\", section 2.4, eqation (106). CAUTION: This must be a unit quaternion! ''' assert ( fabs ( self . norm () - 1 ) < EPSILON ) w = self . w x = self . x y = self . y z = self . z return self . quaternion_to_angle_axis ( w , x , y , z )","title":"to_angle_axis()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.to_left_matrix","text":"Return the left matrix of this quaternion. Notation: p_L = p.to_left_matrix() p x q = p_L * q, where \"*\" is matrix multiplication, and q can be considered as a 4 by 1 matrix. Source code in code_fmkit/pyrotation.py def to_left_matrix ( self ): ''' Return the left matrix of this quaternion. Notation: p_L = p.to_left_matrix() p x q = p_L * q, where \"*\" is matrix multiplication, and q can be considered as a 4 by 1 matrix. ''' w = self . w x = self . x y = self . y z = self . z M = np . asarray (( ( w , - x , - y , - z ), ( x , w , - z , y ), ( y , z , w , - x ), ( z , - y , x , w ) )) return M","title":"to_left_matrix()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.to_right_matrix","text":"Return the right matrix of this quaternion. Notation: q_R is q.to_right_matrix() p x q = q_R * p, where \"*\" is matrix multiplication, and q is considered as a 4 by 1 matrix. Source code in code_fmkit/pyrotation.py def to_right_matrix ( self ): ''' Return the right matrix of this quaternion. Notation: q_R is q.to_right_matrix() p x q = q_R * p, where \"*\" is matrix multiplication, and q is considered as a 4 by 1 matrix. ''' w = self . w x = self . x y = self . y z = self . z M = np . asarray (( ( w , - x , - y , - z ), ( x , w , z , - y ), ( y , - z , w , x ), ( z , y , - x , w ) )) return M","title":"to_right_matrix()"},{"location":"pyrotation-reference/#pyrotation.Quaternion.to_rotation_matrix","text":"Convert this unit quaternion to a rotation matrix. CAUTION: This must be a unit quaternion! Source code in code_fmkit/pyrotation.py def to_rotation_matrix ( self ): ''' Convert this unit quaternion to a rotation matrix. CAUTION: This must be a unit quaternion! ''' assert ( fabs ( self . norm () - 1 ) < EPSILON ) w = self . w x = self . x y = self . y z = self . z return self . quaternion_to_rotation_matrix ( w , x , y , z )","title":"to_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.alt_azimuth_to_axis","text":"Calculate an axis represented by a unit vector using alt and azimuth angles. NOTE: alt and azimuth are in degree, not radian. The output axis is always a unit vector. Source code in code_fmkit/pyrotation.py def alt_azimuth_to_axis ( alt_degree , azimuth_degree ): ''' Calculate an axis represented by a unit vector using alt and azimuth angles. NOTE: alt and azimuth are in degree, not radian. The output axis is always a unit vector. ''' alt_radian = alt_degree * np . pi / 180 azimuth_radian = azimuth_degree * np . pi / 180 ux = cos ( alt_radian ) * cos ( azimuth_radian ) uy = cos ( alt_radian ) * sin ( azimuth_radian ) uz = sin ( alt_radian ) u = np . asarray (( ux , uy , uz )) u = u / np . linalg . norm ( u ) return u","title":"alt_azimuth_to_axis()"},{"location":"pyrotation-reference/#pyrotation.angle_axis_to_rotation_matrix","text":"Convert angle-axis representation of rotation to a rotation matrix, using the Rodrigues formula. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). Source code in code_fmkit/pyrotation.py def angle_axis_to_rotation_matrix ( u ): ''' Convert angle-axis representation of rotation to a rotation matrix, using the Rodrigues formula. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). ''' angle = np . linalg . norm ( u ) I = np . identity ( 3 ) if angle < EPSILON : return I else : # normalize the axis vector u = u / np . linalg . norm ( u ) ux = vector_to_skew_symmetric_matrix ( u ) uut = np . matmul ( u . reshape (( 3 , 1 )), u . reshape ( 1 , 3 )) R = I * cos ( angle ) + ux * sin ( angle ) + uut * ( 1 - cos ( angle )) return R","title":"angle_axis_to_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.axis_to_alt_azimuth","text":"Calculate the alt and azimuth angles from an axis vector \"u\". NOTE: alt and azimuth are in degree, not radian. CAUTION: In the degenerated case, where the norm of the vector u is zero, i.e., the vector u is pointting to the z-axis or the opposite of the z-axis, the output alt is set to plus/minus 90 degrees and the azimuth to zero degrees. Source code in code_fmkit/pyrotation.py def axis_to_alt_azimuth ( u ): ''' Calculate the alt and azimuth angles from an axis vector \"u\". NOTE: alt and azimuth are in degree, not radian. CAUTION: In the degenerated case, where the norm of the vector u is zero, i.e., the vector u is pointting to the z-axis or the opposite of the z-axis, the output alt is set to plus/minus 90 degrees and the azimuth to zero degrees. ''' u_norm = np . linalg . norm ( u ) if fabs ( fabs ( u_norm ) - 1 ) < EPSILON : degenerated = True alt = 90 azimuth = 0 gimbal_lock = False else : degenerated = False u = u / u_norm if fabs ( u [ 2 ] - 1 ) < EPSILON : # CAUTION: if u is pointing to the z-axis, the result is degenerated, # i.e., azimuth is undefined. alt = 90 azimuth = 0 gimbal_lock = True elif fabs ( u [ 2 ] + 1 ) < EPSILON : # Similarly, if u is pointing to the opposite of the z-axis, azimuth is # also undefined. alt = - 90 azimuth = 0 gimbal_lock = True else : alt = asin ( u [ 2 ]) c = cos ( alt ) dx = u [ 0 ] / c dy = u [ 1 ] / c azimuth = atan2 ( dy , dx ) alt = alt * 180 / pi azimuth = azimuth * 180 / pi gimbal_lock = False return alt , azimuth , gimbal_lock , degenerated","title":"axis_to_alt_azimuth()"},{"location":"pyrotation-reference/#pyrotation.euler_zyx_to_rotation_matrix","text":"Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation, i.e., using the following, R = R_z * R_y * R_x where, R_z = [ cos(z) -sin(z) 0 ] [ sin(z) cos(z) 0 ] [ 0 0 1 ] R_y = [ cos(y) 0 sin(y) ] [ 0 1 0 ] [ -sin(y) 0 cos(y) ] R_x = [ 1 0 0 ] [ 0 cos(x) -sin(x) ] [ 0 sin(x) cos(x) ] Also, the angles are named as following, z - yaw (psi) y - pitch (theta) x - roll (phi) These angles are also called Tait-Bryan angles, and we use the z-y'-x\" intrinsic convention. See this for the conventions: https://en.wikipedia.org/wiki/Euler_angles#Tait\u2013Bryan_angles Also see this for the conversion between different representations: https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimension Caution: The three input angles are in radian! Source code in code_fmkit/pyrotation.py def euler_zyx_to_rotation_matrix ( z , y , x ): ''' Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation, i.e., using the following, R = R_z * R_y * R_x where, R_z = [ cos(z) -sin(z) 0 ] [ sin(z) cos(z) 0 ] [ 0 0 1 ] R_y = [ cos(y) 0 sin(y) ] [ 0 1 0 ] [ -sin(y) 0 cos(y) ] R_x = [ 1 0 0 ] [ 0 cos(x) -sin(x) ] [ 0 sin(x) cos(x) ] Also, the angles are named as following, z - yaw (psi) y - pitch (theta) x - roll (phi) These angles are also called Tait-Bryan angles, and we use the z-y'-x\" intrinsic convention. See this for the conventions: https://en.wikipedia.org/wiki/Euler_angles#Tait\u2013Bryan_angles Also see this for the conversion between different representations: https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimension Caution: The three input angles are in radian! ''' sz = np . sin ( z ) cz = np . cos ( z ) sy = np . sin ( y ) cy = np . cos ( y ) sx = np . sin ( x ) cx = np . cos ( x ) a11 = cz * cy a12 = cz * sy * sx - cx * sz a13 = sz * sx + cz * cx * sy a21 = cy * sz a22 = cz * cx + sz * sy * sx a23 = cx * sz * sy - cz * sx a31 = - sy a32 = cy * sx a33 = cy * cx R = np . asarray ([[ a11 , a12 , a13 ], [ a21 , a22 , a23 ], [ a31 , a32 , a33 ]]) return R","title":"euler_zyx_to_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.normalize_rotation_matrix","text":"Normalize a rotation matrix with SVD, i.e., using the following step. u, s, vh = np.linalg.svd(R) return np.matmul(u, vh) Source code in code_fmkit/pyrotation.py def normalize_rotation_matrix ( R ): ''' Normalize a rotation matrix with SVD, i.e., using the following step. u, s, vh = np.linalg.svd(R) return np.matmul(u, vh) ''' u , s , vh = np . linalg . svd ( R ) del s return np . matmul ( u , vh )","title":"normalize_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.orthonormal_basis_from_two_vectors","text":"Construct three orthonormal basis vectors from arbitrary two vectors. The output orthonormal basis (u1, u2, u3) has the following properties. (1) The vector u1 is in the direction of v1. If v1 is all zero, v1_default is used instead. (2) The vector u2 is in the same plane spanned by v1 and v2, and u2 is perpendicular to v1, i.e., their dot product is zero. If v2 is all zero or if v2 has the same direction as v1, v2_default is used instead. (3) The vector u3 is perpendicular to the plane spanned by v1 and v2. Source code in code_fmkit/pyrotation.py def orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ): ''' Construct three orthonormal basis vectors from arbitrary two vectors. The output orthonormal basis (u1, u2, u3) has the following properties. (1) The vector u1 is in the direction of v1. If v1 is all zero, v1_default is used instead. (2) The vector u2 is in the same plane spanned by v1 and v2, and u2 is perpendicular to v1, i.e., their dot product is zero. If v2 is all zero or if v2 has the same direction as v1, v2_default is used instead. (3) The vector u3 is perpendicular to the plane spanned by v1 and v2. ''' n1 = np . linalg . norm ( v1 ) n2 = np . linalg . norm ( v2 ) v3 = np . cross ( v1 , v2 ) n3 = np . linalg . norm ( v3 ) if fabs ( n1 ) < EPSILON : v1 = v1_default if fabs ( n2 ) < EPSILON or fabs ( n3 ) < EPSILON : v2 = v2_default u1 = v1 / np . linalg . norm ( v1 ) v3 = np . cross ( u1 , v2 ) u3 = v3 / np . linalg . norm ( v3 ) v2 = np . cross ( u3 , u1 ) u2 = v2 / np . linalg . norm ( v2 ) return u1 , u2 , u3","title":"orthonormal_basis_from_two_vectors()"},{"location":"pyrotation-reference/#pyrotation.rotate_a_point_by_angle_axis","text":"Rotate a point \"p\" along the axis \"u\" by an angle which is the norm of \"u\". Both \"p\" and \"u\" are numpy arrays of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). Source code in code_fmkit/pyrotation.py def rotate_a_point_by_angle_axis ( p , u ): ''' Rotate a point \"p\" along the axis \"u\" by an angle which is the norm of \"u\". Both \"p\" and \"u\" are numpy arrays of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). ''' angle = np . linalg . norm ( u ) if fabs ( angle ) < EPSILON : return p else : # normalize the axis vector u = u / np . linalg . norm ( u ) pp = np . dot ( p , u ) * u pv = p - pp u_x_cross = np . cross ( u , p ) rp = pp + pv * np . cos ( angle ) + u_x_cross * np . sin ( angle ) return rp","title":"rotate_a_point_by_angle_axis()"},{"location":"pyrotation-reference/#pyrotation.rotate_a_point_by_rotation_matrix","text":"Rotate a point \"p\" by a rotation matrix \"R\". \"p\" must be a numpy array of three elements. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy array of three elements, same as the input \"p\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rp = np.matmul(R, p.reshape(3, 1)) return rp.flatten() Source code in code_fmkit/pyrotation.py def rotate_a_point_by_rotation_matrix ( R , p ): ''' Rotate a point \"p\" by a rotation matrix \"R\". \"p\" must be a numpy array of three elements. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy array of three elements, same as the input \"p\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rp = np.matmul(R, p.reshape(3, 1)) return rp.flatten() ''' rp = np . matmul ( R , p . reshape ( 3 , 1 )) return rp . flatten ()","title":"rotate_a_point_by_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.rotate_points_by_angle_axis","text":"Rotate points \"ps\" along the axis \"u\" by an angle which is the norm of \"u\". \"ps\" must a numpy 3-by-n array, and u must a numpy array of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). CAUTION: The input \"ps\" is now an array of vectors, where each vector is a column. Source code in code_fmkit/pyrotation.py def rotate_points_by_angle_axis ( ps , u ): ''' Rotate points \"ps\" along the axis \"u\" by an angle which is the norm of \"u\". \"ps\" must a numpy 3-by-n array, and u must a numpy array of three elements. CAUTION: For numerical stability, small angle rotations are considered as no rotation (i.e., if angle < 1e-6 radian, angle is considered as zero). CAUTION: The input \"ps\" is now an array of vectors, where each vector is a column. ''' angle = np . linalg . norm ( u ) if fabs ( angle ) < EPSILON : return ps else : # normalize the axis vector u = u / np . linalg . norm ( u ) u = u . reshape (( 3 , 1 )) # CAUTION: since ps is an array of vectors, pp should be the dot # product of each vector with u to obtain an array of scalars, then # multiply each scalar with u to form an array of vectors. pp = np . matmul ( u , np . matmul ( u . T , ps )) pv = ps - pp # CAUTION: numpy uses the last axis to define vectors in the cross # product with arrays of vectors u_x_cross = np . cross ( u . T , ps . T ) . T rps = pp + pv * np . cos ( angle ) + u_x_cross * np . sin ( angle ) return rps","title":"rotate_points_by_angle_axis()"},{"location":"pyrotation-reference/#pyrotation.rotate_points_by_rotation_matrix","text":"Rotate points array \"ps\" by a rotation matrix \"R\". \"ps\" must be a numpy 3-by-n matrix where. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy 3-by-n matrix, same as the input \"ps\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rps = np.matmul(R, ps) return rps Source code in code_fmkit/pyrotation.py def rotate_points_by_rotation_matrix ( R , ps ): ''' Rotate points array \"ps\" by a rotation matrix \"R\". \"ps\" must be a numpy 3-by-n matrix where. \"R\" must be a numpy 3-by-3 matrix. The result is a numpy 3-by-n matrix, same as the input \"ps\". CAUTION: This function does not validate whether R is really a rotation matrix. It just do the following operations. rps = np.matmul(R, ps) return rps ''' rps = np . matmul ( R , ps ) return rps","title":"rotate_points_by_rotation_matrix()"},{"location":"pyrotation-reference/#pyrotation.rotation_matrix_from_orthonormal_basis","text":"Construct a 3-by-3 rotation matrix from a set of orthonormal basis vectors. Source code in code_fmkit/pyrotation.py def rotation_matrix_from_orthonormal_basis ( ux , uy , uz ): ''' Construct a 3-by-3 rotation matrix from a set of orthonormal basis vectors. ''' R = np . zeros (( 3 , 3 )) R [:, 0 ] = ux R [:, 1 ] = uy R [:, 2 ] = uz return R","title":"rotation_matrix_from_orthonormal_basis()"},{"location":"pyrotation-reference/#pyrotation.rotation_matrix_from_xy","text":"Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the x-axis and the other is the y-axis. The z-axis is chosen accordingly. The x-axis is always preserved, and if the y-axis is not perpendicular to the x-axis, its projection on the YOZ plane defined by the x-axis will be the y-axis. NOTE: If the vector x has zero length, it is a degenerated case and it is set to (1, 0, 0) NOTE: If the vector y has zero length or if the vector y is in the same direction of the vector x, it is a degenerated case and the vector y is set to (0, 1, 0). CAUTION: No warning or exception is generated in the degenerated case! Source code in code_fmkit/pyrotation.py def rotation_matrix_from_xy ( x , y ): ''' Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the x-axis and the other is the y-axis. The z-axis is chosen accordingly. The x-axis is always preserved, and if the y-axis is not perpendicular to the x-axis, its projection on the YOZ plane defined by the x-axis will be the y-axis. NOTE: If the vector x has zero length, it is a degenerated case and it is set to (1, 0, 0) NOTE: If the vector y has zero length or if the vector y is in the same direction of the vector x, it is a degenerated case and the vector y is set to (0, 1, 0). CAUTION: No warning or exception is generated in the degenerated case! ''' v1 = x v2 = y v1_default = np . asarray (( 1 , 0 , 0 )) v2_default = np . asarray (( 0 , 1 , 0 )) u1 , u2 , u3 = orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) R = rotation_matrix_from_orthonormal_basis ( u1 , u2 , u3 ) return R","title":"rotation_matrix_from_xy()"},{"location":"pyrotation-reference/#pyrotation.rotation_matrix_from_yz","text":"Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! Source code in code_fmkit/pyrotation.py def rotation_matrix_from_yz ( y , z ): ''' Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! ''' v1 = y v2 = z v1_default = np . asarray (( 0 , 1 , 0 )) v2_default = np . asarray (( 0 , 0 , 1 )) u1 , u2 , u3 = orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) R = rotation_matrix_from_orthonormal_basis ( u3 , u1 , u2 ) return R","title":"rotation_matrix_from_yz()"},{"location":"pyrotation-reference/#pyrotation.rotation_matrix_from_zx","text":"Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! Source code in code_fmkit/pyrotation.py def rotation_matrix_from_zx ( z , x ): ''' Construct three orthonormal basis, i.e., the rotation matrix, based on two vectors, where one of them is the y-axis and the other is the z-axis. The x-axis is chosen accordingly. The y-axis is always preserved, and if the z-axis is not perpendicular to the y-axis, its projection on the ZOX plane defined by the y-axis will be the z-axis. NOTE: If the vector y has zero length, it is a degenerated case and it is set to (0, 1, 0) NOTE: If the vector z has zero length or if the vector z is in the same direction of the vector y, it is a degenerated case and the vector z is set to (0, 0, 1). CAUTION: No warning or exception is generated in the degenerated case! ''' v1 = z v2 = x v1_default = np . asarray (( 0 , 0 , 1 )) v2_default = np . asarray (( 1 , 0 , 0 )) u1 , u2 , u3 = orthonormal_basis_from_two_vectors ( v1 , v2 , v1_default , v2_default ) R = rotation_matrix_from_orthonormal_basis ( u2 , u3 , u1 ) return R","title":"rotation_matrix_from_zx()"},{"location":"pyrotation-reference/#pyrotation.rotation_matrix_to_angle_axis","text":"Convert a rotation matrix to an angle-axis representation. NOTE: The returned rotation angle is between 0 and pi. CAUTION: For numerical stability, small angle rotations are considered as no rotation. CAUTION: In the degenerated case, where the rotation angle is zero, the axis is set to (0, 0, 1), i.e., the z-axis. Source code in code_fmkit/pyrotation.py def rotation_matrix_to_angle_axis ( R ): ''' Convert a rotation matrix to an angle-axis representation. NOTE: The returned rotation angle is between 0 and pi. CAUTION: For numerical stability, small angle rotations are considered as no rotation. CAUTION: In the degenerated case, where the rotation angle is zero, the axis is set to (0, 0, 1), i.e., the z-axis. ''' # TODO: this might be buggy!!! # Check the determinant of R! It must be 1. assert fabs ( np . linalg . det ( R ) - 1 ) < EPSILON assert np . allclose ( np . matmul ( R , R . T ), np . identity ( 3 ), atol = EPSILON ) if np . allclose ( R , np . identity ( 3 )): u = np . asarray (( 0 , 0 , 0 )) else : angle = acos (( np . trace ( R ) - 1 ) / 2 ) s = 2 * sin ( angle ) x = ( R [ 2 , 1 ] - R [ 1 , 2 ]) / s y = ( R [ 0 , 2 ] - R [ 2 , 0 ]) / s z = ( R [ 1 , 0 ] - R [ 0 , 1 ]) / s u = np . asarray (( x , y , z )) u = u / np . linalg . norm ( u ) u = u * angle return u","title":"rotation_matrix_to_angle_axis()"},{"location":"pyrotation-reference/#pyrotation.rotation_matrix_to_euler_angles_zyx","text":"Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation. CAUTION: Euler angles have a singularity when pitch = pi / 2 or - pi / 2, i.e., gimbal lock. In this case, yaw and roll angles can not be determined uniquely, and this function always return a zero yaw angle. Source code in code_fmkit/pyrotation.py def rotation_matrix_to_euler_angles_zyx ( R ): ''' Converting a rotation represented by three Euler angles (z-y'-x\") to rotation matrix represenation. CAUTION: Euler angles have a singularity when pitch = pi / 2 or - pi / 2, i.e., gimbal lock. In this case, yaw and roll angles can not be determined uniquely, and this function always return a zero yaw angle. ''' if fabs ( fabs ( R [ 2 , 0 ]) - 1 ) < EPSILON : # cos(y) != 0, gimbal lock # CAUTION: y is always pi/2, and z is always 0 y = copysign ( pi / 2 , - R [ 2 , 0 ]) x = 0 z = atan2 ( R [ 0 , 1 ], R [ 0 , 2 ]) gimbal_lock = True #print('gimbal lock!!!') else : # cos(y) == 0, normal situation # CAUTION: y is always in [-pi/2, pi/2] y = - asin ( R [ 2 , 0 ]) cy = cos ( y ) x = atan2 ( R [ 2 , 1 ] / cy , R [ 2 , 2 ] / cy ) z = atan2 ( R [ 1 , 0 ] / cy , R [ 0 , 0 ] / cy ) gimbal_lock = False return z , y , x , gimbal_lock","title":"rotation_matrix_to_euler_angles_zyx()"},{"location":"pyrotation-reference/#pyrotation.skew_symmetric_matrix_to_vector","text":"Return the vector that corresponds to the skew matrix M. Assume: m = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] Then: v = (x, y, z) CAUTION: this function does not check whether the matrix is really a skew symmetric matrix! It assumes the input is correct! The input must be a numpy 3-by-3 matrix! Source code in code_fmkit/pyrotation.py def skew_symmetric_matrix_to_vector ( M ): ''' Return the vector that corresponds to the skew matrix M. Assume: m = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] Then: v = (x, y, z) CAUTION: this function does not check whether the matrix is really a skew symmetric matrix! It assumes the input is correct! The input must be a numpy 3-by-3 matrix! ''' x = M [ 2 , 1 ] y = M [ 0 , 2 ] z = M [ 1 , 0 ] return np . asarray (( x , y , z ))","title":"skew_symmetric_matrix_to_vector()"},{"location":"pyrotation-reference/#pyrotation.vector_to_skew_symmetric_matrix","text":"Return the skew matrix M constructed by vector v, i.e., Assume: v = (x, y, z) Then: M = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] Source code in code_fmkit/pyrotation.py def vector_to_skew_symmetric_matrix ( v ): ''' Return the skew matrix M constructed by vector v, i.e., Assume: v = (x, y, z) Then: M = [ 0, -z, y ] [ z, 0, -x ] [ -y, x, 0 ] ''' x = v [ 0 ] y = v [ 1 ] z = v [ 2 ] M = np . asarray (( ( 0 , - z , y ), ( z , 0 , - x ), ( - y , x , 0 ) )) return M","title":"vector_to_skew_symmetric_matrix()"}]}